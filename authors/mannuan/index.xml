<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mannuan</title>
    <link>https://mannuan.github.io/authors/mannuan/</link>
    <description>Recent content on mannuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 28 Aug 2019 13:02:28 +0800</lastBuildDate>
    
	<atom:link href="https://mannuan.github.io/authors/mannuan/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>promise</title>
      <link>https://mannuan.github.io/post/20190828130228/</link>
      <pubDate>Wed, 28 Aug 2019 13:02:28 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190828130228/</guid>
      <description>参考链接
promise Promise的立即执行性 var p = new Promise(function(resolve, reject){ console.log(&amp;#34;create a promise&amp;#34;); resolve(&amp;#34;success&amp;#34;); }); console.log(&amp;#34;after new Promise&amp;#34;); p.then(function(value){ console.log(value); });  控制台输出 &amp;#34;create a promise&amp;#34; &amp;#34;after new Promise&amp;#34; &amp;#34;success&amp;#34;  总结 Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中&amp;rdquo;create a promise&amp;rdquo;先于&amp;rdquo;after new Promise&amp;rdquo;输出。
Promise 三种状态 var p1 = new Promise(function(resolve,reject){ resolve(1); }); var p2 = new Promise(function(resolve,reject){ setTimeout(function(){ resolve(2); }, 500); }); var p3 = new Promise(function(resolve,reject){ setTimeout(function(){ reject(3); }, 500); }); console.log(p1); console.log(p2); console.log(p3); setTimeout(function(){ console.</description>
    </item>
    
    <item>
      <title>flex</title>
      <link>https://mannuan.github.io/post/20190828095201/</link>
      <pubDate>Wed, 28 Aug 2019 09:52:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190828095201/</guid>
      <description>参考链接
flex 定义  Flex 是 Flexible Box 的缩写，意为&amp;rdquo;弹性布局&amp;rdquo;，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。  .box{ display: flex; }  行内元素也可以使用 Flex 布局。  .box{ display: inline-flex; }  Webkit 内核的浏览器，必须加上-webkit前缀。  .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
基本概念 flex container flex容器就是采用flex布局的元素
flex item flex项目
main axis 水平主轴
cross axis 垂直主轴
main start main axis的开始位置与边框的交叉点
main end main axis的结束位置
cross start cross axis的开始位置
cross end cross axis的结束位置</description>
    </item>
    
    <item>
      <title>项目分配</title>
      <link>https://mannuan.github.io/post/20190827212757/</link>
      <pubDate>Tue, 27 Aug 2019 21:27:58 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827212757/</guid>
      <description> 项目分配 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述： 某公司雇有N名员工，每名员工可以负责多个项目，但一个项目只能交由一名员工负责。现在该公司接到M个项目，令A_{i,j}表示第i名员工负责第j个项目所带来的收益，那么如果项目分配得当，总收益最大是多少？
输入 第一行包含两个整数N和M，1≤N，M≤1000。
接下来N行，每行包含M个整数，第i行的第j个整数表示A{i,j}，1≤A{i,j}≤1000。
输出 输出总收益的最大值。
样例输入 3 3
1 3 3
2 2 2
3 2 1
样例输出 9
# include&amp;lt;iostream&amp;gt;  using namespace std; int n,m,cost =0; int x[1001],c[1001][1001]; void work(int i, int count){ if(i&amp;gt;n&amp;amp;&amp;amp;count&amp;gt;cost){ cost=count; return ; } if(count&amp;gt;cost){ for(int j=1;j&amp;lt;=m;j++){ if(x[j]==0){ x[j] = 1; work(i+1, count+c[i][j]); x[j] =0; } } } } int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(int i=1;i&amp;lt;=n;i++){ for(int j=1;j&amp;lt;=m;j++){ cin&amp;gt;&amp;gt;c[i][j]; c[i][j] = -c[i][j]; x[j] = 0; } cost+=c[i][i]; } work(1, 0); cout&amp;lt;&amp;lt;-cost&amp;lt;&amp;lt;endl; return 0; } </description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://mannuan.github.io/post/20190827152635/</link>
      <pubDate>Tue, 27 Aug 2019 15:26:35 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827152635/</guid>
      <description>链表 定义 本质是线性表</description>
    </item>
    
    <item>
      <title>jquery</title>
      <link>https://mannuan.github.io/post/20190827144836/</link>
      <pubDate>Tue, 27 Aug 2019 14:48:36 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827144836/</guid>
      <description> jquery  链接 链接  </description>
    </item>
    
    <item>
      <title>selenium</title>
      <link>https://mannuan.github.io/post/20190827143841/</link>
      <pubDate>Tue, 27 Aug 2019 14:38:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827143841/</guid>
      <description>selenium webDriver原理 工作流程  打开浏览器并绑定到指定端口，作为remote server client通过commandExecuter发送httpRequest给remote server remote server 根据原生的浏览器组件来转化为浏览器的本地调用
元素定位 find_element_by_id
 find_element_by_name
 find_element_by_class_name
 find_element_by_tag_name
 find_element_by_link_text
 find_element_by_partial_link_text
 find_element_by_xpath 绝对定位
 find_element_by_css_selector
常见控件 button element.click()
Textbox,Upload element.send_keys()
MouseEvent double_click()
 context_click()
 drag_and_drop()
 move_to_element()
 perform()
Dropdown下拉菜单 select_by_index()
 select_by_value()
 select_by_visible_text()
Alert switch_to.alert.accept()
 switch_to.alert.dismiss()
 switch_to.alert.text()
 switch_to.alert.send_keys()
Window Driver.refresh()
 Driver.back()
 Driver.forward()
 Driver.maximize_window()
 Driver.set_window_size(100, 200)
 Driver.</description>
    </item>
    
    <item>
      <title>pyspider</title>
      <link>https://mannuan.github.io/post/20190827142620/</link>
      <pubDate>Tue, 27 Aug 2019 14:26:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827142620/</guid>
      <description> pyspider 数据库 sqlite mongodb mysql redis elasticsearch fetcher引擎 phantomjs puppeteer fetcher调用客户端 tornado 消息队列 python内置队列 multiprocessing.queues queue
高级消息队列协议 amqp
Beanstalk import beanstalkc kombu import kombu redis消息队列 import redis 页面框架 flask 架构流程 调度器 抓取器 处理器 页面代码, 比如pyquery
webui 可以监视这个流程
创建任务 on_start函数 self.crawl  @config修饰符  age单位秒 priority优先级，越高越好  exetime,几秒后执行 retries,重试次数 itag, 页面标记 auto_recrawl,重爬 method params, get, url参数 data, post，传输的数据 user_agent headers  也可以使用Handler.crawl_config cookies  connect_timeout timeout allow_redirects validate_cert proxy etag last_modified fetch_type js_script load_images save taskid force_update cancel  </description>
    </item>
    
    <item>
      <title>pyquery</title>
      <link>https://mannuan.github.io/post/20190827141725/</link>
      <pubDate>Tue, 27 Aug 2019 14:17:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827141725/</guid>
      <description>pyquery 定义 PyQuery支持下载网页为文本，是通过Requests实现的
导入包使用 from pyquery import PyQuery as pq pq = p(_str) 获取网页源代码 html()
获取网页中的文字 text()
根据指定索引号得到指定元素 eq(index)
根据类名、id名得到指定元素 filter()
查找嵌套元素 find()
获取或设置属性值 attr()
为元素添加类 addClass(value)
判断元素是否包含给定的类 hasClass(name)
获取子元素 children(selector=None)
获取父元素 parents(selector=None)
返回一个节点的拷贝 clone()
移除节点内容 empty()
返回后面全部的元素块 nextAll(selector=None)
返回不匹配选择器的元素 not_(selector)</description>
    </item>
    
    <item>
      <title>mongodb</title>
      <link>https://mannuan.github.io/post/20190827110733/</link>
      <pubDate>Tue, 27 Aug 2019 11:07:33 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190827110733/</guid>
      <description>mongodb 定义  非关系型数据库（没有特定的表结构），采用BSON存储文档数据 BSON( Binary Serialized Document Format) 采用c++编写  优点  面向文档存储，以json格式的文档存储数据 扩展性好（可以后续添加字段） 自动分片 查询功能丰富 即时更新  基本概念 字段 字段(field)对应列(column)
文档 数据库的基本单元，类似于关系型数据库的行
集合 一组文档，类似于关系型数据库中的表
数据库 每个数据库都有自己的集合和权限
ObjectID 时间戳(4字节，记录文档创建时间)+客户端ID(3字节，用来标识不同客户端)+客户端进程ID(2字节，用来区分不同进程创建的ObjectID)+自增字段(3字节，确保同一秒产生的ObjectID的唯一性)。
相当于数据库中的主键
命令行工具 javascriptshell
数据类型 null 表示空值或未定义的对象
布尔值 32位整数 shell不支持，默认转为64位浮点数
64位整数 shell不支持，默认转为64位浮点数
64位浮点数 shell使用的数据类型
字符串 utf-8字符串
符号 shell不支持, 自动转为字符串
ObjectID 12个字节
日期 从标准纪元开始的毫秒数
正则表达式 遵循javascript的正则表达式语法
代码 可以包含javascript代码
undefined 数组 值的集合或列表
内嵌文档 最大值 BSON包括一个特殊类型，表示可能的最大值。shell中没有这个类型。
最小值 BSON包括一个特殊类型，表示可能的最小值。shell中没有这个类型。
具体使用 切换数据库 use 数据库名称
显示数据库列表 show dbs</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://mannuan.github.io/post/20190826224619/</link>
      <pubDate>Mon, 26 Aug 2019 22:46:19 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190826224619/</guid>
      <description> 设计模式 javascript中的设计模式 工厂模式 构造函数模式 考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节
原型模式 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
组合模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式 其他常用设计模式 单例模式  单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点；  享元模式 优点 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
缺点  为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。  装饰模式 优点  采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。
缺点 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。
  代理模式 优点  代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
 增加了系统的复杂度；
  观察者模式 优点  降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。
缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
  适配器模式 优点  客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。  缺点  对类适配器来说，更换适配器的实现过程比较复杂  </description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://mannuan.github.io/post/20190826170328/</link>
      <pubDate>Mon, 26 Aug 2019 17:03:28 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190826170328/</guid>
      <description>数组去重 最简洁的做法 function unique(arr){ return [...new Set(arr)]; }  对象属性的唯一性 function unique(arr){ let res = []; let obj = new Object(); arr.forEach(e =&amp;gt; { if(!obj[e]){ obj[e] = 1; res.push(e); } }); return res; }  一般的做法 function unique(arr){ let seen = []; arr.forEach(e =&amp;gt; { if(seen.indexOf(e) &amp;lt; 0){ seen.push(e); } }); return seen; } console.log(unique([1,1,1,1,3,4]));  python实现-普通做法 def unique(arr): seen = [] for i in arr: if i not in seen: seen.</description>
    </item>
    
    <item>
      <title>判断一个单词是否是回文</title>
      <link>https://mannuan.github.io/post/20190826162047/</link>
      <pubDate>Mon, 26 Aug 2019 16:20:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190826162047/</guid>
      <description> 判断一个单词是否是回文  回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider.
很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。
 function isHuiWen(str){ return str == str.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;); } def isHuiWen(_str): return _str == &amp;#34;&amp;#34;.join(_str.split()[::-1])# include&amp;lt;iostream&amp;gt;  # include&amp;lt;cstring&amp;gt;  # include&amp;lt;cstdlib&amp;gt;  using namespace std; int main(){ string str; bool flag = true; cin&amp;gt;&amp;gt;str; for(int i=0,j=str.size()-1;i&amp;lt;str.size();i++, j--){ if(str[i] != str[j]){ flag = false; } } if(flag){ cout&amp;lt;&amp;lt;&amp;#34;是回文&amp;#34;&amp;lt;&amp;lt;endl; }else{ cout&amp;lt;&amp;lt;&amp;#34;不是回文&amp;#34;&amp;lt;&amp;lt;endl; } return 0; } </description>
    </item>
    
    <item>
      <title>姓名排序</title>
      <link>https://mannuan.github.io/post/20190825163450/</link>
      <pubDate>Sun, 25 Aug 2019 16:34:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190825163450/</guid>
      <description>姓名排序 时间限制：C/C++语言 3000MS；其他语言 5000MS
内存限制：C/C++语言 131072KB；其他语言 655360KB
题目描述： 马上就要开学了，教务处的老师拿到了新生的名单，现在他需要根据考生的姓名录入一个拼音版的新名单。
老师录入时，需要输入姓和名(例如：ZHANG SAN，字母均为大写，姓名以空格隔开)，并且要将这些人按一定规则排序。
排序的方式如下：
首先，按照该姓的出现次数排序，即：姓出现次数多的人先排序
其次，若两个人的姓出现的次数一样多（或者是同一个姓），按照原名单的顺序。
输入 输入包括多行，每一行两个字符串，代表一个人的姓和名
输出 输出排序后的名单
样例输入 ZHANG SAN
LI SI
WANG WU
WANG LIU
WANG QI
ZHANG WU
LI WU
样例输出 WANG WU
WANG LIU
WANG QI
ZHANG SAN
LI SI
ZHANG WU
LI WU
提示 范围 输入只包含大写字母，最多10000行，每行最多50个字符
#include&amp;lt;bits/stdc++.h&amp;gt; typedef long long ll; const int maxn = 1e4 + 5; const int INF = 0x3f3f3f3f; const int MOD = 1e9 + 7; using namespace std; struct node { string x, m; }f[maxn]; map&amp;lt;string, int&amp;gt;mp; bool cmp(node a, node b) { return mp[a.</description>
    </item>
    
    <item>
      <title>最优打字策略</title>
      <link>https://mannuan.github.io/post/20190825161517/</link>
      <pubDate>Sun, 25 Aug 2019 16:15:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190825161517/</guid>
      <description>最优打字策略 题目描述 在英文的输入中，我们经常会遇到大小写切换的问题，频繁切换大小写会增加我们的按键次数，也会降低我们的打字效率。
众所周知，切换大小写有两种方式，一种是按下“caps locks”，也就是大写锁定键，这样一来，之后的输入模式都会被切换。另一种是同时按下shift和需要打印的字母，可以临时切换大小写(算作按下两个键)。
已知初始状态下，打字模式是小写，现在给出需要打印的字符串(区分大小写)，请你计算出最少需按键多少次才能打印出来。
输入 输入第一行仅包含一个正整数n，表示字符串的长度(1&amp;lt;=n&amp;lt;=1000000)。
输入第二行包含一个长度为n的字符串，仅包含大小写字母。
输出 输出仅包含一个正整数，即最少的按键次数。
样例输入
6
AaAAAA
样例输出
8
#include&amp;lt;bits/stdc++.h&amp;gt; typedef long long ll; const int maxn = 1e3 + 5; const int INF = 0x3f3f3f3f; const int MOD = 1e9 + 7; using namespace std; int main() { int n, flag = 0, sum; string p; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p; sum = p.length(); for (int i = 0; i &amp;lt; p.</description>
    </item>
    
    <item>
      <title>markdown书写规范</title>
      <link>https://mannuan.github.io/post/20190825142423/</link>
      <pubDate>Sun, 25 Aug 2019 14:24:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190825142423/</guid>
      <description> markdown书写规范 举例如下 --- date: &amp;#34;2019-08-25T14:24:23+08:00&amp;#34; title: &amp;#34;markdown书写规范&amp;#34; authors: [mannuan] toc: true 显示目录 categories: - 开发文档 draft: true --- # markdown开发文档</description>
    </item>
    
    <item>
      <title>ASCII码对照表</title>
      <link>https://mannuan.github.io/post/20190825140450/</link>
      <pubDate>Sun, 25 Aug 2019 14:04:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190825140450/</guid>
      <description>ASCII码对照表  ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符   0 NUT 32 (space) 64 @ 96 、   1 SOH 33 ! 65 A 97 a   2 STX 34 &#34; 66 B 98 b   3 ETX 35 # 67 C 99 c   4 EOT 36 $ 68 D 100 d   5 ENQ 37 % 69 E 101 e   6 ACK 38 &amp;amp; 70 F 102 f   7 BEL 39 , 71 G 103 g   8 BS 40 ( 72 H 104 h   9 HT 41 ) 73 I 105 i   10 LF 42 * 74 J 106 j   11 VT 43 + 75 K 107 k   12 FF 44 , 76 L 108 l   13 CR 45 - 77 M 109 m   14 SO 46 .</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>https://mannuan.github.io/post/20190824230403/</link>
      <pubDate>Sat, 24 Aug 2019 23:04:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190824230403/</guid>
      <description>反转链表 参考视频地址 视频地址
非递归实现 过程描述 需要两个指针prev, head在链表中进行移动；另外还需要一个指针save,用来保存head节点的下一个节点
举例说明 初始化的时候  prev 1(head)-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;null  prev = null head = 1 save = null   第一次循环 改变指针的指向  prev&amp;lt;-1(head) 2-&amp;gt;3-&amp;gt;4-&amp;gt;null  prev = null head = 1 save = 2   往右平移prev,head  null&amp;lt;-1(prev) 2(head)-&amp;gt;3-&amp;gt;4-&amp;gt;null  prev = 1 head = 2 save = 2   第二次循环 改变指针指向  null&amp;lt;-1(prev)&amp;lt;-2(head) 3-&amp;gt;4-&amp;gt;null  prev = 1 head = 2 save = 3   往右平移指针prev,head  null&amp;lt;-1&amp;lt;-2(prev) 3(head)-&amp;gt;4-&amp;gt;null  prev = 2 head = 3 save = 3   第三次循环 改变指针指向  null&amp;lt;-1&amp;lt;-2(prev)&amp;lt;-3(head) 4-&amp;gt;null  prev = 2 head = 3 save = 4   往右平移指针prev,head  null&amp;lt;-1&amp;lt;-2&amp;lt;-3(prev) 4(head)-&amp;gt;null  prev = 3 head = 4 save = 4   第四次循环 改变指针指向  null&amp;lt;-1&amp;lt;-2&amp;lt;-3(prev)&amp;lt;-4(head) null  prev = 3 head = 4 save = null   往右平移指针prev,head  null&amp;lt;-1&amp;lt;-2&amp;lt;-3&amp;lt;-4(prev) null(head)  prev = 4 head = null save = null   循环结束条件 根据第四次循环的结果，可以看到循环的终止条件就是head=null</description>
    </item>
    
    <item>
      <title>大数相加</title>
      <link>https://mannuan.github.io/post/20190824230046/</link>
      <pubDate>Sat, 24 Aug 2019 23:00:46 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190824230046/</guid>
      <description> 大数相加 javascript实现 function sumBigNumber(a, b) { var res = &amp;#39;&amp;#39;, temp = 0; a = a.split(&amp;#39;&amp;#39;); b = b.split(&amp;#39;&amp;#39;); while (a.length || b.length || temp) { temp += ~~a.pop() + ~~b.pop(); res = (temp % 10) + res; temp = temp &amp;gt; 9; } return res.replace(/^0+/, &amp;#39;&amp;#39;); } </description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://mannuan.github.io/post/20190824224818/</link>
      <pubDate>Sat, 24 Aug 2019 22:48:19 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190824224818/</guid>
      <description>快速排序 过程描述 对数组的每一个部分，分别根据base进行元素的划分
在元素的划分过程中，需要借助两个指针i,j; 分别向后和向前移动
javascript实现 function partion(arr, left, right){ let base = arr[left]; let i = left; let j = right; while(i&amp;lt;j){ while(arr[j]&amp;gt;=base&amp;amp;&amp;amp;i&amp;lt;j){ j--; } while(arr[i]&amp;lt;=base&amp;amp;&amp;amp;i&amp;lt;j){ i++; } let tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } arr[left] = arr[i]; arr[i] = base; return i; } function quickSort(arr, left, right){ if(left &amp;lt; right){ let m = partion(arr, left, right); quickSort(arr, left, m); quickSort(arr, m+1,right); } }  c++实现 # include&amp;lt;iostream&amp;gt;  # include&amp;lt;cstring&amp;gt;  # include&amp;lt;cstdlib&amp;gt;  using namespace std; int partion(int arr[], int left, int right){ int base = arr[left]; int i = left; int j = right; while(i&amp;lt;j){ while(arr[j]&amp;gt;=base&amp;amp;&amp;amp;i&amp;lt;j){ j--; } while(arr[i]&amp;lt;=base&amp;amp;&amp;amp;i&amp;lt;j){ i++; } int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } arr[left] = arr[i]; arr[i] = base; return i; } void quickSort(int arr[], int left, int right){ if(left &amp;lt; right){ int m = partion(arr, left, right); quickSort(arr, left, m); quickSort(arr, m+1, right); } } int main(){ const int n = 10; int arr[n] = {0}; for(int i=0;i&amp;lt;n;i++){ arr[i] = rand() % n + 0; } for(int i=0;i&amp;lt;n;i++){ cout&amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout&amp;lt;&amp;lt;endl; quickSort(arr, 0, n); for(int i=0;i&amp;lt;n;i++){ cout&amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout&amp;lt;&amp;lt;endl; return 0; }  python实现 import random arr = [random.</description>
    </item>
    
    <item>
      <title>有赞一面凉面</title>
      <link>https://mannuan.github.io/post/20190824174052/</link>
      <pubDate>Sat, 24 Aug 2019 17:40:52 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190824174052/</guid>
      <description>有赞一面凉面  首先上来就问了我对上午的宣讲会，说说对于有赞印象。
 我说听好的，有赞挺有意思的  然后，做了一个自我介绍，说了我现在在哪里上学，最近在做一个个人博客的项目
 这里我就开始疯狂扒拉我的项目： 我首先说了我前期使用hugo来搭建我的博客； 然后，之后我为了更好的呈现我的博客，我使用vue又重新写了一下我的博客导航页面 对于这当中的难点，我一一说了出来 首先，我使用vue-router来实现导航栏下面的页面的切换，然后，之后我改用vuex来实现页面的改变  事件流
 设计模式(单例模式，没有了解过)
 继承
 css盒模型
 元素如何垂直居中
 linux 权限管理
 数据类型
 http协议
 7层网络模型
 从输入URL到获得数据的流程
 https的原理（具体就是描述https的第三方代理机构ca）
 线程和进程的区别
 javascript是单线程的吗，举个例子说明一下
 什么是事件流的代理
 this是什么
 0.1+0.2!=0.3为什么
 闭包
 为什么存在跨域
 数组你是如何去重的？
 box-sizing
 快速排序(这个没写出来，写了一半中间有些细节忘了，要不然就成了，太可惜了，成了个备胎)
 链表反转（这个时间不够直接就没问）
 在页面中根据数组渲染页面，然后点击每个数组的每个内容输出&amp;rdquo;hello world&amp;rdquo;(这题主要考察编码规范)
 我写的是下面的代码，正好完美的躲避了错误   function render(arr){ arr.forEach(e =&amp;gt; { let li = document.</description>
    </item>
    
    <item>
      <title>生命周期</title>
      <link>https://mannuan.github.io/post/20190823220435/</link>
      <pubDate>Fri, 23 Aug 2019 22:04:35 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823220435/</guid>
      <description> 生命周期 图解 实例创建过程 创建一个实例 new Vue()  init(初始化)  beforeCreate()
injections和reactivity created()
   在beforeCreate的时候不可以修改data数据，最早在created中添加一些行为
 在created完成以后，它会去判断instance(实例)中是否含有&amp;rdquo;el&amp;rdquo;option(选项)，如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接进入下一步。接下来他会判断是否含有“template”这个选项，如果有的话，他会把template解析成一个render function, 这是一个template编译的过程，结果是解析成功了render函数：
render (h) { return h(&amp;#39;div&amp;#39;, {}, this.text) }   render函数中的h就是vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，就是组件上的props对象，或者是事件之类的东西或是事件之类的东西。第三个参数就是div标签里面的内容，就是data中的text。
 使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的。也就是说在beforeMount的时候，$el还是我们之前写的html中的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。
在使用.vue文件开发的过程中，我们写的template模板，在经过了vue-loader的处理之后，就变成了render function, 最终放到了vue-loader解析过的文件里面。这样的好处就是：我们在在页面上执行vue代码的时候，效率高。
beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕以后，这个实力算是初步创建好了。
后面的钩子函数都是需要外部的触发才会执行。比如数据的变化，会调用beforeUpdate,然后进过Virtual DOM，最后updated更新完毕。当组件
 vue的双向数据绑定  Object.defineProperty() 观察者模式 让双向绑定更有效率 一对多的模式  一：改了一个地方 多：页面凡是用了数据的地方都更新  数据劫持，就是通过defineProperty()   </description>
    </item>
    
    <item>
      <title>GET和POST比较</title>
      <link>https://mannuan.github.io/post/20190823215248/</link>
      <pubDate>Fri, 23 Aug 2019 21:52:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823215248/</guid>
      <description>GET和POST比较 作用 GET 用于获取资源，而 POST 用于传输实体主体。
参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。
因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。
GET /test/demo_form.asp?name1=value1&amp;amp;name2=value2 HTTP/1.1  POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;amp;name2=value2  安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。
GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
安全的方法除了 GET 之外还有：HEAD、OPTIONS。
不安全的方法除了 POST 之外还有 PUT、DELETE。
幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。
所有的安全方法也都是幂等的。
在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</description>
    </item>
    
    <item>
      <title>HTTP/1.1新特性</title>
      <link>https://mannuan.github.io/post/20190823214854/</link>
      <pubDate>Fri, 23 Aug 2019 21:48:54 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823214854/</guid>
      <description> HTTP/1.1新特性  默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age  </description>
    </item>
    
    <item>
      <title>HTTP/2.0</title>
      <link>https://mannuan.github.io/post/20190823213853/</link>
      <pubDate>Fri, 23 Aug 2019 21:38:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823213853/</guid>
      <description>HTTP/2.0 HTTP/1.x缺陷 HTTP/1.x 实现简单是以牺牲性能为代价的：
 客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。  二进制分帧层 HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。
 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。  服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。
首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。
HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。
不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://mannuan.github.io/post/20190823212538/</link>
      <pubDate>Fri, 23 Aug 2019 21:25:38 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823212538/</guid>
      <description>HTTPS HTTP 有以下安全性问题： + 使用明文进行通信，内容可能会被窃听； + 不验证通信方的身份，通信方的身份有可能遭遇伪装； + 无法证明报文的完整性，报文有可能遭篡改。
HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。
通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 加密 对称密钥加密 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。
+ 优点：运算速度快； + 缺点：无法安全地将密钥传输给通信方。
非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。
公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。
 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢  HTTPS采用的加密方式 HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）
认证 通过使用 证书 来对通信方进行认证。
数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。
服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。
完整性保护 SSL 提供报文摘要功能来进行完整性保护。
HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</description>
    </item>
    
    <item>
      <title>具体应用</title>
      <link>https://mannuan.github.io/post/20190823191245/</link>
      <pubDate>Fri, 23 Aug 2019 19:12:46 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823191245/</guid>
      <description>参考链接
具体应用 连接管理 短连接与长连接 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。
长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。
 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。  流水线 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。
流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。
Cookie HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。
Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。
用途  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）  创建过程 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</description>
    </item>
    
    <item>
      <title>HTTP首部</title>
      <link>https://mannuan.github.io/post/20190823191041/</link>
      <pubDate>Fri, 23 Aug 2019 19:10:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823191041/</guid>
      <description> HTTP首部 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。
 各种首部字段及其含义如下（不需要全记，仅供查阅）：
 通用首部字段    首部字段名 说明     Cache-Control 控制缓存的行为   Connection 控制不再转发给代理的首部字段、管理持久连接   Date 创建报文的日期时间   Pragma 报文指令   Trailer 报文末端的首部一览   Transfer-Encoding 指定报文主体的传输编码方式   Upgrade 升级为其他协议   Via 代理服务器的相关信息   Warning 错误通知    请求首部字段    首部字段名 说明     Accept 用户代理可处理的媒体类型   Accept-Charset 优先的字符集   Accept-Encoding 优先的内容编码   Accept-Language 优先的语言（自然语言）   Authorization Web 认证信息   Expect 期待服务器的特定行为   From 用户的电子邮箱地址   Host 请求资源所在服务器   If-Match 比较实体标记（ETag）   If-Modified-Since 比较资源的更新时间   If-None-Match 比较实体标记（与 If-Match 相反）   If-Range 资源未更新时发送实体 Byte 的范围请求   If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反）   Max-Forwards 最大传输逐跳数   Proxy-Authorization 代理服务器要求客户端的认证信息   Range 实体的字节范围请求   Referer 对请求中 URI 的原始获取方   TE 传输编码的优先级   User-Agent HTTP 客户端程序的信息    响应首部字段    首部字段名 说明     Accept-Ranges 是否接受字节范围请求   Age 推算资源创建经过时间   ETag 资源的匹配信息   Location 令客户端重定向至指定 URI   Proxy-Authenticate 代理服务器对客户端的认证信息   Retry-After 对再次发起请求的时机要求   Server HTTP 服务器的安装信息   Vary 代理服务器缓存的管理信息   WWW-Authenticate 服务器对客户端的认证信息    实体首部字段    首部字段名 说明     Allow 资源可支持的 HTTP 方法   Content-Encoding 实体主体适用的编码方式   Content-Language 实体主体的自然语言   Content-Length 实体主体的大小   Content-Location 替代对应资源的 URI   Content-MD5 实体主体的报文摘要   Content-Range 实体主体的位置范围   Content-Type 实体主体的媒体类型   Expires 实体主体过期的日期时间   Last-Modified 资源的最后修改日期时间    </description>
    </item>
    
    <item>
      <title>HTTP方法</title>
      <link>https://mannuan.github.io/post/20190823185325/</link>
      <pubDate>Fri, 23 Aug 2019 18:53:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823185325/</guid>
      <description>HTTP方法  客户端发送的 请求报文 第一行为请求行，包含了方法字段。
GET 获取网络资源
当前网络请求中，绝大部分使用的是 GET 方法。
HEAD 获取报文首部
和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。
POST 向服务器发送数据
POST 主要用来传输数据，而 GET 主要用来获取资源。
PUT 上传文件
由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
 PUT /new.html HTTP/1.1 Host: example.com Content-type: text/html Content-length: 16 &amp;lt;p&amp;gt;New File&amp;lt;/p&amp;gt;  PATCH 对资源进行部分修改
PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
PATCH /file.txt HTTP/1.1 Host: www.example.com Content-Type: application/example If-Match: &amp;quot;e0023aa4e&amp;quot; Content-Length: 100 [description of changes]  DELETE 删除文件
与 PUT 功能相反，并且同样不带验证机制。 DELETE /file.html HTTP/1.1
OPTIONS 查询支持的方法</description>
    </item>
    
    <item>
      <title>HTTP状态码</title>
      <link>https://mannuan.github.io/post/20190823173028/</link>
      <pubDate>Fri, 23 Aug 2019 17:30:28 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823173028/</guid>
      <description>HTTP状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。
   状态码 类别 含义     1XX Informational（信息性状态码） 接收的请求正在处理   2XX Success（成功状态码） 请求正常处理完毕   3XX Redirection（重定向状态码） 需要进行附加操作以完成请求   4XX Client Error（客户端错误状态码） 服务器无法处理请求   5XX Server Error（服务器错误状态码） 服务器处理请求出错   
1XX信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
2XX成功  200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。  3XX重定向  301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</description>
    </item>
    
    <item>
      <title>Socket</title>
      <link>https://mannuan.github.io/post/20190823171122/</link>
      <pubDate>Fri, 23 Aug 2019 17:11:22 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823171122/</guid>
      <description> Socket </description>
    </item>
    
    <item>
      <title>基础概念</title>
      <link>https://mannuan.github.io/post/20190823170451/</link>
      <pubDate>Fri, 23 Aug 2019 17:04:51 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190823170451/</guid>
      <description> 基础概念 URI URI 包含 URL 和 URN。 请求和响应报文 请求报文 响应报文 </description>
    </item>
    
    <item>
      <title>概述</title>
      <link>https://mannuan.github.io/post/20190822105913/</link>
      <pubDate>Thu, 22 Aug 2019 10:59:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190822105913/</guid>
      <description> 概述 网络的网络 网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。
ISP </description>
    </item>
    
    <item>
      <title>报文转义</title>
      <link>https://mannuan.github.io/post/20190821212336/</link>
      <pubDate>Wed, 21 Aug 2019 21:23:36 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190821212336/</guid>
      <description>题目描述 说明: 实现报文转义功能, 报文中如里出现0x0A，转义成为2个字节0x12 0x34, 如果出现0x0B，转义成为2个字节0xAB OXCD。 其他报文字节保持不变
输入描述：  输入的报文为16进制，输入报文长度不超过127，输入的报文第一个字节为报文长度，第一个字节（报文长度）算正式报文的一部分，但是不参与转义 输入的报文每个字节用空格隔开
输出描述： 输出为转义后的报文，转义后的报文长度也不超过255，输出到的报文第一个字节算正式报文的一部分，为转义后的报文长度
 输出的报文内容都为大写的16进制，输出报文为16进制，前不带0x前缀
 输出的报文每个字节用空格隔开
  示例1 输入 8 1 2 3 4 5 6 A
输出 9 1 2 3 4 5 6 12 34
说明 输入报文 8 1 2 3 4 5 6 A 解释：8 为报文长度 输出报文 9 1 2 3 4 5 6 12 34 解释: 9为报文长度， 12 34为输入报文中A 转义后的报文
实现代码 # -*- coding: utf-8 -*- import sys line = sys.</description>
    </item>
    
    <item>
      <title>vue开发环境和生产环境自动切换baseUrl</title>
      <link>https://mannuan.github.io/post/20190814142003/</link>
      <pubDate>Wed, 14 Aug 2019 14:20:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190814142003/</guid>
      <description>新建一个vue.config.js文件，填写下面的代码
const devBaseUrl = &amp;#34;/&amp;#34;; const proBaseUrl = &amp;#34;/knowledge-summary/frontend/dist/&amp;#34;; let baseUrl; process.env.NODE_ENV === &amp;#34;development&amp;#34; ? (baseUrl = devBaseUrl) : (baseUrl = proBaseUrl); module.exports = { baseUrl: baseUrl }; </description>
    </item>
    
    <item>
      <title>把矩形往右边移动</title>
      <link>https://mannuan.github.io/post/20190813215119/</link>
      <pubDate>Tue, 13 Aug 2019 21:51:19 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190813215119/</guid>
      <description> 纯css实现 </description>
    </item>
    
    <item>
      <title>网易严选面试总结</title>
      <link>https://mannuan.github.io/post/20190813191500/</link>
      <pubDate>Tue, 13 Aug 2019 19:15:00 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190813191500/</guid>
      <description>面试过程  首先是一个自我介绍， 然后，上来就是说我前端项目做的比较多（但我没做过多少，我每个项目的前端工作，我都用一行字介绍了一下） 面试官首先问我最早什么时候开始接触前端 首先问了我，原生实现ajax 然后问了我一个关于promise的题目  这道题目由于当时比较紧张，没答上来，现在一想挺简单的，挺可惜的   console.log(1); const promise = new Promise((resolve, reject) =&amp;gt; { console.log(3); resolve(4); }) promise.then(console.log); console.log(2);   我项目上就写前端布局用了vue和element-ui就疯狂地问我
 面试官了问了知不知道vue中自定义指令，我直接说不知道。 问我element-ui中用了哪些组件，我说了el-header,el-footer,el-main 还问有没有使用element-ui中的table组件 我说之前我的项目用的不是vue和element-ui中的table，我说我用的是其他的库中的table组件  然后就问了我原生的table
 面试问我如何合并行，rowspan 如何合并原生table中的边框 这个我回答把border设置为0 但其实是这个：border-collapse:collapse;  如何让一个矩形往右边移动
 我说用css中的transform实现，然后具体怎么写，我说不知道 面试官问我js如何实现上面的这个效果 我直接说不知道  然后面试官让实现每个一秒钟减1的功能，输入是hh:mm:ss的格式
 看到这个我一脸懵逼，我知道使用setInterval(),其他的具体就不知道了 主要是让我使用在线的ide,然后还让我运行代码，我很不适应  之后面试官发现我项目的重心在爬虫上面，
 问我爬虫是不是使用的mongodb，我说是
 然后面试官问我ObjectId是如何实现的 我回答了，它由4部分组成，第一部分是时间戳，中间两个部分忘记了，最后一个部分是自增的一个字段， 然后，面试问我，这个自增的字段具体是如何实现的， 我说我没有深入了解过  然后问了如何实现自动登录
 我说先使用selenium模拟登录一遍，然后暂停几分钟， 手动登录，获取cookie 然后之后直接加载cookie就可以登录了  最后，面试官说我的前端掌握的比较欠缺，然后就结束面试了
  面试总结 整个面试花费了我半个多小时，在面试过程中，面试官的几个问题都说明我对于vue的理解和使用都很欠缺（这个其实我早就在担心了，但是没有办法，我真的没有时间深入理解vue），我认为对于现阶段我来说，应该多看vue相关的资料和面经，然后查漏补缺，弥补一下其他方面的知识。</description>
    </item>
    
    <item>
      <title>网易面试总结</title>
      <link>https://mannuan.github.io/post/20190813190824/</link>
      <pubDate>Tue, 13 Aug 2019 19:08:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190813190824/</guid>
      <description> 基本数据类型有哪些 null和undefined的区别 number和Boolean之间的类型转换 ==和===的区别 数组的常用方法，简单介绍 遍历数组的方法有哪些（forEach，长度遍历，in，for in, for of）es6对数组的访问有哪些 如果一个数组形如[1,,,,3,4,5,,,,]只会输出有值的那几项的下标 一个数组只对其中大于0的数据进行相乘，结果保留五位小数的方法有哪些（filter，reduce，toFixed，） toFixed的返回值是那种类型 object的遍历方式 迭代器的属性有哪些，迭代器的使用方法 对象有迭代器属性么 for in 和object.keys的区别 如何判断对象是否为空的方法 对象的存储器属性，常用的场景有哪些 作用域的规则 作用域函数的实例问答 js的事件循环介绍一下 正则中的符号 捕获组，问题提取url中的查询，将其包装为对象 异步的几种方式 promise 和生成器，await的区别 多个请求一起发送，全部响应之后在执行下一步操作 catch和finally的区别 http的请求报文的组成 常见的http首部有哪些 cookies的应用场景 cookie不同的网站可以访问其他网站的cookie么（淘宝可以访问网易的cookies么） 有哪些字段可以用来做浏览器的缓存 原生ajax的调用 css的选择器 伪类和伪元素举例 选择器的优先级 css的标准盒模型，width的计算 css定位机制有哪些 子元素全为float，父元素高度，如何正常计算父元素的高度 建立bfc的集中方式 一列定长一列自适应的实现方式 vue，webpack，typeScript了解  </description>
    </item>
    
    <item>
      <title>20190811163816</title>
      <link>https://mannuan.github.io/post/20190811163816/</link>
      <pubDate>Sun, 11 Aug 2019 16:38:16 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190811163816/</guid>
      <description>题目描述: 小A很喜欢字母N，他认为连续的N串是他的幸运串。 有一天小A看到了一个全部由大写字母组成的字符串， 他被允许改变最多2个大写字母（也允许不改变或则只改变1个大写字母）， 使得字符串中所包含的最长的连续的N串的长度最长，你能帮助他吗？
输入描述: 输入的第一行是一个正整数T(0数据范围: 20%的数据中，字符串长度不超过100;
70%的数据中，字符串长度不超过1000;
100%的数据中，字符串长度不超过50000。
输出描述: 对于每一组测试样例，输出一个整数，表示操作后包含的最长的连续N串的长度
示例1: 输入: 3
NNTN
NNNNGGNNNN
NGNNNNGNNNNNNNNSNNNN
输出: 4
10
18
import java.util.*; public class Test02 { private static int findLargeSeq2(char[] arr) { int max_len = 0; int curr_max_len = 0; int max_low = 0; int max_high = 0; for(int i=0;i&amp;lt;arr.length;i++){ if(&amp;#34;N&amp;#34;.equals(arr[i]+&amp;#34;&amp;#34;)){ curr_max_len ++; }else{ if(max_len &amp;lt; curr_max_len){ max_len = curr_max_len; max_low = i-max_len; max_high = max_low+max_len-1; } curr_max_len = 0; } } int not_N_count = 0; int i=0; for(i=max_high+1;i&amp;lt;arr.</description>
    </item>
    
    <item>
      <title>20190810232351</title>
      <link>https://mannuan.github.io/post/20190810232351/</link>
      <pubDate>Sat, 10 Aug 2019 23:23:51 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810232351/</guid>
      <description> 题目描述 小易在维护数据的时候遇到一个需求，具体来说小易有一系列数据，这些数据了构成一个长度为n的数字序列，接下来小易会在这个序列上进行q次操作。
每次操作有一个查询的数字x，小易需要将序列数据中所有大于等于x的数字都减一并输出在本次操作中有多少个数字被减一了。
小易犯了难，希望你能帮帮他。
输入描述 第一行n,q, 表示数字个数和操作个数
接下来一行n个数表示初始的数字
接下来q行，每行一个数，表示指定的数字x。
\(1 \leq n, q \leq 20000, 1 \leq a_i, x \leq n\)
输出描述 对于每个询问，输出一个数字表示答案
示例 1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 4 3
1 2 3 4
4
3
1
输出 1
2
4
代码待更新 </description>
    </item>
    
    <item>
      <title>20190810231142</title>
      <link>https://mannuan.github.io/post/20190810231142/</link>
      <pubDate>Sat, 10 Aug 2019 23:11:43 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810231142/</guid>
      <description>题目描述 小易给你一个包含n个数字的数组\(a_1, a_2, \dots, a_3\)。你可以对这个数组执行任意次以下
交换操作：
对于数组中的两个下标i,j(\(1 \leq i, j \leq n\))，如果\(a_i + a_j\)为奇数，就可以交换\(a_i\)和\(a_j\)
现在允许你使用操作次数不限，小易希望你能求出在所有能通过若干次操作可以得到的数组中，字典序最小的一个是什么。
输入描述： 第一行一个整数n;
第二行n个整数\(a_1, a_2, \dots, a_n\), 表示数组，每两个数字之间用一个空格分隔。
输入保证\(1 \leq n \leq 10^5; 1 \leq a_i \leq 10^9\)。
输出描述： n个整数，每两个整数之间用一个空格分隔，表示得到的字典序最小的数组。
示例1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 4
7 3 5 1
输出 7 3 5 1
示例2  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 10
53941 38641 31525 75864 29026 12199 83522 58200 64784 80987
输出 12199 29026 31525 38641 53941 58200 64784 75864 80987 83522</description>
    </item>
    
    <item>
      <title>连续子序列</title>
      <link>https://mannuan.github.io/post/20190810230504/</link>
      <pubDate>Sat, 10 Aug 2019 23:05:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810230504/</guid>
      <description> 题目描述 小易给定了一个长度为n的数字序列，对于每一个\(1 \leq k \leq n\)，小易希望能求解出所有长度为的连续子序列的最大值中的最小值
输入描述 第一行数字n
接下来一行是一个长度为n的数字序列
\(1 \leq n \leq 100000, 0 \leq a_i \leq 10^9\)
输出描述： 一行n个数字，第i个数字表示k=i时的答案
示例 1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 6
1 3 2 4 6 5
输出 1 3 3 4 6 6
代码待更新 </description>
    </item>
    
    <item>
      <title>辗转相除法</title>
      <link>https://mannuan.github.io/post/20190810225614/</link>
      <pubDate>Sat, 10 Aug 2019 22:56:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810225614/</guid>
      <description> 题目描述 小易学习了转相除法之后，就开始实践这个算法在求解最大公约数上。牛牛给小易出了一道不同寻常的求解最大公约数：求解a和b的最大公约数，但是a和b的范围特别大。 小易遇到了因难，向聪明的你寻求帮助，希望你能帮帮他。
输入描述： 第一行数字 a，第二行数字 b
\(1 \leq a \leq 10^{10^5}, 1 \leq b &amp;lt; 10^{18}\)
输出描述 一行一个数字表示答案
示例 1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 6
4
输出 2
示例 2  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 7951346523609888
6998915114363550
输出 1013754
代码待更新 </description>
    </item>
    
    <item>
      <title>旋转字符串</title>
      <link>https://mannuan.github.io/post/20190810224801/</link>
      <pubDate>Sat, 10 Aug 2019 22:48:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810224801/</guid>
      <description>题目描述 给字符串定义一个“旋转“的操作，比如字符串AbcD旋转一次变成bcDA。继续旋转则依次变成cDAb、DAbc、Abcd。 给定两个字符串“源和目标”请判断“源“在旋转一定次数后，是否可以包含“目标
输入描述 三组长度非空字符串，一共6行，奇数行为“源“字符串，偶数行为“目标”字符串
输出描述 每组字符串是否可以旋转包含。包含返回 1, 不包含返回 0
示例1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 AABCD
CDAA
AABCD
ABCD
AABCD
CFS
输出 110
代码待添加</description>
    </item>
    
    <item>
      <title>强迫症卖家</title>
      <link>https://mannuan.github.io/post/20190810221953/</link>
      <pubDate>Sat, 10 Aug 2019 22:19:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810221953/</guid>
      <description>时间限制： C/C++语言 1秒；其他语言 2秒
内存限制： C/C++语言 32768K；其他语言 65536K 64bit IO Format %lld
题目描述 小明是个有强迫症的卖家，他手头有10000台设备，他想以他的幸运数D元（D是个浮点数）每台的价格批量卖一些出去，他不在乎能卖出去多少台，只在乎卖出去的每台均价最接近D元，而且他只收整数数额的钱。请你编程计算他应该每次卖出去的台数N，一共售价M。
输入描述 输入一个浮点数D(0 &amp;lt;D &amp;lt;10），精确到小数点后14位，表示小明钟情的价格。
输出描述 输出两个正整数M, N，以空格分割 如果有多种方案均价一样，输出台数最小的那个。
示例1  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 0.50000000000000
输出 1 2
示例2  输入输出示例仅供调试，后台判题数据一般不包含示例
 输入 3.14159265358979
输出 355 113
代码待添加</description>
    </item>
    
    <item>
      <title>特殊的测试</title>
      <link>https://mannuan.github.io/post/20190810215703/</link>
      <pubDate>Sat, 10 Aug 2019 21:57:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810215703/</guid>
      <description>时间限制： C/C++语言 1000MS；其他语言 3000MS
内存限制： C/C++语言 131072KB；其他语言 655360KB
题目描述： 小C在做一种特殊的服务器负载测试，对于一个请求队列中的请求，每一个请求都有一个负荷值，为了保证服务器稳定，请求队列中的请求负荷必须按照先递增后递减的规律(仅递增，仅递减也可以)，比如[ 1，2，8，4，3 ]，[ 1，3，5 ]和[ 10 ]这些是满足规律的，还有一些不满足的，比如[ 1，2，2，1 ]，[ 2，1，2 ]和[ 10，10 ]。现在给你一个请求队列，你可以对请求的负荷值进行增加，要求你调整队列中请求的负荷值，使数组满足条件。最后输出使队列满足条件最小的增加总和。
输入 输入有两行，
第一行是 N (1≤n≤5000) ，代表请求队列中的请求数量。
第二行有 N个数字 a1,a2…an (1≤ai≤10^9)。Ai是第i个请求的负荷值。
输出 输出这个最小增加总和
样例输入 5 1 4 3 2 5
样例输出 6
提示 样例解释，此时合法队列为[1,4,5,6,5]，最小增加和为6
此题代码只通过27%，期待更新正确的代码  import java.util.Scanner; public class Test02{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] arr = new int[n]; int max = 0; for(int i=0;i&amp;lt;n;i++){ arr[i] = scanner.</description>
    </item>
    
    <item>
      <title>月光宝盒的密码</title>
      <link>https://mannuan.github.io/post/20190810215316/</link>
      <pubDate>Sat, 10 Aug 2019 21:53:16 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810215316/</guid>
      <description>时间限制： C/C++语言 1000MS；其他语言 3000MS
内存限制： C/C++语言 131072KB；其他语言 655360KB
题目描述： 小希偶然得到了传说中的月光宝盒,然而打开月光宝盒需要一串密码。虽然小希并不知道密码具体是什么，但是月光宝盒的说明书上有着一个长度为 n (2 &amp;lt;= N &amp;lt;= 50000)的序列 a (-10^9 &amp;lt;= a[i] &amp;lt;= 10^9)的范围内。下面写着一段话：密码是这个序列的最长的严格上升子序列的长度(严格上升子序列是指，子序列的元素是严格递增的，例如: [5,1,6,2,4]的最长严格上升子序列为[1,2,4])，请你帮小希找到这个密码。
输入 第1行： 1个数N，N为序列的长度(2&amp;lt;=N&amp;lt;=50000)
第2到 N+1行： 每行1个数，对应序列的元素(-10^9 &amp;lt;= a[i] &amp;lt;= 10^9)
输出 一个正整数表示严格最长上升子序列的长度
样例输入 8 5 1 6 8 2 4 5 10
样例输出 5
import java.util.Scanner; public class Test{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); int[] arr = new int[N]; int[] seqs = new int[N]; for(int i=0; i&amp;lt;arr.</description>
    </item>
    
    <item>
      <title>若若的三角形</title>
      <link>https://mannuan.github.io/post/20190810214645/</link>
      <pubDate>Sat, 10 Aug 2019 21:46:46 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810214645/</guid>
      <description>时间限制： C/C++语言 1000MS；其他语言 3000MS
内存限制： C/C++语言 131072KB；其他语言 655360KB
题目描述： 若若有一个格子数为n*m的网格，现在若若想知道3个点都在格点上能形成的三角形有多少个（三点不能共线）
输入 一行两个数n和m
n,m&amp;lt;=1800
输出 三角形个数
样例输入 2 2
样例输出 76
# include&amp;lt;stdio.h&amp;gt; # include&amp;lt;iostream&amp;gt; # include&amp;lt;string.h&amp;gt; # include&amp;lt;algorithm&amp;gt; using namespace std; int gcd(int a,int b){ if(b==0){ return a; } return gcd(b, a%b); } long long Com(int n, int r){ if(n&amp;lt;r) return 0; if(n-r&amp;lt;r) r = n-r; int i,j; long long ret = 1; for(i=0,j=1;i&amp;lt;r;i++){ ret*=(n-i); for(;j&amp;lt;=r&amp;amp;&amp;amp;ret%j==0;j++){ ret /= j; } } return ret; } int main(){ int n,m; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m)!</description>
    </item>
    
    <item>
      <title>计算绝对值</title>
      <link>https://mannuan.github.io/post/20190810214234/</link>
      <pubDate>Sat, 10 Aug 2019 21:42:34 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190810214234/</guid>
      <description> 时间限制： C/C++语言 1000MS；其他语言 3000MS
内存限制： C/C++语言 131072KB；其他语言 655360KB
题目描述： 给出n个正整数，要求找出相邻两个数字中差的绝对值最小的一对数字，如果有差的绝对值相同的，则输出最前面的一对数。 2&amp;lt;n&amp;lt;=100，正整数都在10^16范围内
输入 输入包含2行，第一行为n，第二行是n个用空格分隔的正整数。
输出 输出包含一行两个正整数，要求按照原来的顺序输出
样例输入 9 1 3 4 7 2 6 5 12 32
样例输出 3 4
# -*- coding: utf-8 -*- import sys n = int(sys.stdin.readline().strip()) arr = [int(i) for i in sys.stdin.readline().strip().split()][:n] min_cha = abs(arr[0]-arr[1]) min_tup = (arr[0], arr[1]) for i in range(1, len(arr)): tmp = abs(arr[i-1]-arr[i]) if tmp &amp;lt; min_cha: min_cha = tmp min_tup = (arr[i-1], arr[i]) print(min_tup[0], min_tup[1])</description>
    </item>
    
    <item>
      <title>知识点汇总</title>
      <link>https://mannuan.github.io/post/20190809214541/</link>
      <pubDate>Fri, 09 Aug 2019 21:45:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190809214541/</guid>
      <description>前言 网易面试注重对基本知识的考察。主要从css和js两方面着手。给大家的告诫就是凡是简历上面的东西，最好掌握的很熟悉。
面试自我介绍 面试官你好，我叫吴俊磊，我是杭州电子科技大学，计算机学院的研究生。 我熟悉html、css和js的使用，了解过jquery和vue前端开发框架。 我最近做的项目是智慧旅游的爬虫管理系统。我的任务是负责爬虫和呈现数据。我使用的技术栈是selenium+vue 以上就是我的自我介绍，谢谢！
向面试官提问 你们部门使用的是什么技术栈？
CSS部分  两列布局，一列自适应，这篇文章解释的很好链接  扩展：三列布局链接链接   css选择器  元素选择器 id选择器 class选择器 通配选择器 关系选择器 后代选择器 子选择器 相邻选择器 兄弟选择器 属性选择器 E[att] 选择具有att属性的E元素 E[att=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值等于val的E元素 E[att~=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值其中一个等于val的E元素（包含只有一个值且该值等于val的情况） E[att|=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值为以val开头并用连接符-分隔的字符串的E元素，如果属性值仅为val，也将被选择 E[att^=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值为以val开头的字符串的E元素 E[att$=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值为以val结尾的字符串的E元素 E[att*=&amp;ldquo;val&amp;rdquo;] 选择具有att属性且属性值为包含val的字符串的E元素 伪类选择器 E:link 设置超链接a在未被访问前的样式 E:visited 设置超链接a在其链接地址已被访问过时的样式 伪对象选择器   JS部分  数据类型：6种  基本数据类型：5种 复杂数据类型：1种 ES6新增了Symbol，不需要new  数据类型判断  typeof返回值 typeof() 括号可以省略吗，操作符可以省略， 一元运算符优先级很高 对象进行判断 对数组进行判断  var a = []; Array.</description>
    </item>
    
    <item>
      <title>less与sass的区别</title>
      <link>https://mannuan.github.io/post/20190808155312/</link>
      <pubDate>Thu, 08 Aug 2019 15:53:12 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190808155312/</guid>
      <description>参考链接 链接</description>
    </item>
    
    <item>
      <title>vue从入门到精通</title>
      <link>https://mannuan.github.io/post/20190808140332/</link>
      <pubDate>Thu, 08 Aug 2019 14:03:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190808140332/</guid>
      <description>创建项目 安装vue-cli3.x cnpm install -g @vue/cli 创建项目 vue create xxx Please pick a preset: ? Please pick a preset: firstpractice (vue-router, vuex, dart-sass, eslint) default (babel, eslint) ❯ Manually select features  选择最后一项
Check the features needed for your project: ? Please pick a preset: Manually select features ? Check the features needed for your project: ◯ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◉ Vuex ◉ CSS Pre-processors ❯◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing  选择上面实心圆的几项</description>
    </item>
    
    <item>
      <title>基于网络过程的前端知识框架</title>
      <link>https://mannuan.github.io/post/20190808112742/</link>
      <pubDate>Thu, 08 Aug 2019 11:27:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190808112742/</guid>
      <description> 浏览器输入url 检查http缓存 http缓存没有过期 http缓存已经过期 </description>
    </item>
    
    <item>
      <title>npm的常用命令</title>
      <link>https://mannuan.github.io/post/20190808100721/</link>
      <pubDate>Thu, 08 Aug 2019 10:07:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190808100721/</guid>
      <description> 自动往package.json文件中添加dependencies npm install xxx --save 自动往package.json文件中添加devDependencies npm install xxx --save-dev</description>
    </item>
    
    <item>
      <title>基于情感以及各种规则的反讽检测</title>
      <link>https://mannuan.github.io/post/20190807221347/</link>
      <pubDate>Wed, 07 Aug 2019 22:13:47 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190807221347/</guid>
      <description>摘要 随着网络的快速发展，越来越多的网络社交平台产生。人们普遍通过社交网络来发泄直接对这个社会的不满，其中reddit是国外一个重要的社交平台。在网站中如果是讽刺的文字会用#sarcasm来标注，其中反讽是一个分析人类情感的很重要的一个平台。分析反讽的评论对公众的态度有很太的提升。以前，一般通过上下文来获取的一句话的反讽倾向，或者，提升句子语义的提取来获取反讽的评判依据。我认为之前的研究对于一个反讽的判别器来说太过于片面，没有整体地把握住反讽的评判标准。我认为应该同时考虑以上的两个方面，并且我认为反讽的检测还与情感的变化相关。上下文的反讽主要由于语境的不协调的引起的，因此我认为，可以与正面情感和负面活动的单词的数量、正面情感和负面活动的词对的长度有关。我通过几组实验验证了我的假设，实验表明我的模型优越于最先进的模型。</description>
    </item>
    
    <item>
      <title>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</title>
      <link>https://mannuan.github.io/post/20190807110958/</link>
      <pubDate>Wed, 07 Aug 2019 11:09:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190807110958/</guid>
      <description>在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤  如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间   浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下：  浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样）  打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：  客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z  TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：  主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文  浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树：  Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树  解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树：  Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树  根据DOM树和CSSOM树构建渲染树:  从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式  js解析如下：  浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.</description>
    </item>
    
    <item>
      <title>智慧旅游</title>
      <link>https://mannuan.github.io/post/20190807092523/</link>
      <pubDate>Wed, 07 Aug 2019 09:25:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190807092523/</guid>
      <description> 前端项目架构  public/
 favicon.ico index.html  src/
 api/ assets/ base/ common/ components/ config/ directive/ filters/ mock/ router/ store/ styles/ utils/ views/ App.vue main.js permission.js  babel.config.js
 package-lock.json
 package.json
 vue.config.js
  </description>
    </item>
    
    <item>
      <title>pyspider实现原理详解</title>
      <link>https://mannuan.github.io/post/20190806221552/</link>
      <pubDate>Tue, 06 Aug 2019 22:15:52 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806221552/</guid>
      <description> 介绍 </description>
    </item>
    
    <item>
      <title>爬虫面试知识点总结</title>
      <link>https://mannuan.github.io/post/20190806215803/</link>
      <pubDate>Tue, 06 Aug 2019 21:58:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806215803/</guid>
      <description> 参考资料  链接  </description>
    </item>
    
    <item>
      <title>vue要点总结</title>
      <link>https://mannuan.github.io/post/20190806194820/</link>
      <pubDate>Tue, 06 Aug 2019 19:48:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806194820/</guid>
      <description> 参考资料  链接 链接  </description>
    </item>
    
    <item>
      <title>python面试要点</title>
      <link>https://mannuan.github.io/post/20190806192314/</link>
      <pubDate>Tue, 06 Aug 2019 19:23:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806192314/</guid>
      <description> 参考资料  链接 链接  </description>
    </item>
    
    <item>
      <title>前端知识点总结</title>
      <link>https://mannuan.github.io/post/20190806190120/</link>
      <pubDate>Tue, 06 Aug 2019 19:01:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806190120/</guid>
      <description> 链接 链接 链接   </description>
    </item>
    
    <item>
      <title>瀑布流的Vue实践</title>
      <link>https://mannuan.github.io/post/20190806164157/</link>
      <pubDate>Tue, 06 Aug 2019 16:41:57 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806164157/</guid>
      <description>参考资料 链接</description>
    </item>
    
    <item>
      <title>行内元素和块级元素有哪些？</title>
      <link>https://mannuan.github.io/post/20190806143509/</link>
      <pubDate>Tue, 06 Aug 2019 14:35:09 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806143509/</guid>
      <description>块元素(block element)  address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - 可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表  内联元素(inline element)  a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量  可变元素  可变元素为根据上下文语境决定该元素为块元素或者内联元素。</description>
    </item>
    
    <item>
      <title>box-shadow</title>
      <link>https://mannuan.github.io/post/20190806143255/</link>
      <pubDate>Tue, 06 Aug 2019 14:32:55 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806143255/</guid>
      <description> 参考资料  链接  </description>
    </item>
    
    <item>
      <title>前端面试总结</title>
      <link>https://mannuan.github.io/post/20190806142017/</link>
      <pubDate>Tue, 06 Aug 2019 14:20:17 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806142017/</guid>
      <description> 2019年  链接  2018年  链接 链接 链接  </description>
    </item>
    
    <item>
      <title>CSS-position:static/relative/absolute/fixed定位</title>
      <link>https://mannuan.github.io/post/20190806141030/</link>
      <pubDate>Tue, 06 Aug 2019 14:10:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806141030/</guid>
      <description> 参考资料  链接  关于position:absolute的几篇文章  链接1 链接2 链接3  </description>
    </item>
    
    <item>
      <title> flex 布局</title>
      <link>https://mannuan.github.io/post/20190806140626/</link>
      <pubDate>Tue, 06 Aug 2019 14:06:27 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806140626/</guid>
      <description> 参考资料  链接 链接  </description>
    </item>
    
    <item>
      <title>如何理解Display：None，Block，Inline，Inline-Block</title>
      <link>https://mannuan.github.io/post/20190806140147/</link>
      <pubDate>Tue, 06 Aug 2019 14:01:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806140147/</guid>
      <description> 参考资料  链接  </description>
    </item>
    
    <item>
      <title>下拉菜单</title>
      <link>https://mannuan.github.io/post/20190804210614/</link>
      <pubDate>Sun, 04 Aug 2019 21:06:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190804210614/</guid>
      <description>题目描述 如下图所示，请实现如下功能，当鼠标移到黑底客户服务区块后，出来白底卡片内容，鼠标移出后，卡片内容消失，并且当鼠标在白色部分上移动时白色框不能消失。
纯css的解决方案 链接</description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://mannuan.github.io/post/20190804155523/</link>
      <pubDate>Sun, 04 Aug 2019 15:55:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190804155523/</guid>
      <description>题目描述 设计一个uniquity函数，可以根据用户自定义的重复判定规则进行数组元素去重，举个例子：
//情况一: let arr0 = [1,1,1,0,5,6]; uniqueify(arr0); //输出：[1,0,5,6]  //情况二: let arr1 = [ {id: 1, name: &amp;#34;xx&amp;#34;}, {id: 1, name: &amp;#34;xx&amp;#34;}, {id: 2, name: &amp;#34;xx&amp;#34;}, {id: 1, name: &amp;#34;xx&amp;#34;}, {id: 1, name: &amp;#34;xx&amp;#34;}, ]; uniqueify(arr1, a=&amp;gt;a.id); //假如这里的去重规则依据为id //输出 [ {id: 1, name: &amp;#34;xx&amp;#34;}, {id: 2, name: &amp;#34;xx&amp;#34;}, ]; //情况三  let arr2 = [ {name: &amp;#39;xx&amp;#39;, sex: &amp;#39;male&amp;#39;}, {name: &amp;#39;xx&amp;#39;, sex: &amp;#39;female&amp;#39;}, {name: &amp;#39;xx&amp;#39;, sex: &amp;#39;male&amp;#39;}, {name: &amp;#39;aa&amp;#39;, sex: &amp;#39;male&amp;#39;}, {name: &amp;#39;aa&amp;#39;, sex: &amp;#39;male&amp;#39;}, ] uniqueify(arr2, a=&amp;gt;(a.</description>
    </item>
    
    <item>
      <title>linux和mac下图片压缩工具</title>
      <link>https://mannuan.github.io/post/20190804154807/</link>
      <pubDate>Sun, 04 Aug 2019 15:48:08 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190804154807/</guid>
      <description>有损压缩(jpegoptim) mac brew install jpegoptim linux sudo apt-get install jpegoptim 使用举例 jpegoptim -m80 old/test.jpg --dest new #-m 后的 80 代表压缩品质 改变图片尺寸(optipng) 暂未使用，期待后续更新&amp;hellip;</description>
    </item>
    
    <item>
      <title>Ubuntu16.04安装CUDA10</title>
      <link>https://mannuan.github.io/post/20190803215930/</link>
      <pubDate>Sat, 03 Aug 2019 21:59:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190803215930/</guid>
      <description>sudo apt-get install gnupg-curl wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_10.0.130-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu1604_10.0.130-1_amd64.deb sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub sudo apt-get update wget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64/nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.deb sudo apt install ./nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.deb sudo apt-get update sudo mkdir /usr/lib/nvidia sudo apt-get install --no-install-recommends nvidia-410 sudo apt-get install --no-install-recommends cuda-10-0 libcudnn7=7.4.1.5-1+cuda10.0 libcudnn7-dev=7.4.1.5-1+cuda10.0 sudo apt-get update sudo apt-get install nvinfer-runtime-trt-repo-ubuntu1604-5.0.2-ga-cuda10.0 sudo apt-get update sudo apt-get install -y --no-install-recommends libnvinfer5=5.0.2-1+cuda10.0 sudo apt-get install -y --no-install-recommends libnvinfer-dev=5.0.2-1+cuda10.0 cudnn离线地址 链接</description>
    </item>
    
    <item>
      <title>shadowsocks的sslocal的使用</title>
      <link>https://mannuan.github.io/post/20190803214903/</link>
      <pubDate>Sat, 03 Aug 2019 21:49:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190803214903/</guid>
      <description>安装python-shadowsocks pip install shadowsocks 配置文件(config.json) { &amp;#34;server&amp;#34;:&amp;#34;ip&amp;#34;, &amp;#34;server_port&amp;#34;:&amp;#34;port&amp;#34;, &amp;#34;local_address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;local_port&amp;#34;:1080, &amp;#34;password&amp;#34;:&amp;#34;password&amp;#34;, &amp;#34;timeout&amp;#34;:300, &amp;#34;method&amp;#34;:&amp;#34;aes-256-cfb&amp;#34;, &amp;#34;fast_open&amp;#34;: false, &amp;#34;workers&amp;#34;: 1 } 运行 sslocal -c /etc/shadowsocks/config.json 启动报错  undefined symbol EVP_CIPHER_CTX_cleanup
 打开openssl.py文件 vim python路径/dist-packages/shadowsocks/crypto/openssl.py 修改 把文件中的cleanup改为reset</description>
    </item>
    
    <item>
      <title>安全的rm</title>
      <link>https://mannuan.github.io/post/20190801140243/</link>
      <pubDate>Thu, 01 Aug 2019 14:02:43 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190801140243/</guid>
      <description>安全的删除工具shell-safe-rm</description>
    </item>
    
    <item>
      <title>mac复制屏幕</title>
      <link>https://mannuan.github.io/post/20190801095217/</link>
      <pubDate>Thu, 01 Aug 2019 09:52:17 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190801095217/</guid>
      <description></description>
    </item>
    
    <item>
      <title>vscode常用设置</title>
      <link>https://mannuan.github.io/post/20190801090920/</link>
      <pubDate>Thu, 01 Aug 2019 09:09:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190801090920/</guid>
      <description> 设置中文环境  刚开始的时候vscode默认是英文环境 \(\Uparrow\) + command + P 输入configure language 点击zh-cn  打开新的文件会覆盖旧的窗口  这是因为你单击文件名的缘故，这个是“预览模式”，所以再单击其他文件时，会覆盖当前打开的文件。
 如果你要每次都打开新tab，那就双击文件名好了。这个逻辑和sublime是一样的。
预览模式是现在各类编辑器的默认功能，如果你实在不喜欢，可以关掉的，看下面： 给你配置settings.json里加一条：
{ ... &amp;#34;workbench.editor.enablePreview&amp;#34;: false ... } settings.json，snippets和locale.json的所在的文件目录 在~/Library/Application Support/Code/User/下面 &amp;gt; 这样以后遇到vscode发生崩溃的情况，就可以先备份一下配置文件，然后在重装vscode
code-runner默认在终端中运行代码  在code窗口无法运行 在setting.json中配置
 { ... &amp;#34;code-runner.runInTerminal&amp;#34;: true, ... } 取消conda自动激活环境  由于code窗口只读不可以编辑，所以无法做到系统输入，改变了一下code-runner的运行方法，使用终端来接收输入。但是又遇到每次运行代码都自动激活conda，这使得对于外部输入的代码运行变得很麻烦必须运行两次代码
 为了取消这个自动激活，我们可以在settings.json文件中输入：
{ ... &amp;#34;python.terminal.activateEnvironment&amp;#34;: false, ... } 至于，这个全局的修改方法就是在终端输入：
conda config --set auto_activate_base false 快速打开文件  直接在vscode中打开
 在终端中输入
open 文件路径</description>
    </item>
    
    <item>
      <title>二叉树的知识点整理</title>
      <link>https://mannuan.github.io/post/20190726162722/</link>
      <pubDate>Fri, 26 Jul 2019 16:27:22 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190726162722/</guid>
      <description> 二叉排序树  又称为二叉排序树，或二叉搜索树
 如果它的左子树不为空，那么左子树上所有的结点值都小于它的根结点的值；如果它的右子树不为空，那么右子树上所有的结点值都大于它的根节点的值。
二叉树的前序遍历 </description>
    </item>
    
    <item>
      <title>原码，反码和补码</title>
      <link>https://mannuan.github.io/post/20190723204549/</link>
      <pubDate>Tue, 23 Jul 2019 20:45:49 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190723204549/</guid>
      <description>编码方式 对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是计算机存储一个具体数字的编码方式。
存储方式 数值在计算机是以补码的方式存储的。
机器数 一个数在计算机中的二进制表示形式，比如补码就是机器数的形式。
格式 机器数分为两部分：符号位和数据部分。
符号位 正数为0，负数为1；
 例1: 在字长为8位的计算机中，十进制的&amp;rdquo;+2&amp;rdquo;，转换为二进制为&amp;rdquo;00000010&amp;rdquo;。 例2: 在字长为8位的计算机中，十进制的&amp;rdquo;-2&amp;rdquo;，转换为二进制为&amp;rdquo;10000010&amp;rdquo;。  机器数的真值 带符号位的机器数对应的真正数值。
原码 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值；
反码 反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反；
补码 补码的表示方式是：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）
举例:
   十进制数 原码 反码 补码     85 01010101 01010101 01010101   -85 11010101 10101010 10101011   9 00001001 00001001 00001001   -9 10001001 11110110 11110111    使用补码的原因 反码的来历 计算机底层只有加法器，不支持减法运算，在进行减法运算，会转换为加法运算。即：1-1=1+(-1)。为了解决这个问题，不得不让符号位参与运算，从而产生了反码。
补码的来历 在用反码进行计算时，出现了&amp;rdquo;0&amp;rdquo;这个特殊的数值，0带符号是没有任何意义的。即有&amp;rdquo;00000000&amp;rdquo;和&amp;rdquo;10000000&amp;rdquo;两个编码表示0。于是设计了补码，负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码到的问题：用&amp;rdquo;00000000&amp;rdquo;表示0，用&amp;rdquo;10000000&amp;rdquo;表示-128。
 注意：-128实际上是使用-0的补码来表示的，所以-128并没有原码和反码。而使用补码之后，就修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用补码表示的范围为[-128, 127]。</description>
    </item>
    
    <item>
      <title>MAC下OCR识别文字的软件</title>
      <link>https://mannuan.github.io/post/20190723090032/</link>
      <pubDate>Tue, 23 Jul 2019 09:00:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190723090032/</guid>
      <description>iText - OCR &amp;amp; Translator</description>
    </item>
    
    <item>
      <title>A Large Self-Annotated Corpus for Sarcasm</title>
      <link>https://mannuan.github.io/post/20190722090749/</link>
      <pubDate>Mon, 22 Jul 2019 09:07:49 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190722090749/</guid>
      <description>摘要 该语料库有130万条讽刺性陈述 - 比之前的数据集多10倍 - 并且比非讽刺陈述的例子多几倍，允许在平衡和不平衡的标签系统中学习。每个语句都是自我注释的 - 具有讽刺意味的是作者，而不是独立的注释者 - 并提供用户，主题和对话上下文。
介绍 讽刺检测在数据集中的例子很少、人类难以辨别和现有的数据集平衡的数据标签（数据标签大致相同）这些原因，所以检测讽刺很难。
我们提供了一个用于具有不平衡和自注释标签的讽刺检测的语料库。因为Reddit的评论结构以及经常使用和标准化的讽刺注释。有超过100万个讽刺的例子，每个例子都提供了作者，主题和上下文信息。
我们在第3节讨论了语料库结构和相关统计数据，在第4节手动评估我们语料库的噪声，第5节，我们为讽刺检测系统构建合适的基准，并检查这些子集上的简单基线方法和人类评估者的表现。
相关工作 由于我们的主要贡献是语料库而不是讽刺检测方法。
反讽数据集会有很大的区别，由于获取讽刺或非讽刺陈述的来源，手工标注的数量，和数据集平衡与否。Wallace et al.(2015) 等人使用不平衡的标签，它们不利用自我注释的标签并生成了大约10000各个手工标注的句子。推特的数据集也被用的很多，由于#sarcasm, #notsarcasm和#irony等主题提供了自注释。4.2节提到的，Twitter的缩写语言和其他属性使其变得不那么吸引人。虽然，Twitter是目前最大的原始数据来源并且之前都致力于不平衡的语料库。另外一个评论来源是IAC,这个语料库可以进一步通过人类或机器学习注释为讽刺，大概有产生了10000个带标签的陈述。
语料库细节 Reddit数据集的结构和注释 reddit是一个社交媒体网站，用户通过帖子中的评论进行交流，每一个评论包含了嵌入式媒体，外部链接，和文字，这些发布在指定主题模块的帖子被称为subredddits;这些subreddits包含了搞笑，图片，科学。用户对提交和其他评论进行评论，从而产生了类似树的会话结构。我们把reddit树中的任何节点称为元素（即提交或评论）
reddit用户采用了常用的讽刺注释方法，在讽刺语句的末尾标记&amp;rsquo;/s&amp;rsquo;;这个标记来源于&amp;lt;sarcasm&amp;gt;&amp;lt;/sarcasm&amp;gt;。和Twitter主题标签一样，使用这些标记作为讽刺的指标是嘈杂的，特别是很多用户不使用标记，不知道是不是讽刺，仅仅在讽刺意图不明显的地方使用它，我们在4.1节讨论这种噪音的程度。
构造SARC 我们使用网络爬虫抓取数据，去除了噪音数据。对于每个评论，我们提供一个讽刺标签，作者，subreddit, 用户投票的评论分数，评论的日期，以及回到原始数据集所有评论的标识符。
为了减少噪音，我们使用多个滤镜来消除噪音和无信息的评论。其中许多是标准的预处理步骤，例如排除URL和字符限制在ASCII中。为了处理Reddit数据，我们还排除了作为对话树中的讽刺评论后代的评论，因为在这种表达下，注释非常嘈杂，没有标记作者是否同意先前自己的讽刺表达的讽刺与否。
我们的原始语料库包含了三个文件： 1. 一种CSV格式的数组，包含5.33亿条评论，其中约130万条是讽刺性的。此文件仅包含作者了解标准讽刺注释的注释；这取决于他们是否在评论发布的同一个月或之前使用过注释。添加此限制是为了减少由于作者为注释其讽刺而导致的漏报。每行还包含父注释。 2. 第二个是json格式的哈希表，包含讽刺评论的对话线程中的所有评论和帖子以及所有讽刺评论的兄弟姐妹。 3. csv格式的数组，每行包含一系列导致讽刺的评论，对该序列中的最后一个元素进行(讽刺和非讽刺)的响应。每个元素都作为前一个文件的键。
这种原始语料库非常大，适用于大规模机器学习和统计分析，以及用于评估讽刺检测系统的较小基准任务。这些基准，无论是在平衡还是不平衡的情况下，都需要对语料库进行进一步的子采样，以及在稀疏信号面前处理噪声数据的方法。我们在5.1节评估了这样的方法，然后在输出上评估学习算法。
语料库评估 评估我们的语料库有三个主要的衡量指标：（1）规模，（2）讽刺与非讽刺评论的比例，以及（3）误报率和漏报率。令人感兴趣的还有语料库中的文本质量以及其对其他NLP任务的适用性。因此，在本节中，我们评估原始语料库中的错误，并提供与用于构建讽刺数据集的其他语料库的比较。我们还讨论了我们方法的潜在局限性。
手动评估 为了研究使用Reddit作为自我注释讽刺来源的嘈杂，我们估计了由我们的过滤引起的假阳性和假阴性的比例。 这是通过手动检查来自SARC标记为讽刺和500标记为非讽刺的500条评论的随机子集来完成的，并且可以完全访问评论的上下文。 如果“/ s”标签不是注释而是句子的一部分，并且如果评论作者明显对人类评估者讽刺，则评论被确定为误报。 该程序产生1.0％的假阳性率和2.0％的假阴性率。 虽然假阳性率是合理的，但假讽率与讽刺比例（0.25％）相比是显着的，表明讽刺的工作定义存在很大差异，并且需要能够处理不平衡设置中的噪声数据的方法。 在平衡设置中，这仍然是相当少量的噪音。
与其他数据源进行比较 如前所述，Twitter在以前的语料库中是最常见的讽刺来源; 这可能是由于其主题标签提供的显式注释。 然而，使用Reddit作为讽刺评论的来源具有许多研究优势。 与不受长度约束且包含较少主题标签的Reddit注释不同，推文是用缩写英语编写的。 Hashtagged标记也经常被用作语句本身的一部分（例如“那是#sarcasm”），模糊了文本和注释之间的界限; 在Reddit上，“/ s”通常仅在用作注释时用作注释以外的其他东西（例如“你忘了/ s”）。 由于单个帖子的浅树结构及其注释，Reddit上的完整对话上下文也更容易提供。
此外，从2014年7月的Twitter和Reddit数据的子样本中，我们确定Twitter作者中使用讽刺注释（＃sarcasm，＃sarcastic或#sarcastictweet）的百分比（.002％对.927％）要小得多。 我们假设Reddit用户需要更频繁地以更标准化的形式进行讽刺注释，因为它们主要是匿名的，因此不能依赖共享的上下文来传达讽刺。 最后，Reddit还受益于subreddits，它可以基于明确的主题分配实现特征化和数据探索。
Internet Argument Corpus（IAC）也被用作讽刺评论的来源（Walker等，2012）。 语料库开发人员发现IAC中有12％的例子是讽刺性的，这对于讽刺检测来说比我们的更好。 由于Reddit数据由任意对话组成，而不仅仅是参数，因此即使考虑到假阴性，我们的讽刺百分比也要小得多也就不足为奇了; 此属性还使我们的数据集更加真实。 与Reddit和Twitter不同，IAC还需要手动注释讽刺。
我们方法的局限性 我们收集自注释讽刺数据集的方法有一些值得注意的局限性。 尽管我们努力过滤嘈杂的“/s”标签，但仍存在没有简单规则可靠地消除不正确标签的情况。 我们描述了误报和漏报的困难： * 误报是由于存在“/ s”标记而将评论错误地标记为讽刺的情况。 这种情况仅在评论中出现“/ s”标签时出现，其含义与指示讽刺有所不同。 如前所述，如果用户不知道“/ s”符号，则更有可能发生这种可能性。 类似地，如果“/ s”用于指代其用作注释的约定，那么仅仅检测“/ s”字符串的简单方法也会失败。 最后，“/ s”可能还有其他含义：例如，在HTML中，&amp;lt;s&amp;gt; .</description>
    </item>
    
    <item>
      <title>反讽论文的研究反向</title>
      <link>https://mannuan.github.io/post/20190722084636/</link>
      <pubDate>Mon, 22 Jul 2019 08:46:36 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190722084636/</guid>
      <description></description>
    </item>
    
    <item>
      <title>http协议</title>
      <link>https://mannuan.github.io/post/20190717220231/</link>
      <pubDate>Wed, 17 Jul 2019 22:02:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190717220231/</guid>
      <description>前言 前端工程师打交道最多的就是浏览器，不管做什么都离不开浏览器，其中HTTP协议往往会被我们忽略，但其实资源缓存、CDN加载、页面性能优化等等都离不开对HTTP协议的了解。
介绍 HTTP也叫作超文本传输协议，全称：Hyper Transfer Protocol。最初HTTP只能传输HTML文件，慢慢的现在可以传输文字、图像、视频和各种文件。 HTTP是无状态的：同一个客户端，连续发起多次请求，对HTTP服务器来说，都是新的请求，HTTP没办法知道来自一个客户端。
消息结构 Header  分为request/response line和request/response header。
  request/response line：包括请求的方法Method（GET/POST）、请求资源的路径path to resource和http协议的版本号。 request/response header：这边就是各种请求头了。  Body 响应体，一般是HTML文件。如果是get请求，是没有响应体的。
HTTP请求方法 GET 请求获取Request-URI所标识的资源
POST 在Request-URI所标识的资源后附加新的数据
HEAD 请求获取由Request-URI所标识的资源的响应消息报头
PUT 请求服务器存储一个资源，并用Request-URI作为其标识
DELETE 请求服务器删除Request-URI所标识的资源
TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断
CONNECT 保留将来使用
OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求
对于我们来说，常用的就是GET、和POST。再次声明，不用表单提交，get不存在跟post比较有安全性问题。
HTTP状态码 1XX 提示信息 - 表示请求已被成功接收，继续处理。
2XX 成功 - 表示请求已被成功接收，理解，接受
3XX 重定向 - 要完成请求必须进行更进一步的处理
4XX 客户端错误 - 请求有语法错误或请求无法实现
5XX 服务器端错误 - 服务器未能实现合法的请求
状态码很多，可以自行了解，我觉得有几个是必须知道的。
HTTP通信过程：根据URL查询DNS、查找服务器、建立TCP连接、发送请求、服务器响应。 总结 对于HTTP，我觉得基础的要知道HTTP是无状态的、HTTP的消息结构、基本请求方法、基本状态码这四部分。</description>
    </item>
    
    <item>
      <title>冒泡、选择、插入排序</title>
      <link>https://mannuan.github.io/post/20190717114226/</link>
      <pubDate>Wed, 17 Jul 2019 11:42:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190717114226/</guid>
      <description>/** * 冒泡，插入，选择排序 * * Author: nameczz */ // 冒泡排序 const bubbleSort = (arr) =&amp;gt; { if (arr.length &amp;lt;= 1) return for (let i = 0; i &amp;lt; arr.length; i++) { let hasChange = false for (let j = 0; j &amp;lt; arr.length - i - 1; j++) { if (arr[j] &amp;gt; arr[j + 1]) { const temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp hasChange = true } } // 如果false 说明所有元素已经到位  if (!</description>
    </item>
    
    <item>
      <title>CASCADE: Contextual Sarcasm Detection in Online Discussion Forums翻译和解读</title>
      <link>https://mannuan.github.io/post/20190717110201/</link>
      <pubDate>Wed, 17 Jul 2019 11:02:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190717110201/</guid>
      <description>摘要  The literature in automated sarcasm detection has mainly focused on lexical-, syntactic- and semantic-level analysis of text. However, a sarcastic sentence can be expressed with contextual presumptions, background and commonsense knowledge. In this paper, we propose a ContextuAl SarCasm DEtector (CASCADE), which adopts a hybrid approach of both content- and context-driven modeling for sarcasm detection in online social media discussions. For the latter, CASCADE aims at extracting contextual information from the discourse of a discussion thread.</description>
    </item>
    
    <item>
      <title>单链表</title>
      <link>https://mannuan.github.io/post/20190717084321/</link>
      <pubDate>Wed, 17 Jul 2019 08:43:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190717084321/</guid>
      <description>element next         /** * 1）单链表的插入、删除、查找操作； * 2）链表中存储的是int类型的数据； */ // 创建节点对象 class Node { constructor (element) { this.element = element this.next = null } } class LinkedList { constructor () { this.head = new Node(&amp;#39;head&amp;#39;) } // 根据value查找节点  findByValue (item) { let currentNode = this.head.next; while (currentNode !== null &amp;amp;&amp;amp; currentNode.element !== item) { currentNode = currentNode.next; } console.log(currentNode); return currentNode === null ?</description>
    </item>
    
    <item>
      <title>javascript内置对象Date的使用</title>
      <link>https://mannuan.github.io/post/20190714155323/</link>
      <pubDate>Sun, 14 Jul 2019 15:53:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190714155323/</guid>
      <description> 格式化输出yyyy-mm-dd HH:MM:SS.msmsms function padbyZero(){ // 用零填充  var val = arguments[0]|0; var len = arguments[1]|2; var res = null; for(var i=1;i&amp;lt;len;i++){ res = val&amp;lt;Math.pow(10, i)?&amp;#39;0&amp;#39;+val:&amp;#39;&amp;#39;+val; } return res; } var d=new Date(); //获取年，getFullYear()返回4位的数字 var year=d.getFullYear(); //获取月，月份比较特殊，从0开始计数 var month=padbyZero(d.getMonth()+1); //获取日 var day=padbyZero(d.getDate()); var hour=padbyZero(d.getHours()); var minute=padbyZero(d.getMinutes()); var second=padbyZero(d.getSeconds()); var millisceond=padbyZero(d.getMilliseconds(), 3); formatStr = year+&amp;#39;-&amp;#39;+month+&amp;#39;-&amp;#39;+day+&amp;#39; &amp;#39;+hour+&amp;#39;:&amp;#39;+minute+&amp;#39;:&amp;#39;+second+&amp;#39;.&amp;#39;+millisceond; console.log(formatStr); </description>
    </item>
    
    <item>
      <title>chrome浏览器的调试技巧</title>
      <link>https://mannuan.github.io/post/20190713135841/</link>
      <pubDate>Sat, 13 Jul 2019 13:58:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190713135841/</guid>
      <description> 设置调试的网速 设置network传输的文件图标 </description>
    </item>
    
    <item>
      <title>vscode常用插件</title>
      <link>https://mannuan.github.io/post/20190713105721/</link>
      <pubDate>Sat, 13 Jul 2019 10:57:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190713105721/</guid>
      <description>代码片段效率工具-snippet 查看教程snippet，让你编码效率翻倍
微型的http服务器-Express  Hosts current worksapce with Express web server. - Compulim
  在商店里面搜索express 安装完毕以后，快捷键Shift + command + P，输入Host Current Workspace with ... 点击，就可开启了一个http服务器 之后，在浏览器输入文件相对于vscode的绝对路径  &amp;gt; 快一点的方法就是对着文件右键，选择Copy Relative Path  最后，就可以看到你写的网页了  python代码自动补全 { &amp;#34;python.autoComplete.extraPaths&amp;#34;: [ &amp;#34;包的绝对路径， 通常名为site-packages&amp;#34;, &amp;#34;脚本的路径，比如pip,python等命令行脚本&amp;#34;, ], } 文件-&amp;gt;设置-&amp;gt;首选项，搜索python.jediEnabled,去掉前面的√， 使用Microsoft python analysis engine
python代码静态检查工具-pylint pip install pylint yapf 默认设置
{ &amp;#34;python.linting.enabled&amp;#34;: true, &amp;#34;python.linting.lintOnSave&amp;#34;: true, &amp;#34;python.linting.pylintEnabled&amp;#34;: true } java环境安装（针对于acm）  前提已经配置好了jdk环境变量, 没有必要安装maven
 需要安装的插件有:</description>
    </item>
    
    <item>
      <title>vue学习笔记（第一部分）</title>
      <link>https://mannuan.github.io/post/20190712145655/</link>
      <pubDate>Fri, 12 Jul 2019 14:56:56 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190712145655/</guid>
      <description>Vue.js 第一部分 课程介绍 前面5个部分：学习Vue的基本的语法和概念；打包工具Webpack，Gulp 后面5个部分：以项目驱动教学
什么是Vue.js  Vue.js是目前最火的一个框架，React是最流行的一个框架（React除了开发网站，还可以开发手机App） Vue.js是前端的主流框架之一，和Angular.js、React.js一起，并称为前端三大主流框架! Vue.js是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；  为什么要学习流行的框架  企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；
 企业中，使用框架，能够提高开发的效率；  提高开发效率的发展历程：原生JS-&amp;gt;Jquery之类的类库-&amp;gt;前端模板引擎-&amp;gt;和Angular.js/ Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念[通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了]）
 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以有更多的时间去关注业务逻辑；
 增强自己就业时候的竞争力
 人无我有，人有我优   框架和库的区别  框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。
 node中的express  库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。
 1. 从Jquery切换到Zepto 2. 从EJS切换到art-template   Node（后端）中的MVC与前端中的MVVM之间的区别  MVC是后端的分层开发概念；
 MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分Model，View，VM ViewModel
 为什么有了MVC还要有MVVM
  
Vue.js 基本代码和MVVM之间的对应关系 Vue之 基本的代码结构和插值表达式、v-clock Vue基本的代码结构和插值表达式
Vue指令之 v-text和v-html Vue指令之 v-bind的三种用法  直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&amp;quot;btnTitle + &#39;，这是追加的内容&#39;&amp;quot;  Vue指令之v-on和跑马灯效果 v-clock，v-text, v-html, v-bind, v-on</description>
    </item>
    
    <item>
      <title>nginx安装和配置教程</title>
      <link>https://mannuan.github.io/post/20190711153813/</link>
      <pubDate>Thu, 11 Jul 2019 15:38:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190711153813/</guid>
      <description> linux 安装nginx sudo apt-get install nginx 配置文件路径 /etc/nginx  mac 安装nginx brew install nginx 配置文件路径 /usr/local/etc/nginx/  </description>
    </item>
    
    <item>
      <title>brew国内镜像</title>
      <link>https://mannuan.github.io/post/20190711144859/</link>
      <pubDate>Thu, 11 Jul 2019 14:48:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190711144859/</guid>
      <description>将brew改为国内镜像，主要分为两个步骤：修改brew.git和修改homebrew-core.git
 替换brew.git cd &amp;#34;$(brew --repo)&amp;#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 重置brew.git cd &amp;#34;$(brew --repo)&amp;#34; git remote set-url origin https://github.com/Homebrew/brew.git 替换homebrew-core.git cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 重置homebrew-core.git cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; git remote set-url origin https://github.</description>
    </item>
    
    <item>
      <title>vscode snippet html template</title>
      <link>https://mannuan.github.io/post/20190711103532/</link>
      <pubDate>Thu, 11 Jul 2019 10:35:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190711103532/</guid>
      <description>{ &amp;#34;vue&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;vue-tl&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;!DOCTYPE html&amp;gt;&amp;#34;, &amp;#34;&amp;lt;html lang=\&amp;#34;zh\&amp;#34;&amp;gt;&amp;#34;, &amp;#34;&amp;lt;head&amp;gt;&amp;#34;, &amp;#34; &amp;lt;meta charset=\&amp;#34;UTF-8\&amp;#34;&amp;gt;&amp;#34;, &amp;#34; &amp;lt;title&amp;gt;${1:$CURRENT_DATE}&amp;lt;/title&amp;gt;&amp;#34;, &amp;#34; &amp;lt;style type=\&amp;#34;text/css\&amp;#34;&amp;gt;&amp;#34;, &amp;#34; &amp;lt;/style&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://cdn.staticfile.org/vue/2.2.2/vue.min.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://server.lab421.top/前端开发/我自己的js库/wlib.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/head&amp;gt;&amp;#34;, &amp;#34;&amp;lt;body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;script&amp;gt;&amp;#34;, &amp;#34;var data = {};&amp;#34;, &amp;#34;var vm = new Vue({&amp;#34;, &amp;#34; el: &amp;#39;#app&amp;#39;,&amp;#34;, &amp;#34; data: data,&amp;#34;, &amp;#34; methods: {}&amp;#34;, &amp;#34;});&amp;#34;, &amp;#34;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/html&amp;gt;&amp;#34;, ], &amp;#34;description&amp;#34;: &amp;#34;create a html frame&amp;#34;, }, &amp;#34;basic&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;basic-tl&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;!DOCTYPE html&amp;gt;&amp;#34;, &amp;#34;&amp;lt;html lang=\&amp;#34;zh\&amp;#34;&amp;gt;&amp;#34;, &amp;#34;&amp;lt;head&amp;gt;&amp;#34;, &amp;#34; &amp;lt;meta charset=\&amp;#34;UTF-8\&amp;#34;&amp;gt;&amp;#34;, &amp;#34; &amp;lt;title&amp;gt;${1:$CURRENT_DATE}&amp;lt;/title&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/head&amp;gt;&amp;#34;, &amp;#34;&amp;lt;body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/html&amp;gt;&amp;#34;, ], &amp;#34;description&amp;#34;: &amp;#34;create a html frame&amp;#34;, } }</description>
    </item>
    
    <item>
      <title>vscode snippet markdown template</title>
      <link>https://mannuan.github.io/post/20190711103224/</link>
      <pubDate>Thu, 11 Jul 2019 10:32:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190711103224/</guid>
      <description>{ &amp;#34;table&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;html-table-tl&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;table&amp;gt;&amp;#34;, &amp;#34;&amp;lt;thead&amp;gt;&amp;#34;, &amp;#34;&amp;lt;tr&amp;gt;&amp;#34;, &amp;#34;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/tr&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/thead&amp;gt;&amp;#34;, &amp;#34;&amp;lt;tbody&amp;gt;&amp;#34;, &amp;#34;&amp;lt;tr&amp;gt;&amp;#34;, &amp;#34;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/tr&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/tbody&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/table&amp;gt;&amp;#34; ], &amp;#34;description&amp;#34;: &amp;#34;create a html frame&amp;#34;, } }</description>
    </item>
    
    <item>
      <title>linux使用shadowsocks-qt5实现自动代理</title>
      <link>https://mannuan.github.io/post/20190710221501/</link>
      <pubDate>Wed, 10 Jul 2019 22:15:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190710221501/</guid>
      <description>以ubuntu为例
 下载shadowsocks-qt5 打开链接, 点击Shadowsocks-Qt5-xxx-x86_64.AppImage文件下载
赋予执行权限 sudo chmod +x Shadowsocks-Qt5-xxx-x86_64.AppImage 打开shadowsocks-qt5的两种方式  直接点击 命令行输入  ./Shadowsocks-Qt5-xxx-x86_64.AppImage 生成autoproxy.pac文件  由于在国内生成autoproxy.pac的速度很慢，为了加快这一过程，我们先用shadowsocks配置一个全局代理
 配置全局代理 依次点击ubuntu的设置&amp;gt;系统设置&amp;gt;网络&amp;gt;网络代理&amp;gt;手动
然后把除了socks主机的所有其他行的选项都清空，端口无法清空，可以设置为0
最后，点击应用到整个系统
autoproxy.pac文件生成 安装genpac pip install genpac 使用在线的gfwlist genpac --pac-proxy &amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; --gfwlist-proxy=&amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&amp;#34;autoproxy.pac&amp;#34; 使用离线的gfwlist genpac --pac-proxy &amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; --gfwlist-proxy=&amp;#34;SOCKS5 127.0.0.1:1080&amp;#34; --gfwlist-local=你的路径/gfwlist.txt --output=&amp;#34;autoproxy.pac&amp;#34; 配置系统代理 关键一步，把autoproxy.pac使用本地http协议访问
再次回到网络代理界面，选择自动，在配置URL的框中输入http://127.0.0.1/autoproxy.pac</description>
    </item>
    
    <item>
      <title>vim常用命令</title>
      <link>https://mannuan.github.io/post/20190710153911/</link>
      <pubDate>Wed, 10 Jul 2019 15:39:11 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190710153911/</guid>
      <description>   功能 命令      打开快捷命令窗口      </description>
    </item>
    
    <item>
      <title>javascript数组</title>
      <link>https://mannuan.github.io/post/20190710110242/</link>
      <pubDate>Wed, 10 Jul 2019 11:02:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190710110242/</guid>
      <description>与 Java 、PHP 等语言不同，在 JavaScript 中，数组其实是一种特殊的对象。
数组的创建与读写 以下两种方式都可创建数组：
// 字面量方式,常用 var num = [1,5,6,10]; print(num.length); // 4  // 构造函数方式 var num = new Array(1,5,6,10); print(num.length); // 4  值得注意的是，JavaScript 中的数组数据可以是不同类型，它的语法相对宽松，例如可以指定不同类型数据var example = [1,&amp;quot;Mike&amp;quot;,true,null];另外，可以通过Array.isArray()来判断一个对象是否是数组，例如：
var num = [1,5,6,10]; print(Array.isArray(num)); // true  如何读写数组呢？可以使用循环。
var num = [1,5,6,10]; for (var i = 0; i &amp;lt; num.length; i++) { console.log(num[i]+&amp;#34; &amp;#34;); }  数组的深复制与浅复制 当我们把数组赋给另外一个数组，然后改变其中一个数组的值，另一数组也会随之改变，这就是数组的浅复制。而深复制指的就是不改变原来的数组而去创建一个新的数组，这种情况是经常使用的，为了不破坏原数组。下面的代码展示了这两种复制
// 浅复制 var num = [1,2,3,4,5]; var newNum = num; num[0] = 10; console.</description>
    </item>
    
    <item>
      <title>HTML速查列表</title>
      <link>https://mannuan.github.io/post/20190710104402/</link>
      <pubDate>Wed, 10 Jul 2019 10:44:02 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190710104402/</guid>
      <description>HTML 速查列表   HTML 速查列表. 你可以打印它，以备日常使用。
 HTML 基本文档 &amp;lt;!DOCTYPEhtml&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;文档标题&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;可见文本... &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;    基本标签（Basic Tags） &amp;lt;h1&amp;gt;最大的标题&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;. . . &amp;lt;/h2&amp;gt;&amp;lt;h3&amp;gt;. . . &amp;lt;/h3&amp;gt;&amp;lt;h4&amp;gt;. . . &amp;lt;/h4&amp;gt;&amp;lt;h5&amp;gt;. . . &amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt;最小的标题&amp;lt;/h6&amp;gt;&amp;lt;p&amp;gt;这是一个段落。&amp;lt;/p&amp;gt;&amp;lt;br&amp;gt;（换行） &amp;lt;hr&amp;gt;（水平线） &amp;lt;!--这是注释 --&amp;gt;    文本格式化（Formatting） &amp;lt;b&amp;gt;粗体文本&amp;lt;/b&amp;gt;&amp;lt;code&amp;gt;计算机代码&amp;lt;/code&amp;gt;&amp;lt;em&amp;gt;强调文本&amp;lt;/em&amp;gt;&amp;lt;i&amp;gt;斜体文本&amp;lt;/i&amp;gt;&amp;lt;kbd&amp;gt;键盘输入&amp;lt;/kbd&amp;gt;&amp;lt;pre&amp;gt;预格式化文本&amp;lt;/pre&amp;gt;&amp;lt;small&amp;gt;更小的文本&amp;lt;/small&amp;gt;&amp;lt;strong&amp;gt;重要的文本&amp;lt;/strong&amp;gt;&amp;lt;abbr&amp;gt;（缩写） &amp;lt;address&amp;gt;（联系信息） &amp;lt;bdo&amp;gt;（文字方向） &amp;lt;blockquote&amp;gt;（从另一个源引用的部分） &amp;lt;cite&amp;gt;（工作的名称） &amp;lt;del&amp;gt;（删除的文本） &amp;lt;ins&amp;gt;（插入的文本） &amp;lt;sub&amp;gt;（下标文本） &amp;lt;sup&amp;gt;（上标文本）    链接（Links） 普通的链接：&amp;lt;ahref=&#34;http://www.example.com/&#34;&amp;gt;链接文本&amp;lt;/a&amp;gt;图像链接： &amp;lt;ahref=&#34;http://www.example.com/&#34;&amp;gt;&amp;lt;imgsrc=&#34;URL&#34;alt=&#34;替换文本&#34;&amp;gt;&amp;lt;/a&amp;gt;邮件链接： &amp;lt;ahref=&#34;mailto:webmaster@example.com&#34;&amp;gt;发送e-mail&amp;lt;/a&amp;gt;书签： &amp;lt;aid=&#34;tips&#34;&amp;gt;提示部分&amp;lt;/a&amp;gt;&amp;lt;ahref=&#34;#tips&#34;&amp;gt;跳到提示部分&amp;lt;/a&amp;gt;    图片（Images） &amp;lt;imgsrc=&#34;URL&#34;alt=&#34;替换文本&#34;height=&#34;42&#34;width=&#34;42&#34;&amp;gt;    样式/区块（Styles/Sections） &amp;lt;styletype=&#34;text/css&#34;&amp;gt; h1{color:red;}p{color:blue;} &amp;lt;/style&amp;gt;&amp;lt;div&amp;gt;文档中的块级元素&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;文档中的内联元素&amp;lt;/span&amp;gt;    无序列表 &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;    有序列表 &amp;lt;ol&amp;gt;&amp;lt;li&amp;gt;第一项&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;第二项&amp;lt;/li&amp;gt;&amp;lt;/ol&amp;gt;    定义列表 &amp;lt;dl&amp;gt;&amp;lt;dt&amp;gt;项目 1&amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt;描述项目 1&amp;lt;/dd&amp;gt;&amp;lt;dt&amp;gt;项目 2&amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt;描述项目 2&amp;lt;/dd&amp;gt;&amp;lt;/dl&amp;gt;    表格（Tables） &amp;lt;tableborder=&#34;</description>
    </item>
    
    <item>
      <title>HTML标签的全局属性</title>
      <link>https://mannuan.github.io/post/20190710101926/</link>
      <pubDate>Wed, 10 Jul 2019 10:19:27 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190710101926/</guid>
      <description> span.new { float: right; color: #fff; background-color: #90b575; font-weight: 700; padding-left: 1px; padding-right: 1px; border: 1px solid #fff; outline: 1px solid #90b575; line-height: 16px; }    属性 描述   accesskey 设置访问元素的键盘快捷键。   class 规定元素的类名（classname）   contenteditableNew 规定是否可编辑元素的内容。   contextmenuNew 指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单   data-*New 用于存储页面的自定义数据   dir 设置元素中内容的文本方向。   draggableNew 指定某个元素是否可以拖动   dropzoneNew 指定是否将数据复制，移动，或链接，或删除   hiddenNew hidden 属性规定对元素进行隐藏。   id 规定元素的唯一 id   lang 设置元素中内容的语言代码。   spellcheckNew 检测元素是否拼写错误   style 规定元素的行内样式（inline style）   tabindex 设置元素的 Tab 键控制次序。   title 规定元素的额外信息（可在工具提示中显示）   translateNew 指定是否一个元素的值在页面载入时是否需要翻译    </description>
    </item>
    
    <item>
      <title>Latex常用设置</title>
      <link>https://mannuan.github.io/post/20190709170202/</link>
      <pubDate>Tue, 09 Jul 2019 17:02:02 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190709170202/</guid>
      <description>bib文件点击跳转 在.tex文件开头加上\usepackage[backref]{hyperref}。</description>
    </item>
    
    <item>
      <title>UDP和TCP协议</title>
      <link>https://mannuan.github.io/post/20190708141834/</link>
      <pubDate>Mon, 08 Jul 2019 14:18:34 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190708141834/</guid>
      <description>UDP和TCP协议 1、UDP 1.1、数据包格式   源端口号(16位) 目的端口号(16位)    UDP长度(16位) UDP校验和(16位)   数据    1.2、特点  沟通简单。不需要一肚子花花肠子(大量的数据结构、处理逻辑、包头字段)。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。 轻信他人。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。 愣头青。做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。  1.3、使用场景  需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。 不需要一对一沟通，建立连接，而是可以广播的应用。咱们小时候人都很简单，大家在班级里面，谁成绩好，谁写作好，应该表扬谁惩罚谁，谁得几个小红花都是当着全班的面讲的，公平公正公开。长大了人心复杂了，薪水、奖金要背靠背，和员工一对一沟通。 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。记得曾国藩建立湘军的时候，专门招出生牛犊不怕虎的新兵，而不用那些“老油条”的八旗 兵，就是因为八旗兵经历的事情多，遇到敌军不敢舍死忘生。  TCP三次握手 握手过程   SYN(Synchronize sequence numbers): TCP首部中的同步序号标志 ACK(Acknowledgement): 确认字符      时间段 客户端 服务端   活动 状态 活动 状态       CLOSED  CLOSED     CLOSED  LISTEN    &amp;rarr;   第一次握手 主动发起连接SYN SYN-SENT 收到发起的连接 SYN-RCVD   &amp;larr;  第二次握手 收到SYN和ACK SYN_SENT 返回SYN并ACK客户端的SYN SYN_RCVD    &amp;rarr;   第三次握手 发送ACK的ACK ESTABLISHED 收到客户端的ACK ESTABLISHED    为什么不是两次握手？  A为客户端，B为服务端</description>
    </item>
    
    <item>
      <title>常用的HTML标签整理</title>
      <link>https://mannuan.github.io/post/20190708085133/</link>
      <pubDate>Mon, 08 Jul 2019 08:51:33 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190708085133/</guid>
      <description>标签部分先后顺序，按照收录的先后顺序
 ruby标签 用来注释中文注音或字符。
template标签 HTML内容模板（&amp;lt;template&amp;gt;）元素 是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以在运行时使用JavaScript实例化。
将模板视为一个内容片段，存储在文档中供后续使用。虽然解析器在加载页面时确实会处理&amp;lt;template&amp;gt;元素的内容，但这样做只是为了确保这些内容有效；然而，元素的内容不会被呈现。
一个例子</description>
    </item>
    
    <item>
      <title>后序遍历非递归算法</title>
      <link>https://mannuan.github.io/post/20190707215537/</link>
      <pubDate>Sun, 07 Jul 2019 21:55:37 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190707215537/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java规范中和与Web Service相关的规范有哪些？</title>
      <link>https://mannuan.github.io/post/20190707214914/</link>
      <pubDate>Sun, 07 Jul 2019 21:49:14 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190707214914/</guid>
      <description> JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。 JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。 JAX-RS(JSR 311 &amp;amp; JSR 339 &amp;amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。  </description>
    </item>
    
    <item>
      <title>ICMP协议是什么？ICMP协议的作用是什么？</title>
      <link>https://mannuan.github.io/post/20190707153102/</link>
      <pubDate>Sun, 07 Jul 2019 15:31:02 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190707153102/</guid>
      <description>1、ICMP的定义 全称Internet Control Message Protocol，就是互联网控制报文协议。
 这里的关键词是”控制“，下面我将介绍它是如何控制的
 2、ICMP的由来 由于复杂的网络环境，数据包在网络中传输常常会发生各种问题。当遇到问题时，我们不想让数据包“死得不明不白”。为了知道产生问题的原因，我们需要构造一种新的数据包来传回消息。
 其实，上面提到这种情况和我们在电视上看到的古代作战很像，在开始作战之前，主帅都要派出“侦察兵”来检查敌方的兵力状况，以调整作战策略。
 3、ICMP的报文 ICMP它是一个3层网络协议，工作在网络层。由于数据包的传输是需要源地址和目的地址，所以被封装在IP中。它的数据包结构非常简单，因为一个“侦察兵”要“轻装上阵”，不能携带太多的包袱。
3.1、报文结构  目前类型字段有8位，可以有256种类型，但是我们实际常用的只有3种，分别是0,3,8,具体会在下面提到
 3.2、报文分类  分为两类：查询和差错报文
 3.2.1、查询报文 分为两类：回显请求和回显应答报文。
 在这里代码字段，我们只用到了0，还有255个代码没有用，具体会在下面讲到
 3.2.1.1、 回显请求 类型字段为8，代码字段为0
3.2.1.2、 回显应答 类型字段为0，代码字段为0
3.2.1.3、 Ping应用 ping发的包就符合ICMP协议的格式，只不过它在自己的数据字段增加了自己的格式。比原生的ICMP多了两个字段，一个是标识符，用来标识ping发出去的“侦察兵”的具体的任务是什么，比如“查找水源”；另一个是序号，用来给每个侦察兵编号，比如，“1号查找水源的侦察兵”。在数据字段中，ping还会存放发生请求的时间，用来计算往返的时间。
下图的ping的过程示意图 3.2.2、 差错报文 分为4种：终点不可达，源站抑制，时间超时和路由重定向
3.2.2.1、 终点不可达 网络不可达(代码0)，主机不可达(代码1)，协议不可达(代码2)，端口不可达(代码3)，需要进行分片但设置了不分片位代码(代码4)
3.2.2.2、 源站抑制 就是让源站放慢发送速度。小兵:报告主公，您粮草送的太多了吃不完。
3.2.2.3、 时间超时 就是超过网络包的生存时间还是没到。小兵:报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。
3.2.2.4、 路由重定向 就是让下次发给另一个路由器。小兵:报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。
差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包 的IP 头和IP 正文的前 8 个字节。
 而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。
* 侦察兵:报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。</description>
    </item>
    
    <item>
      <title>http缓存详解</title>
      <link>https://mannuan.github.io/post/20190706141207/</link>
      <pubDate>Sat, 06 Jul 2019 14:12:07 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190706141207/</guid>
      <description>前言 http缓存主要针对如css,js,图片等更新频率不大的静态文件。
http缓存字段的描述 根据请求和响应分为：
Request Headers（浏览器端） if-modified-since
请求头，缓存最新修改的时间，浏览器询问服务器，服务器会将它与last-modified进行比对
if-none-match
请求头，缓存标识，浏览器询问服务器询，服务器会将它与etag进行比对
Response Headers（服务器端） cache-control
控制http缓存的最高指令
常用值有:
1. no-store: 所有内容都不缓存
2. no-cache: 缓存，但是浏览器使用缓存前，都会请求服务器判断缓存是否是最新，过期的缓存就不使用
3. max-age=x(单位秒)在缓存后的x秒内不发请求，是http1.1的属性，类似于expires，但优先级高于expires
4. s-maxage=x(单位秒)代理服务器请求源站在缓存后的x秒内不发请求，只对CDN有效
5. public 客户端和代理服务器（CDN）都可缓存
6. private 只有客户端可以缓存
last-modified
响应头，缓存最新修改的时间，服务器返回给浏览器，优先级小于etag
etag
响应头，缓存标识，服务器返回给浏览器，优先级高于last-modified
expires
响应头，代表缓存过期时间，服务器返回，是http1.0的属性，优先级小于max-age
使用http缓存的原因  客户端每次都要请求服务器，浪费流量;
 服务器每次都得提供查找，下载，请求用户基础如果较大，服务器存在较大压力;
 客户端每次请求完都要进行页面渲染，用户体验较差。
  http缓存字段的关系 服务器和浏览器的对话  我将从服务器和浏览器的日常对话来阐述各个字段的起因和来由。
为了简化，服务器称为S，浏览器称为C
第一次对话(expires的由来)
 C: S，S，我要一个a.css文件，快发给我!!! S: 烦死了，给你，在expires时间前别来烦我!!!  第二次对话(last-modified和if-modified-since的由来)
C: S, S, 我的a.css文件到期了，你快给我发一个新的!!! S: 新的a.css? 它有修改过吗？ 你之前用的就是最新的吧? ... 呃😓我也不知道了，要不我们都记录一下时间吧？ 我用last-modified记录a.</description>
    </item>
    
    <item>
      <title>一个基于selenium的快速编写爬虫脚本的爬虫框架-beryllium</title>
      <link>https://mannuan.github.io/post/20190705212259/</link>
      <pubDate>Fri, 05 Jul 2019 21:22:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705212259/</guid>
      <description> 前言 之前在做智慧旅游的爬虫项目的时候，遇到了js动态加载网页内容的问题。导致必须适应selenium来解决问题，但是使用selenium太麻烦了。因此，开发了一个爬虫库，来快速编写爬虫脚本。
beryllium demo # -*- coding: utf-8 -*- from beryllium import Beryllium import time from beryllium import FieldList, Field, FieldName, Page, ListCssSelector, Mongodb, NextPageCssSelectorSetup, PageFunc bery = Beryllium() bery.driver = bery.get_driver() bery.fast_get_page(&amp;#34;https://www.baidu.com&amp;#34;) time.sleep(1) bery.until_send_text_by_css_selector(css_selector=&amp;#34;#kw&amp;#34;, text=&amp;#34;杭州&amp;#34;) bery.until_send_enter_by_css_selector(css_selector=&amp;#34;#kw&amp;#34;) time.sleep(2) fieldlist_shop = FieldList( Field(field_name=FieldName.SHOP_NAME, css_selector=&amp;#34;h3&amp;#34;), ) page_shop = Page(name=&amp;#34;shop_page&amp;#34;, field_list=fieldlist_shop, list_css_selector=ListCssSelector(list_css_selector=&amp;#34;#content_left &amp;gt; div.result.c-container&amp;#34;)) bery.until_click_no_next_page_by_css_selector( next_page_setup=NextPageCssSelectorSetup( page=page_shop, css_selector=&amp;#34;#page &amp;gt; a.n&amp;#34;, main_page_func=PageFunc(func=bery.from_page_get_data_list, page=page_shop) ) ) 演示 </description>
    </item>
    
    <item>
      <title>上传自己的python库到pip源</title>
      <link>https://mannuan.github.io/post/20190705200528/</link>
      <pubDate>Fri, 05 Jul 2019 20:05:28 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705200528/</guid>
      <description>前言 为了把项目分享给别人，我觉得还是放在pip上比较方便
编写README.md文件 介绍自己的项目，以及如何使用
编写setup.py文件 下面以我的配置文件为例：
# -*- coding: utf-8 -*- import setuptools with open(&amp;#34;README.md&amp;#34;, &amp;#34;r&amp;#34;) as fh: long_description = fh.read() setuptools.setup( name=&amp;#34;beryllium&amp;#34;, version=&amp;#34;1.0.0&amp;#34;, author=&amp;#34;mannuan&amp;#34;, author_email=&amp;#34;1271990125@qq.com&amp;#34;, description=&amp;#34;A framework for spider over selenium&amp;#34;, long_description=long_description, long_description_content_type=&amp;#34;text/markdown&amp;#34;, url=&amp;#34;https://github.com/mannuan/beryllium&amp;#34;, packages=setuptools.find_packages(), classifiers=[ &amp;#34;Programming Language :: Python :: 3&amp;#34;, &amp;#34;License :: OSI Approved :: MIT License&amp;#34;, &amp;#34;Operating System :: OS Independent&amp;#34;, ], install_requires=[ &amp;#34;selenium&amp;gt;=3.14.0&amp;#34;, &amp;#34;PyVirtualDisplay&amp;gt;=0.2.1&amp;#34;, &amp;#34;pymongo&amp;gt;=3.7.1&amp;#34;, &amp;#34;PyMySQL&amp;gt;=0.9.2&amp;#34;, ], ) 安装setuptools pip install setuptools 安装twine pip install twine 打包项目 python setup.</description>
    </item>
    
    <item>
      <title>import error No Module named Setuptools</title>
      <link>https://mannuan.github.io/post/20190705171744/</link>
      <pubDate>Fri, 05 Jul 2019 17:17:45 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705171744/</guid>
      <description>pip install setuptools</description>
    </item>
    
    <item>
      <title>兼容所有浏览器的清除前后空格的方法</title>
      <link>https://mannuan.github.io/post/20190705105222/</link>
      <pubDate>Fri, 05 Jul 2019 10:52:22 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705105222/</guid>
      <description>if(!String.prototype.trim){ String.prototype.trim = function(){ return this.replace(/^[\s]+/g, &amp;#39;&amp;#39;).replace(/[\s]+$/g, &amp;#39;&amp;#39;); } } </description>
    </item>
    
    <item>
      <title>异步脚本、延迟脚本与DOMContentLoaded的关系</title>
      <link>https://mannuan.github.io/post/20190705101104/</link>
      <pubDate>Fri, 05 Jul 2019 10:11:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705101104/</guid>
      <description>sync 如上图所示， HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。HTML文档解析完毕后触发DOMContentLoaded。
async 分为两种情况：异步脚本先执行完，dom先解析完或dom和异步脚本同时完成
异步脚本先执行完 HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件。
dom先解析完或dom和异步脚本同时完成 HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。
总结 DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 和sync脚本。
defer defer与上面的同步和异步脚本不同，defer执行脚本的阶段必须在dom解析完毕之后。它也分为两种情况：defer先加载完和dom先解析完
defer先加载完 HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。
dom先解析完 HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发domContentLoaded事件。
总结 如果在dom解析完成以后，defer脚本没有执行，在dom解析完成后，defer会率先被执行，会延迟domContentLoaded事件的触发。</description>
    </item>
    
    <item>
      <title>首屏时间与domContentLoaded触发时机的关系</title>
      <link>https://mannuan.github.io/post/20190705095553/</link>
      <pubDate>Fri, 05 Jul 2019 09:55:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705095553/</guid>
      <description>按照有无js和css，domContentLoaded的触发时机可以分为3类 没有js和css 只有css 有js和css 首屏时间 定义：计算这个网页从空白到出现内容所花费的时间
这段时间其实就是HTML 文档加载和解析的时间。也就是DOMContentLoaded 事件触发之前所经历的时间。
对于首屏时间而言，js放在HTML文档的开头和结尾处效果是一样的，而js放在结尾的目的并不是为了减少首屏时间，而是由于js经常需要操纵DOM，放在后面才更能保证找到DOM节点。</description>
    </item>
    
    <item>
      <title>onload、domContentLoaded和$(document).ready(function)的区别</title>
      <link>https://mannuan.github.io/post/20190705084243/</link>
      <pubDate>Fri, 05 Jul 2019 08:42:43 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190705084243/</guid>
      <description>为了更加直观的比较它们的加载顺序，我写了下面的网页
onload、domContentLoaded和$(document).ready(function)加载顺序对比
 加载顺序 domContentLoaded &amp;gt; $(document).ready(function) &amp;gt; onload
domContentLoaded mdn的解释： 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
domContentLoaded的写法是：
function DOMContentLoaded() { console.log(&amp;#39;我是onContentLoaded&amp;#39;); } document.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, DOMContentLoaded, false); // false表示在事件捕获阶段响应  $(document).ready(function) w3school的解释：当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。
 $(document).ready(function)实质上是使用了domContentLoaded方法，所以他的加载时间要早于onload
 $(document).ready(function)等价于$(function)和$().ready(function)
 其中$().ready(function)不推荐使用
 $(document).ready(function)可以编写多个，且输出多个结果
onload mdn解释：The load event is fired when the whole page has loaded, including all dependent resources such as stylesheets images.
onload有两种写法：
window.addEventListener(&amp;#39;load&amp;#39;, (event) =&amp;gt; { console.log(&amp;#39;page is fully loaded&amp;#39;); }); window.</description>
    </item>
    
    <item>
      <title>toString()、toLocaleString()和valueOf()的区别</title>
      <link>https://mannuan.github.io/post/20190704215403/</link>
      <pubDate>Thu, 04 Jul 2019 21:54:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190704215403/</guid>
      <description> 注意没有toLocalString()这种方法
 这几个方法主要在两种数据类型中使用
* 引用类型：Object, Array, Date
* 基本数据类型：Number, Boolean
其中只在：Date 和Number这两种类型中有区别
 Date类型 var a = new Date(); console.log(a.toString()); // Thu Jul 04 2019 22:42:17 GMT+0800 (China Standard Time) console.log(a.toLocaleString()); // 7/4/2019, 10:42:17 PM console.log(a.valueOf()); // 1562251337216  Number类型 var a = new Number(1000); console.log(a.toString()); //1000 console.log(a.toLocaleString()); //1,000 console.log(a.valueOf()); //1000  总结  toString()方法获取的是String(传统字符串),而toLocaleString()方法获取的是LocaleString(本地环境字符串)。 如果你开发的脚本在世界范围都有人使用，那么将对象转换成字符串时请使用toString()方法来完成。 如果是为了返回时间类型的数据，推荐使用LocaleString()。 若是在后台处理字符串，请务必使用toString()。  </description>
    </item>
    
    <item>
      <title>js数组类型的常用方法</title>
      <link>https://mannuan.github.io/post/20190704205305/</link>
      <pubDate>Thu, 04 Jul 2019 20:53:05 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190704205305/</guid>
      <description>concat() 合并数组，返回合并后的数组 var a = [1, 2, 3]; var b = [2, 3, 4]; var c = a.concat(b); console.log(a); //[1,2,3] console.log(b); //[2,3,4] console.log(c); //[1, 2, 3, 2, 3, 4]  join() 把数组连接成为字符串，并用指定分隔符隔开 var a = [1, 2, 3]; console.log(a.join(&amp;#34;/&amp;#34;)); // 1/2/3   和python的语法不同，方向刚好是相反的，而且python要求合并的必须是字符串类型
 # -*- coding: utf-8 -*- a = [1, 2, 3] a = [str(i) for i in a] print(&amp;#34;/&amp;#34;.join(a)) pop() 取出并返回栈顶元素 var a = [1, 2, 3]; console.</description>
    </item>
    
    <item>
      <title>python中的如何把当前时间转换为字符串</title>
      <link>https://mannuan.github.io/post/20190704202704/</link>
      <pubDate>Thu, 04 Jul 2019 20:27:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190704202704/</guid>
      <description>import datetime now_time_str = datetime.datetime.now().strftime(&amp;#34;%Y%m%d%H%M%S&amp;#34;) # 类似输出20190704213307</description>
    </item>
    
    <item>
      <title>Representing Social Media Users for Sarcasm Detection论文翻译和解读</title>
      <link>https://mannuan.github.io/post/20190704162010/</link>
      <pubDate>Thu, 04 Jul 2019 16:20:10 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190704162010/</guid>
      <description>Representing Social Media Users for Sarcasm Detection  用于讽刺检测的社交媒体用户的特征表示
 摘要 在上下文讽刺检测的背景下，两种表示作者特征的方式：
 使用贝叶斯的方式直接表示作者的讽刺倾向；
 密集向量嵌入可以学习到作者和文本之间的交互；
 使用reddit评论的SARC数据集，双向的rnn可以提高性能；
  贝叶斯的方法在同质的上下文中是足够的，密集的向量嵌入是有价值的 the Bayesian approach suffices in homogeneous contexts, whereas the added power of the dense embeddings proves valuable in more diverse ones. 
  介绍  Irony and sarcasm1 are extreme examples of context-dependence in language. Given only the text Great idea! or What a hardship!, we cannot resolve the speaker’s intentions unless we have in- sight into the circumstances of utterance – who is speaking, and to whom, and how the content relates to the preceding discourse (Clark, 1996).</description>
    </item>
    
    <item>
      <title>实验十三 利用ip标准访问控制列表acl进行网络流量的控制</title>
      <link>https://mannuan.github.io/post/20190701194642/</link>
      <pubDate>Mon, 01 Jul 2019 19:46:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701194642/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 掌握路由器上编号的标准 IP 访问列表规则及配置。
需求分析 只允许网段172.16.2.0与172.16.4.0的主机进行通信，不允许172.16.1.0去访问172.16.4.0网段的主机。
实验原理 IP ACL(IP 访问控制列表或IP访问列表)是实现对流经路由器或交换机的数据包根据一定的规则进行过滤，从而提高网络可管理性和安全性。 IP ACL分为两种:标准IP访问列表和扩展IP访问列表。 标准IP访问列表可以根据数据包的源IP地址定义规则，进行数据包的过滤。 扩展IP访问列表可以根据数据包的源IP、目的IP、源端口、目的端口、协议来定义规则，进行数据包的过滤。 IP ACL基于接口进行规则的应用，分为:入栈应用和出栈应用。 入栈应用是指由外部经该接口进行路由器的数据包进行过滤。 出栈应用是指路由器从该接口向外转发数据时进行数据包的过滤。 IP ACL 的配置有两种方式:按照编号的访问列表，按照命名的访问列表。 标准IP访问列表编号范围是1~99、1300~1999，扩展IP访问列表编号范围是100~199、2000~2699。
实验拓扑 选择设备  路由器：2台Generic（从左边数第一个） 主机：3台Generic（从左边数第一个）  实验demo 实验十三-利用ip标准访问控制列表acl进行网络流量的控制.pkt
实验步骤 设置左边的路由器 no Router&amp;gt;en Router#conf t Router(config)#inter loop0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter loop1 Router(config-if)#ip address 172.16.2.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter se2/0 Router(config-if)#clock rate 64000 Router(config-if)#ip address 172.16.3.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#exit Router(config)#ip route 0.0.0.0 0.</description>
    </item>
    
    <item>
      <title>实验十二 利用单臂路由实现vlan间的路由</title>
      <link>https://mannuan.github.io/post/20190701192111/</link>
      <pubDate>Mon, 01 Jul 2019 19:21:11 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701192111/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 掌握如何路由器端口上划分子接口、封装 Dot1Q(IEEE 802.1Q)协议，实现VLAN间的路由。
需求分析 需要在交换机上配置 VLAN，然后在路由器连接交换机的端口上划分子接口，给相应的VLAN设置IP地址，以实现 VLAN间的路由。
实验原理 在交换网络中，通过 VLAN 对一个物理网络进行了逻辑划分，不同的 VLAN 之间是无法直接访问的，必须通过三层的路由设备进行连接。一般利用路由器或三层交换机来实现不 同 VLAN 之间的互相访问。 将路由器和交换机相连，使用 IEEE 802.1Q 来启动一个路由器上的子接口成为干道模式，就可以利用路由器来实现 VLAN 之间的通信。 路由器可以从某一个VLAN接收数据包并且将这个数据包转发到另外的一个VLAN，要实施VLAN间的路由，必须在一个路由器的物理接口上启用子接口，也就是将以太网物理 接口划分为多个逻辑的、可编址的接口，并配置成干道模式，每个VLAN对应一个这种接口，这样路由器就能够知道如何到达这些互联的VLAN。
实验拓扑 选择设备  交换机：1台2960 路由器：1台Generic（从左边数第一个） 主机：2台Generic（从左边数第一个）  实验demo 实验十二-利用单臂路由实现vlan间路由.pkt
实验步骤 设置交换机 Switch&amp;gt;en Switch#conf t Switch(config)#vlan 10 Switch(config-vlan)#vlan 20 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/2 Switch(config-if)#switchport access vlan 20 Switch(config-if)#inter fa0/3 Switch(config-if)#switchport mode trunk Switch(config-if)#end Switch#sh run  设置路由器 no Router&amp;gt;en Router#conf t Router(config)#inter fa0/0 Router(config-if)#no ip address Router(config-if)#no shut Router(config-if)#inter fa0/0.</description>
    </item>
    
    <item>
      <title>实验十一 ospf基本配置</title>
      <link>https://mannuan.github.io/post/20190701182805/</link>
      <pubDate>Mon, 01 Jul 2019 18:28:05 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701182805/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 掌握在路由器上配置OSPF单区域。
需求分析 需要在路由器和交换机上配置OSPF路由协议，使全网互通，从而实现信息的共享和传递。
实验原理 OSPF(Open Shortest Path First，开放式最短路径优先)协议，是目前网络中应用最广泛 的路由协议之一。属于内部网关路由协议，能够适应各种规模的网络环境，是典型的链路状 态(link-state)协议。 OSPF 路由协议通过向全网扩散本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库(LSDB)，然后路由器采用SPF算法，以自己为根，计算到达 其他网络的最短路径，最终形成全网路由信息。 OSPF属于无类路由协议，支持VLSM(变长子网掩码)。OSPF是以组播的形式进行链 路状态的通告的。 在大规模的网络环境中，OSPF支持区域的划分，将网络进行合理规划。划分区域时必须存在area0(骨干区域)。其他区域和骨干区域直接相连，或通过虚链路的方式连接。
实验拓扑 选择设备  交换机：1台3650-24PS 路由器：2台Generic（从左边数第一个）  实验demo 实验十一ospf基本配置.pkt
实验步骤 设置三层交换机 Switch&amp;gt;en Switch(config)#vlan 10 Switch(config-vlan)#vlan 50 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/2 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/3 Switch(config-if)#switchport access vlan 50 Switch(config-if)#inter vlan 10 Switch(config-if)#ip address 172.16.1.2 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#inter vlan 50 Switch(config-if)#ip address 172.16.5.1 255.255.255.0 Switch(config-if)#no shut %ospf取别名为123，只能设置为数字 Switch(config-if)#router ospf 123 Switch(config-router)#network 172.</description>
    </item>
    
    <item>
      <title>实验十 RIP路由协议基本配置</title>
      <link>https://mannuan.github.io/post/20190701172233/</link>
      <pubDate>Mon, 01 Jul 2019 17:22:33 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701172233/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 掌握在路由器上如何配置 RIP 路由协议。
需求分析 两台路由器通过快速以太网端口连接在一起，每个路由器上设置2个Loopback端口模拟子网，在所有端口运行RIP路由协议，实现所有子网间的互通。
实验原理 RIP(Routing Information Protocols，路由信息协议)是应用较早、使用较普遍的 IGP(Interior Gateway Protocol，内部网关协议)，适用于小型同类网络，是典型的距离矢量 (distance-vector)协议。 RIP 协议以跳数做为衡量路径开销的，RIP 协议里规定最大跳数为 15。 RIP 在构造路由表时会使用到 3 种计时器:更新计时器、无效计时器、刷新计时器。 它让每台路由器周期性地向每个相邻的邻居发送完整的路由表。路由表包括每个网络或子网 的信息，以及与之相关的度量值。
实验拓扑 选择设备  路由器：2台Generic（从左边数第一个）  实验demo 实验十-RIP路由协议基本配置.pkt
实验步骤 设置左边的路由器 no Router&amp;gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 192.168.1.1 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shut Router(config-if)#inter loop0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#inter loop1 Router(config-if)#ip address 172.16.2.1 255.255.255.0 Router(config-if)#router rip Router(config-router)#network 172.16.0.0 Router(config-router)#network 192.168.1.0 Router(config-router)#end Router#sh run  设置右边的路由器 no Router&amp;gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 192.</description>
    </item>
    
    <item>
      <title>实验六 跨交换机实现vlan间的路由</title>
      <link>https://mannuan.github.io/post/20190701105039/</link>
      <pubDate>Mon, 01 Jul 2019 10:50:39 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701105039/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
 当前的实验无法在6.0.0.0045以上版本测试成功
 实验目的 利用三层交换机跨交换机实现VLAN间路由。
需求分析 在二层交换机上划分VLAN配置Trunk实现不同VLAN的主机接入，在三层交换机上划分VLAN配置Trunk并配置SVI接口实现不同VLAN间路由。
实验原理 在二层交换机上划分VLAN可实现不同VLAN的主机接入，而VLAN间的主机通信为不同网段间的通信，需要通过三层设备对数据进行路由转发才可以实现，通过在三层交换机上为各VLAN配置SVI接口，利用三层交换机的路由功能可以实现VLAN间的路由。
实验拓扑 选择设备  交换机：1台3560-24PS，2台2960 移动终端：2台Generic（从左边数第一个）  实验demo 实验六-跨交换机实现vlan间路由.pkt
实验步骤 设置最上面的交换机 Switch&amp;gt;en Switch#conf t Switch(config)#vlan 10 Switch(config-vlan)#vlan 20 Switch(config)#inter vlan 10 Switch(config-if)#ip address 192.168.10.1 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#inter vlan 20 Switch(config-if)#ip address 192.168.20.1 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#end Switch#sh run  设置左边的2960交换机 Switch&amp;gt;en Switch#conf t Switch(config)#inter fa0/2 Switch(config-if)#switch mode trunk Switch(config-if)#vlan 10 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#end Switch#sh run  设置右边的2960交换机 Switch&amp;gt;en Switch#conf t Switch(config)#inter fa0/2 Switch(config-if)#switch mode trunk Switch(config-if)#vlan 20 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 20 Switch(config-if)#end Switch#sh run  设置左边的主机 1、打开&amp;rdquo;IP Configure&amp;rdquo;</description>
    </item>
    
    <item>
      <title>实验九 配置动态nat</title>
      <link>https://mannuan.github.io/post/20190701101121/</link>
      <pubDate>Mon, 01 Jul 2019 10:11:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701101121/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 配置网络地址变换，为私有地址的用户提供到外部网络的资源的访问。
需求分析 ISP 提供商给 IT 企业的一段公共 IP 地址的地址段为 200.1.1.200~100.1.1.210，需要内网使用这段址去访问 Internet，考虑到包括安全在内的诸多因素，公司希望对外部隐藏内部 网络。
实验原理 在路由器上定义内网与外网接口，利用 NAT 地址池实现内网对外网的访问，并把内网 隐藏起来。
实验拓扑 选择设备  交换机：1台2960 移动终端：2台Generic（从左边数第一个） 路由器：2台Generic（从左边数第一个）  实验demo 实验九-配置动态nat.pkt
实验步骤 设置左边的路由器 no Router&amp;gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.2 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shutdown Router(config-if)#end Router#sh run  设置右边的路由器 no Router&amp;gt;en Router#conf t Router(config)#ip route 0.0.0.0 0.0.0.0 se2/0 Router(config)#access-list 10 permit 172.16.1.0 0.0.0.255 Router(config)#ip nat pool test 200.1.1.200 200.</description>
    </item>
    
    <item>
      <title>实验八 配置静态nat</title>
      <link>https://mannuan.github.io/post/20190701090625/</link>
      <pubDate>Mon, 01 Jul 2019 09:06:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190701090625/</guid>
      <description>实验平台 Cisco模拟器，Version：5.3.0.0088
实验目的 配置网络地址变换，提供到公司共享服务器的可靠外部访问，即把内网的ip映射到公网ip。
需求分析 公司需要将 172.16.1.5 和 172.16.1.6 两台主机作为共享服务器，需要外网能够访问，考虑到包括安全在内的诸多因素，公司希望对外部隐藏内部网络。
实验原理 在路由器上把 172.16.1.5、172.16.1.6 两台主机静态映射到外部，把内网隐藏起来。
实验拓扑 选择设备  交换机：1台2960 移动终端：2台Generic（从左边数第一个） 路由器：2台Generic（从左边数第一个）  实验demo 实验八-配置静态nat.pkt
实验步骤 设置左边的路由器 no Router&amp;gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.2 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shutdown Router(config-if)#end Router#sh run  设置右边的路由器 no Router&amp;gt;en Router#conf t Router(config)#ip route 0.0.0.0 0.0.0.0 se2/0 Router(config)#ip nat inside source static 172.16.1.5 200.1.1.80 Router(config)#ip nat inside source static 172.16.1.6 200.1.1.81 Router(config)#inter se2/0 Router(config-if)#ip address 200.</description>
    </item>
    
    <item>
      <title>Chrome设置PAC模式无效的解决方案</title>
      <link>https://mannuan.github.io/post/20190630230818/</link>
      <pubDate>Sun, 30 Jun 2019 23:08:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190630230818/</guid>
      <description>发现问题 以Ubuntu系统为例，我们通过genpac生成autoproxy.pac文件，然后点击系统设置-&amp;gt;网络-&amp;gt;代理设置-&amp;gt;自动，在输入框中输入file://绝对路径/autoproxy.pac。设置好以后，Chrome应当可以自动切换网络，但是Chrome无法访问google的搜索引擎，而火狐浏览器可以正常访问。
分析问题 出现上面问题的唯一可能就是Chrome设置有误，因此点击设置-&amp;gt;高级设置-&amp;gt;打开代理设置，打开的就是Ubuntu系统的网络设置。因此，我们可以判断自动代理模式设置失效，这里我们就要仔细分析为什么会失效？
解决方案 出现上面问题的主要原因是：Chrome移除对file://和data:协议的支持，目前只能使用http://协议。因此，我们打算使用nginx实现对本地文件的http映射。
安装nginx sudo apt-get install nginx 修改nginx.cnf配置文件 vim /etc/nginx/nginx.conf 在nginx.conf的http{...}代码块中输入:
server{ listen 80; #注意这里不用&amp;#34;:&amp;#34;隔开，listen后面没有冒号  server_name 127.0.0.1; #注意这里不用&amp;#34;:&amp;#34;隔开，server_name后面没有冒号  location /autoproxy.pac { alias 绝对路径/autoproxy.pac; } } 重启nginx
sudo nginx -s reload 把http://127.0.0.1/autoproxy.pac填写到系统设置-&amp;gt;网络-&amp;gt;代理设置-&amp;gt;自动代理中</description>
    </item>
    
    <item>
      <title>原生js实现JSONP</title>
      <link>https://mannuan.github.io/post/20190629214157/</link>
      <pubDate>Sat, 29 Jun 2019 21:41:57 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190629214157/</guid>
      <description>介绍 JSONP是JSON with Padding(填充式JSON或参数式JSON)的简写，是一种非常常用的跨域请求方式。主要原理是利用了script 标签可以跨域请求的特性，由其 src属性发送请求到服务器，服务器返回JavaScript 代码，浏览器接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。
JSONP由两部分组成：回调函数和数据，回调函数是当响应到来时应该在页面中调用的函数，回调函数的名字一般在请求中指定。当服务器响应时，服务器端就会把该函数和数据拼成字符串返回。
JSONP 的请求过程  请求阶段：浏览器创建一个 script 标签，并给其src 赋值(类似 http://example.com/api/?callback=jsonpCallback）。 发送请求：当给script的src赋值时，浏览器就会发起一个请求。 数据响应：服务端将要返回的数据作为参数和函数名称拼接在一起(格式类似”jsonpCallback({name: &#39;abc&#39;})”)返回。当浏览器接收到了响应数据，由于发起请求的是 script，所以相当于直接调用 jsonpCallback 方法，并且传入了一个参数。  服务端交互示意图 server1代码(Nodejs实现) var Koa = require(&amp;#39;koa&amp;#39;); var Router = require(&amp;#39;koa-router&amp;#39;); var querystring = require(&amp;#39;querystring&amp;#39;); var app = new Koa(); var router = new Router(); //处理get请求 router.get(&amp;#39;/get&amp;#39;, async function(ctx){ var params = querystring.parse(ctx.request.url.split(&amp;#39;?&amp;#39;)[1]); var data = { message: &amp;#34;我是&amp;#34; + ctx.request.header.host + &amp;#34;，我收到了你的get请求！！！&amp;#34; } ctx.status=200; ctx.</description>
    </item>
    
    <item>
      <title>验证Promise是同步的</title>
      <link>https://mannuan.github.io/post/20190628220548/</link>
      <pubDate>Fri, 28 Jun 2019 22:05:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628220548/</guid>
      <description>前言 Promise是ES6提出的解决异步编程导致陷入回调的地狱问题。
例子1 console.log(1); var a=new Promise(function(resolve, reject){ console.log(2); resolve(); }); console.log(2); var b = new Promise(function(resolve, reject){ console.log(4); resolve(); }); console.log(5); a.then(function(){ console.log(6); }); b.then(function(){ console.log(7); });   顺序输出：1~7
 例子2 console.log(1); var a = new Promise(function(resolve, reject){ resolve(); console.log(2); }); a.then(function(){ console.log(6); }); console.log(3); var b = new Promise(function(resolve, reject){ resolve(); console.log(4); }); b.then(function(){ console.log(7); }); console.log(5);   顺序输出：1~7
 结论 Promise本身是同步的，但.then和.catch方法是异步的</description>
    </item>
    
    <item>
      <title>原生js、jQuery和Vue.js的Ajax的详细对比</title>
      <link>https://mannuan.github.io/post/20190628213546/</link>
      <pubDate>Fri, 28 Jun 2019 21:35:46 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628213546/</guid>
      <description>原生js ajax(&amp;#39;get&amp;#39;, &amp;#39;http://127.0.0.1:3000/get&amp;#39;, function(response){ alert(JSON.parse(response)[&amp;#39;message&amp;#39;]); }); ajax(&amp;#39;post&amp;#39;, &amp;#39;http://127.0.0.1:3000/post&amp;#39;, function (response) { alert(JSON.parse(response)[&amp;#39;message&amp;#39;]); }, JSON.stringify({name: &amp;#34;post测试&amp;#34;})); function ajax(method, url, callback, data, async){ var data=data || null; var async=async || true; var xhr = new window.XMLHttpRequest || ActiveXObject(&amp;#39;Microsoft.XMLHTTP&amp;#39;); xhr.open(method, url, async); xhr.setRequestHeader(&amp;#39;content-type&amp;#39;, &amp;#39;application/json&amp;#39;); xhr.send(data); console.log(&amp;#34;发送的数据是：&amp;#34;+data); xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status &amp;gt;=200&amp;amp;&amp;amp;xhr.status&amp;lt;300||xhr.status==304){ console.log(&amp;#34;完成请求，响应就绪&amp;#34;); callback(this.responseText); } } } }  原生js-Promise ajax(&amp;#39;get&amp;#39;, &amp;#39;http://127.0.0.1:3000/get&amp;#39;).then(function (data) { alert(JSON.parse(data).message); }).catch(function (error) { alert(error); }); ajax(&amp;#39;post&amp;#39;, &amp;#39;http://127.</description>
    </item>
    
    <item>
      <title>关于Ajax的jQuery、Vue.js、原生js的各个版本的实现对比</title>
      <link>https://mannuan.github.io/post/20190628203826/</link>
      <pubDate>Fri, 28 Jun 2019 20:38:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628203826/</guid>
      <description>目录
前言
1、原生js实现
2、原生js实现——Promise版本
3、jQuery实现
4、Vue.js实现
总结
前言  下面对于各个版本的Ajax代码，想要实际测试它们，可以把它命名为server2.html，然后放在当前目录views目录下面。具体的教程可以看测试Ajax的Nodejs服务端代码
 1、原生js实现 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;原生js版本&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button&amp;gt;点击我发送get请求&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button&amp;gt;点击我发送post请求&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; document.getElementsByTagName(&amp;#39;button&amp;#39;)[0].addEventListener(&amp;#39;click&amp;#39;, function () { ajax(&amp;#39;get&amp;#39;, &amp;#39;http://127.0.0.1:3000/get&amp;#39;, function (response) { alert(JSON.parse(response)[&amp;#39;message&amp;#39;]); }); }); document.getElementsByTagName(&amp;#39;button&amp;#39;)[1].addEventListener(&amp;#39;click&amp;#39;, function () { ajax(&amp;#39;post&amp;#39;, &amp;#39;http://127.0.0.1:3000/post&amp;#39;, function (response) { alert(JSON.parse(response)[&amp;#39;message&amp;#39;]); }, JSON.stringify({ name: &amp;#34;post测试&amp;#34; })); }); function ajax(method, url, callback, data, async) { data = data || null; async = async || true; var xhr = new window.</description>
    </item>
    
    <item>
      <title>测试Ajax的Nodejs服务端代码</title>
      <link>https://mannuan.github.io/post/20190628174910/</link>
      <pubDate>Fri, 28 Jun 2019 17:49:10 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628174910/</guid>
      <description>前言  由于使用Ajax必须要有一个服务端来接收消息，为了方便我使用Nodejs来搭建服务端。同时，为了兼顾实践跨域的方法，我在这里搭建了两个服务端。其中，一个服务端用来响应Ajax请求，另外一个服务端用作加载页面。这样就产生了跨域的问题，我采用的是cors的解决方案，具体的实现，请看sever1的代码。
 前期准备工作  安装nodejs，可以参看我的这篇教程 选择koa2作为服务端 安装模块：koa，koa-router，koa2-cors，koa-bodyparser，koa-art-template，path  服务端交互示意图 文件路径示意图 server1.js var Koa = require(&amp;#39;koa&amp;#39;); var Router = require(&amp;#39;koa-router&amp;#39;); var cors = require(&amp;#39;koa2-cors&amp;#39;); var bodyParser = require(&amp;#39;koa-bodyparser&amp;#39;); var app = new Koa(); var router = new Router(); //下面的代码必须写在设置路由的前面 app.use(cors({ origin: function (ctx) { return &amp;#39;http://127.0.0.1:4000&amp;#39;; }, exposeHeaders: [&amp;#39;WWW-Authenticate&amp;#39;, &amp;#39;Server-Authorization&amp;#39;], maxAge: 5, credentials: true, allowMethods: [&amp;#39;GET&amp;#39;, &amp;#39;POST&amp;#39;, &amp;#39;DELETE&amp;#39;], allowHeaders: [&amp;#39;Content-Type&amp;#39;, &amp;#39;Authorization&amp;#39;, &amp;#39;Accept&amp;#39;], })); //配置post提交数据的中间件 app.use(bodyParser()); //处理get请求 router.get(&amp;#39;/get&amp;#39;, async function(ctx){ ctx.</description>
    </item>
    
    <item>
      <title>nodejs安装教程（完美避坑，适用于mac和linux）</title>
      <link>https://mannuan.github.io/post/20190628152512/</link>
      <pubDate>Fri, 28 Jun 2019 15:25:12 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628152512/</guid>
      <description>安装nodejs mac端 brew install node 如果安装速度慢，可以到nodejs官网下载pkg安装包；
linux端 apt安装方式(不推荐，nodejs的版本太旧) sudo apt-get install nodejs 官网下载安装 nodejs官网下载node-vxx.xx.x-linux-x64.tar.xz安装包
安装步骤  解压  unar node-vxx.xx.x-linux-x64.tar.xz   移动node-vxx.xx.x-linux-x64到/usr/local/下面   为了防止nodejs被篡改，保险起见放在根目录下面
 sudo mv node-vxx.xx.x-linux-x64 /usr/local/  配置nodejs的环境变量  修改.zshrc或者.bashrc这两个配置文件，具体取决于你自己使用的是什么终端主题
 由于nodejs是普通用户级别的命令，不建议修改/etc/profile
 export PATH=/usr/local/node-vxx.xx.x-linux-x64/bin:$PATH 检查安装 node -v npm -v 修改node_modules目录权限 教程
添加node_modules路径 教程</description>
    </item>
    
    <item>
      <title>node require can&#39;t find module(适用于mac或linux，不支持window)</title>
      <link>https://mannuan.github.io/post/20190628114044/</link>
      <pubDate>Fri, 28 Jun 2019 11:40:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628114044/</guid>
      <description> 前言  我已经正确的安装了node，并且我使用npm install -g 安装包没有出错，但是就是在代码中导入包的时候使用require(&#39;安装包&#39;)报错，我的全局模块路径是在/usr/local/lib/node_modules下面
 原因分析 可能是node命令早不到npm的安装包的安装目录，于是我打印了node默认的模块目录：
node module.paths [ &amp;#39;/Users/用户名/repl/node_modules&amp;#39;, &amp;#39;/Users/用户名/node_modules&amp;#39;, &amp;#39;/Users/node_modules&amp;#39;, &amp;#39;/node_modules&amp;#39;, &amp;#39;/Users/用户名/.node_modules&amp;#39;, &amp;#39;/Users/用户名/.node_libraries&amp;#39;, &amp;#39;/usr/local/lib/node&amp;#39; ] 我发现，/usr/local/lib/node_modules目录并没有包含在里面，于是我使用下面的命令：
module.paths.push(&amp;#39;/usr/local/lib/node_modules&amp;#39;) 虽然这个命令生效了，但它是暂时性的。但我并不知道如何永久的把我的模块目录添加进去。 为了解决这个问题，我使用软链接的来解决这个问题。
解决方案 ln -sfn /usr/local/lib/node_modules /Users/$USER/node_modules  由于根据npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules，node_module目录的拥有者是当前用户，所以没有必要使用sudo命令.
 </description>
    </item>
    
    <item>
      <title>npm list -g出错</title>
      <link>https://mannuan.github.io/post/20190628110638/</link>
      <pubDate>Fri, 28 Jun 2019 11:06:38 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628110638/</guid>
      <description>前言  我是在重装node之后遇到这个问题的
 原因分析 当你已经安装node之后，它给你以下提示说明你已经安装好了：
This package has installed: Node.js v10.16.0 to /usr/local/bin/node npm v6.9.0 to /usr/local/bin/npm Make sure that /usr/local/bin is in your $PATH.  但是，当你使用下面命令，报错了
npm list -g 推测 我认为可能是没有卸载干净
解决方案 我使用ls -a命令打印出了home目录下面的隐藏文件，发现了几个可以目录, &amp;quot;.npm&amp;quot;, &amp;quot;.npminstall_tarball&amp;quot;, &amp;quot;.node-gyp&amp;quot;。我把他们删除以后就不报错了
结论 这些隐藏目录下面的配置文件的优先级比较高，导致出错</description>
    </item>
    
    <item>
      <title>npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules</title>
      <link>https://mannuan.github.io/post/20190628104030/</link>
      <pubDate>Fri, 28 Jun 2019 10:40:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628104030/</guid>
      <description> 原因分析  详看错误提示：npm ERR! Error: EACCES: permission denied, access /usr/local/lib/node_modules 推测当前用户没有对node_modules目录的写入权限
 验证推测 &amp;gt;&amp;gt; ls -lth /usr/local/lib/node_modules total 0 drwxr-xr-x 24 root wheel 768B May 29 05:21 npm 观看上面的结果推测成立
解决方案 方案一（不推荐） 修改node_modules目录的权限，增加”写入“权限；
sudo chmod 775 /usr/local/lib/node_modules  并不推荐这种方案，因为这个目录完全不会有root用户进行访问
 方案二 （推荐） 改变node_nodules目录的拥有者
sudo chown -R $USER /usr/local/lib/node_modules</description>
    </item>
    
    <item>
      <title>mac下pkg安装包卸载</title>
      <link>https://mannuan.github.io/post/20190628101517/</link>
      <pubDate>Fri, 28 Jun 2019 10:15:17 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190628101517/</guid>
      <description>Mac下的安装和删除都比windows更加简单清晰，这点在dmg方式下非常明显，但很多时候我们会使用pkg来进行安装，这样的安装想删除就有点麻烦了。
比如，我安装了Golang这个pkg用于go语言的编译，安装后确实可以使用，但安装的是一个工具链，并不是一个应用软件。所以在Application目录下是没有内容的，你可以查到安装在/usr/local/go这个目录下，但是否所有的内容都安装在这个目录下呢？我删除这个pkg的目的是为了用源码直接编译出工具链来应用，如果还有其他一些配置文件遗漏，可能会导致后续配置的问题。
经过一些搜索和学习，觉得有两个方法：
 使用pkgutil命令  首先运行pkgutil --pkgs | grep -i go，这样会列出含有go字样的pkg
这里我们可以看到，运行命令后列出了所有名字中含有&amp;rdquo;go&amp;rdquo;的pkg，其中com.googlecode.go就是我们golang的pkg，也就是我们要删除的pkg。
然后运行pkgutil &amp;ndash;files com.googlecode.go这个命令，这个命令会列出pkg的所有安装的文件，根据这个列表就可以保证删除干净了，再也没有后患。
比如对于golang的pkg，虽然有长长的一个列表，我们还是可以总结出来，除/usr/local/go之外，还有etc/paths.d/go这个文件需要删除。
 直接使用工具，这样可以傻瓜化的一键搞定，下载地址：http://www.corecode.at/uninstallpkg/   除了这两个方法之外，还有其他的方法，不过我觉得这两个方法比较清晰简单。第一个方法主要是手动删除，适用于熟练的资深工程师；第二个方法一键完成，适用于一切玩家。</description>
    </item>
    
    <item>
      <title>优化mac触摸板（Trackpad）使用体验的推荐设置</title>
      <link>https://mannuan.github.io/post/20190627165448/</link>
      <pubDate>Thu, 27 Jun 2019 16:54:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190627165448/</guid>
      <description>右键菜单 使用”双指点击“代替”右键“
上下左右滚动页面 使用”双指拖动“代替”鼠标“
切换窗口 使用”四指拖动“代替”传统的组合快捷键“
快捷返回桌面 使用”五指释放“代替”传统的组合快捷键“
打开Launchpad 使用”五指收回“
左键点击 使用”单指轻触“代替左键点击</description>
    </item>
    
    <item>
      <title>iTerm2的常用快捷键</title>
      <link>https://mannuan.github.io/post/20190627162924/</link>
      <pubDate>Thu, 27 Jun 2019 16:29:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190627162924/</guid>
      <description>   快捷键 功能     command+D 新建Tab   command+数字 切换Tab    </description>
    </item>
    
    <item>
      <title>mac使用快捷键打开iTerm2</title>
      <link>https://mannuan.github.io/post/20190627154651/</link>
      <pubDate>Thu, 27 Jun 2019 15:46:51 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190627154651/</guid>
      <description>前言  使用快捷键打开item窗口的一个前提是iTerm必须已经打开了
 选择iTerm2，点击prefences 点击Profiles 新建窗口实例 常用的窗口属性 设置窗口名称 设置窗口字体 设置窗口透明度 设置窗口的快捷键 设置窗口的位置 有多种设置窗口位置的方法，比如”置顶“，”正常模式“等</description>
    </item>
    
    <item>
      <title>关于Content-Type几种值的区别及用法</title>
      <link>https://mannuan.github.io/post/20190626224453/</link>
      <pubDate>Wed, 26 Jun 2019 22:44:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190626224453/</guid>
      <description>1、Content-Type 的值类型：
1.1 application/json：消息主体是序列化后的 JSON 字符串
1.2 application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式
1.3 multipart/form-data： 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件之时使用的
1.4 text/plain：数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。
2、application/json 和 application/x-www-form-urlencoded的区别
2.1 application/json：作用： 告诉服务器请求的主题内容是json格式的字符串，服务器端会对json字符串进行解析，好处： 前端人员不需要关心数据结构的复杂度，只要是标准的json格式就能提交成功。
2.2 application/x-www-form-urlencoded：是Jquery的Ajax请求默认方式作用：在请求发送过程中会对数据进行序列化处理，以键值对形式？key1=value1&amp;amp;key2=value2的方式发送到服务器，好处：所有浏览器都支持
3、 application/x-www-form-urlencoded：信息数据被编码为名称/值对，这是标准且默认的编码格式
3.1 当action为get时候，客户端把form数据转换成一个字串append到url后面，用&amp;rsquo;?&amp;lsquo;分割。
3.2 当action为post时候，浏览器把form数据封装到http body中，然后发送到server。（可以取消post请求的预检请求）
Vue中 content-type 设置</description>
    </item>
    
    <item>
      <title>网站优化 14条--雅虎十四条优化原则</title>
      <link>https://mannuan.github.io/post/20190626102231/</link>
      <pubDate>Wed, 26 Jun 2019 10:22:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190626102231/</guid>
      <description>相信互联网已经越来越成为人们生活中不可或缺的一部分。Ajax，flex等等富客户端的应用使得人们越加“幸福”地体验着许多原先只能在C/S实 现的功 能。比如Google机会已经把最基本的office应用都搬到了互联网上。当然便利的同时毫无疑问的也使页面的速度越来越慢。自己是做前端开发的，在性能方面，根据Yahoo的调查，后台只占5%，而前端高达95%之多，其中有88%的东西是可以优化的。
[外链图片转存失败(img- edenZ0UF-1562139364811)(http://www.phpv.net/uploadfile/month_200901/local_xahdWW7qeV.jpg)]
以上是一张web2.0页面的生命周期图。工程师很形象地讲它分成了“怀孕，出生，毕业，结婚”四个阶段。如果在我们点击网页链接的时候能够意识到 这个过程而不是简单的请求-响应的话，我们便可以挖掘出很多细节上可以提升性能的东西。今天听了淘宝小马哥的一个对yahoo开发团队对web性能研究的 一个讲座，感觉收获很大，想在blog上做个分享。
相信很多人都听过优化网站性能的14条规则。更多的信息可见developer.yahoo.com
   1. 尽可能的减少 HTTP 的请求数 content     2. 使用 CDN（Content Delivery Network） server   3. 添加 Expires 头(或者 Cache-control ) server   4. Gzip 组件 server   5. 将 CSS 样式放在页面的上方 css   6. 将脚本移动到底部（包括内联的） javascript   7. 避免使用 CSS 中的 Expressions css   8. 将 JavaScript 和 CSS 独立成外部文件 javascript css   9.</description>
    </item>
    
    <item>
      <title>CSS三种引入方式：内联、页级、外联</title>
      <link>https://mannuan.github.io/post/20190625205945/</link>
      <pubDate>Tue, 25 Jun 2019 20:59:45 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190625205945/</guid>
      <description>1.内联CSS 内联CSS也可称为行内CSS或者行级CSS，它直接在标签内部引入，显著的优点是十分的便捷、高效；但是同时也造成了不能够重用样式的缺点，如果代码行数到达一定长度不建议采用。通常内联CSS作为测试使用，可以查找代码中bug。
&amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width: 65px;height: 20px;border: 1px solid;&amp;#34;&amp;gt;测试元素div&amp;gt; &amp;lt;body&amp;gt; 2.页级CSS 页级CSS也可称为内部CSS，整体是放在head标签里边的，在style标签里边定义样式，作用范围和字面意思相同，仅限于本页面的元素；如果你写的代码超过了几百行，想想每次把代码页拉到最上边都很烦，所以它在可维护性方面较差。
&amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;/&amp;gt; &amp;lt;title&amp;gt;测试title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; div { width: 65px; height: 20px; border: 1px solid; background: greenyellow; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; 3. 外联CSS 外联CSS也可称为外部CSS，在实际的项目中通常使用此种方式，它只在页面中使用link或者@import引入即可，可维护性好；并且外联CSS是一个单独的文件，可以作用于多个页面，在修改的时候可以针对性地修改某一块区域，达到多个页面样式同时变更，相较于内联CSS和页级CSS，省去了到每个页面修改的步骤，提高了开发效率，同时一定程度提高了性能。
接下来具体说说link和@import的区别：
(1)link: link语法格式中，rel指的是关联(relation)，type指的是类型，href指的是链接文件路径。
link的作用主要用来引入CSS和网页图标，指示告知搜索引擎，网页之间的关系等。
(2)@import: @import语法格式务必写在style标签中，后直接加文件路径即可。
@import作用在CSS文件和页面中，可以在一个CSS文件中引入其他的CSS文件，例如在index.css文件中引入其他CSS文件的样式，整合在一起后，再在index.html中调用一次即可，在实际项目中经常使用，方便管理和维护。
(3)二者加载顺序影响 HTML加载过程：
1) 加载HTML-DOM结构 2)CSS和JS 3)图片和多媒体 4)加载事件触发 link和@import都没有放置顺序的要求，但是不同的放置位置可能会造成效果显示的差异。对于link，无论放到哪个位置，都是一边加载数据，一边进行优化，视觉感受很好；而对于@import，放置到哪里，才从哪里开始加载CSS样式，即先加载数据，然后加载样式，如果网速不佳，可能会造成只有数据出来，而样式一点点加载的效果。并且在同一个页面中，调用两种方式，link永远比@import优先级高。
在项目中使用的时候，一般在页面中调用方式为link，并且放在head标签中；使用@import除了在CSS文件中，在页面调用时，一般加载第三方的样式会使用到，并且需要放置在页面的底部，不会影响自己的网站。</description>
    </item>
    
    <item>
      <title>JavaScript debugger 语句</title>
      <link>https://mannuan.github.io/post/20190625164126/</link>
      <pubDate>Tue, 25 Jun 2019 16:41:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190625164126/</guid>
      <description>实例 开启 debugger ，代码在执行到第三行前终止。
var x = 15 * 5; debugger; document.getElementbyId(&amp;#34;demo&amp;#34;).innerHTML = x;  定义和用法 debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。
使用 debugger 语句类似于在代码中设置断点。
通常，你可以通过按下 F12 开启调试工具， 并在调试菜单中选择&amp;rdquo;Console&amp;rdquo; 。
注意： 如果调试工具不可用，则调试语句将无法工作。
更多 JavaScript 调试信息，及在浏览器不支持的情况下如何激活浏览器的调试工具，请查阅我们的JavaScript调试 教程。
浏览器支持
 语句
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  debugger
  Yes
  Yes
  Yes
  Yes
  Yes
  语法  JavaScript 版本：
  1.</description>
    </item>
    
    <item>
      <title>javascript创建对象的10种模式</title>
      <link>https://mannuan.github.io/post/20190624213600/</link>
      <pubDate>Mon, 24 Jun 2019 21:36:00 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190624213600/</guid>
      <description>第1种：对象字面量
//对象字面量（速度快，推荐使用） var animal = {property: &amp;#34;都要呼吸&amp;#34;, getProperty: function(){return this.property;}}; var person = {feature: &amp;#34;直立行走&amp;#34;, getFeature: function(){return this.feature;}};  第2种：Object构造函数
var animal = new Object(); animal.property=&amp;#34;都要呼吸&amp;#34;; animal.getProperty=function(){return this.property;} var person = new Object(); person.feature=&amp;#34;直立行走&amp;#34;; person.getFeature = function(){return this.feature;}  第3种：工厂模式
function createAnimal(){var animal=new Object();animal.property=&amp;#34;都要呼吸&amp;#34;;animal.getProperty=function(){return this.property;} return animal;} function createPerson(){var person=new Object();person.feature=&amp;#34;直立行走&amp;#34;;person.getFeature=function(){return this.feature;} return person;} var animal = createAnimal(); var person = createPerson();  第4种：构造函数模式
function Animal(){this.property=&amp;#34;都要呼吸&amp;#34;;this.getProperty=function(){return this.property;};} function Person(){this.feature=&amp;#34;直立行走&amp;#34;;this.getFeature=function(){return this.feature;};} var animal = new Animal(); var person = new Person();  第5种：原型模式</description>
    </item>
    
    <item>
      <title>javascript继承的6种方式</title>
      <link>https://mannuan.github.io/post/20190624200748/</link>
      <pubDate>Mon, 24 Jun 2019 20:07:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190624200748/</guid>
      <description>第一种：原型链继承： function Animal(){ this.property=&amp;#34;都要呼吸&amp;#34;; } Animal.prototype.getProperty = new function(){ return this.property; } function Person(){ this.feature=&amp;#34;直立行走&amp;#34;; } Person.prototype = new Animal(); Person.prototype.getFeature = function(){ return this.feature; } var p1 = new Person(); console.log(p1.getProperty()); console.log(p1.getFeature());  第二种：借用构造函数继承: function Animal(){ this.property=&amp;#34;都要呼吸&amp;#34;; this.getProperty=function(){ return this.property; }; } function Person(){ Animal.call(this); this.feature=&amp;#34;直立行走&amp;#34;; } Person.prototype.getFeature = function(){ return this.feature; } var p1 = new Person(); console.log(p1.getProperty()); console.log(p1.getFeature());  第三种：组合继承:（最常用的继承模式） function Animal(){ this.property=&amp;#34;都要呼吸&amp;#34;; } Animal.prototype.getProperty = function(){ return this.</description>
    </item>
    
    <item>
      <title>强大的pdf压缩工具</title>
      <link>https://mannuan.github.io/post/20190622235521/</link>
      <pubDate>Sat, 22 Jun 2019 23:55:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622235521/</guid>
      <description>Smallpdf目前是全网免费的pdf压缩工具中压缩率最高的，没有之一。但是由于目前在线的版本开始收费了，所以我专门下载了离线版进行crack，供以后长期使用。目前这个离线版本的压缩效果还是相当不错，它比目前流行的pdf压缩工具PDFCompressor的压缩效果要好50%。yqiq, fnas</description>
    </item>
    
    <item>
      <title>关于mac的time machine功能</title>
      <link>https://mannuan.github.io/post/20190622192423/</link>
      <pubDate>Sat, 22 Jun 2019 19:24:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622192423/</guid>
      <description>前言  最近这一个月，我发现我的mac空间不足了。我一直以为是我项目占据了很多空间。因此，不停的进行清理不用的东西。最后，还是发现空间不够。这个清理工作反反复复持续了几周，我电脑硬盘的可以存储空间还是很少。在不经意间，我用外部硬盘time machine备份了一下电脑，瞬间多了一大半的存储空间。我前面几个月也是经常备份电脑的，但是最近这个月由于论文和找工作的缘故没有时间备份。
 总结 mac如果开启time machine功能，就会定期进行备份。如果不用外部硬盘进行备份，就会先被分在本机硬盘上。这样会消耗大量的存储空间。但是，如果不开time machine，资料就没有保障。因此，定期用外部硬盘进行备份尤为重要。</description>
    </item>
    
    <item>
      <title>css书写常见错误</title>
      <link>https://mannuan.github.io/post/20190622151359/</link>
      <pubDate>Sat, 22 Jun 2019 15:13:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622151359/</guid>
      <description> 每个属性之间用分号&amp;rdquo;;&amp;ldquo;隔开;  </description>
    </item>
    
    <item>
      <title>vue常见错误汇总</title>
      <link>https://mannuan.github.io/post/20190622103331/</link>
      <pubDate>Sat, 22 Jun 2019 10:33:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622103331/</guid>
      <description> new Vue(), V要大写 .vue文件中的&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;中不可以出现空行 vue模板中的el指向的是id，所以为了标识id，在前面要加上&amp;rdquo;#&amp;rdquo;  </description>
    </item>
    
    <item>
      <title>attr()和addClass()的区别</title>
      <link>https://mannuan.github.io/post/20190622092813/</link>
      <pubDate>Sat, 22 Jun 2019 09:28:13 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622092813/</guid>
      <description>   方法 addClass() attr()     用途 追加样式 设置样式   对同一个网页元素操作 &amp;lt;p&amp;gt;test&amp;lt;/p&amp;gt;    第1次使用方法 $(&amp;quot;p&amp;quot;).addClass(&amp;quot;high&amp;quot;); $(&amp;quot;p&amp;quot;).attr(&amp;quot;class&amp;quot;, &amp;quot;high&amp;quot;);   第1次结果 &amp;lt;p class=&amp;quot;high&amp;quot;&amp;gt;test&amp;lt;/p&amp;gt;    再次使用方法 $(&amp;quot;p&amp;quot;).addClass(&amp;quot;another&amp;quot;); $(&amp;quot;p&amp;quot;).attr(&amp;quot;class&amp;quot;, &amp;quot;another&amp;quot;);   最终结果 &amp;lt;p class=&amp;quot;high another&amp;quot;&amp;gt;test&amp;lt;/p&amp;gt; &amp;lt;p class=&amp;quot;another&amp;quot;&amp;gt;test&amp;lt;/p&amp;gt;    </description>
    </item>
    
    <item>
      <title>val()方法的选中功能</title>
      <link>https://mannuan.github.io/post/20190622092753/</link>
      <pubDate>Sat, 22 Jun 2019 09:27:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622092753/</guid>
      <description>&amp;lt;select id=&amp;#34;single&amp;#34;&amp;gt; &amp;lt;option&amp;gt;选择1号&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选择2号&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选择3号&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;select id=&amp;#34;multiple&amp;#34; multiple=&amp;#34;multiple&amp;#34; style=&amp;#34;height:120px;&amp;#34;&amp;gt; &amp;lt;option selected=&amp;#34;selected&amp;#34;&amp;gt;选择1号&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选择2号&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选择3号&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选择4号&amp;lt;/option&amp;gt; &amp;lt;option selected=&amp;#34;selected&amp;#34;&amp;gt;选择5号&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;input type=&amp;#34;checkbox&amp;#34; value=&amp;#34;check1&amp;#34;/&amp;gt;多选1 &amp;lt;input type=&amp;#34;checkbox&amp;#34; value=&amp;#34;check2&amp;#34;/&amp;gt;多选2 &amp;lt;input type=&amp;#34;checkbox&amp;#34; value=&amp;#34;check3&amp;#34;/&amp;gt;多选3 &amp;lt;input type=&amp;#34;checkbox&amp;#34; value=&amp;#34;check4&amp;#34;/&amp;gt;多选4 &amp;lt;input type=&amp;#34;radio&amp;#34; value=&amp;#34;radio1&amp;#34;/&amp;gt;单选1 &amp;lt;input type=&amp;#34;radio&amp;#34; value=&amp;#34;radio2&amp;#34;/&amp;gt;单选2 &amp;lt;input type=&amp;#34;radio&amp;#34; value=&amp;#34;radio3&amp;#34;/&amp;gt;单选3 该网页中的一些元素是默认选中的，可以通过val()方法来改变它们的选中项。如果要使第1个下拉框的第2项被选中，可以用以下jQuery代码实现：
$(&amp;#34;#single&amp;#34;).val(&amp;#34;选择2号&amp;#34;);  如果使下拉框的第2项和第3项被选中，可以用以下jQuery代码实现:
$(&amp;#34;#multiple&amp;#34;).val([&amp;#34;选择2号&amp;#34;, &amp;#34;选择3号&amp;#34;]);  按照上面类似的写法，下面的代码可以使多选框和单选框被选中，jQuery代码如下：
$(&amp;#34;:checkbox&amp;#34;).val([&amp;#34;check2&amp;#34;, &amp;#34;check3&amp;#34;]); $(&amp;#34;:radio&amp;#34;).val([&amp;#34;radio2&amp;#34;]); </description>
    </item>
    
    <item>
      <title>parent()，parents()与closest()的区别</title>
      <link>https://mannuan.github.io/post/20190622092726/</link>
      <pubDate>Sat, 22 Jun 2019 09:27:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622092726/</guid>
      <description>   方法 描述 示例     parent() 获得集合中每个匹配元素的父级元素 $(&#39;.item-1&#39;).parent().css(&#39;background-color&#39;,&#39;red&#39;); parent()方法从指定类型的直接父节点开始查找。parent()返回一个元素节点。   parents() 获得集合中每个匹配元素的祖先元素 $(&#39;.item-1&#39;).parents(&#39;ul&#39;).css(&#39;background-color&#39;, &#39;red&#39;);
parents()方法查找同parent()方法类似，不同的一点在于，当它找到第一个父节点时并没有停止查找，而是继续查找，最后返回多个父节点。   closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 $(.item-1).closest(&amp;quot;ul&amp;quot;).css(&amp;quot;background-color&amp;quot;, &#39;red&#39;);
closest()方法查找是从包含自身的节点找起，它同parents()方法类似，不同点在于它的只返回匹配的第一个节点。    </description>
    </item>
    
    <item>
      <title>snippet，让你编码效率翻倍</title>
      <link>https://mannuan.github.io/post/20190622092650/</link>
      <pubDate>Sat, 22 Jun 2019 09:26:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190622092650/</guid>
      <description>如何打开snippet配置 这里以vscode为例，其他编辑器大概也差不多。在vscode中快捷键Ctrl + Shift + P打开命令窗口，然后输入snippet,选择配置用户代码片段，点击后，就可以愉快的进行片段的编写了。
Snippet怎么用 先上一个Demo
{ &amp;#34;vue&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;vue-tl&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;!DOCTYPE html&amp;gt;&amp;#34;, &amp;#34;&amp;lt;html lang=\&amp;#34;zh\&amp;#34;&amp;gt;&amp;#34;, &amp;#34;&amp;lt;head&amp;gt;&amp;#34;, &amp;#34; &amp;lt;meta charset=\&amp;#34;UTF-8\&amp;#34;&amp;gt;&amp;#34;, &amp;#34; &amp;lt;title&amp;gt;${1:$CURRENT_DATE}&amp;lt;/title&amp;gt;&amp;#34;, &amp;#34; &amp;lt;style type=\&amp;#34;text/css\&amp;#34;&amp;gt;&amp;#34;, &amp;#34; &amp;lt;/style&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://cdn.staticfile.org/vue/2.2.2/vue.min.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34; &amp;lt;script src=\&amp;#34;https://server.lab421.top/前端开发/我自己的js库/wlib.js\&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/head&amp;gt;&amp;#34;, &amp;#34;&amp;lt;body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/body&amp;gt;&amp;#34;, &amp;#34;&amp;lt;script&amp;gt;&amp;#34;, &amp;#34;var data = {};&amp;#34;, &amp;#34;var vm = new Vue({&amp;#34;, &amp;#34; el: &amp;#39;#app&amp;#39;,&amp;#34;, &amp;#34; data: data,&amp;#34;, &amp;#34; methods: {}&amp;#34;, &amp;#34;});&amp;#34;, &amp;#34;&amp;lt;/script&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/html&amp;gt;&amp;#34;, ], &amp;#34;description&amp;#34;: &amp;#34;create a html frame&amp;#34;, }, &amp;#34;basic&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;basic-tl&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;!</description>
    </item>
    
    <item>
      <title>jQuery插入节点的方法</title>
      <link>https://mannuan.github.io/post/20190621195930/</link>
      <pubDate>Fri, 21 Jun 2019 19:59:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621195930/</guid>
      <description>方法 描述 示例     append() 向每个匹配的元素内部追加内容 HTML代码: &amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt; jQuery代码: $(&amp;quot;p&amp;quot;).append(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;); 结果: &amp;lt;p&amp;gt;我想说：&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;   appendTo() 将所有匹配的元素追加到指定元素中，实际上，使用该方法是颠倒了常规的$(A).append(B)的操作，即不是将B追加到A中，而是将A追加到B中 HTML代码：
&amp;lt;p&amp;gt;我想说:&amp;lt;/p&amp;gt; jQuery代码:
$(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;).appendTo(&amp;quot;p&amp;quot;); 结果:
&amp;lt;p&amp;gt;我想说：&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;   prepend() 向每个匹配的元素内部前置内容 HTML代码：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt; jQuery代码：
$(&amp;quot;p&amp;quot;).prepend(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;);
结果：
&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;我想说：&amp;lt;/p&amp;gt;   prependTo() 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).prepend(B)的操作，即不是将B前置到A中，而是将A前置到B中 HTML代码：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt;
jQuery代码:
$(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;).prependTo(&amp;quot;p&amp;quot;);
结果:
&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;我想说：&amp;lt;/p&amp;gt;   after() 在每个匹配的元素之后插入内容 HTML代码：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt;
jQuery代码：
$(&amp;quot;p&amp;quot;).after(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;);
结果：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;   insertAfter() 将所有匹配的元素插入到指定元素的后面。实际上，使用该方法是颠倒了常规的$(A).after(B)的操作，即不是讲B插入到A后面，而是将A插入到B后面 HTML代码：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt;
jQuery代码:
$(&amp;quot;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;&amp;quot;).insertAfter(&amp;quot;p&amp;quot;);
结果：
&amp;lt;p&amp;gt;我想说：&amp;lt;/p&amp;gt;&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;   before() 在每个匹配的元素之前插入内容 HTML代码：</description>
    </item>
    
    <item>
      <title>表单选择器</title>
      <link>https://mannuan.github.io/post/20190621134332/</link>
      <pubDate>Fri, 21 Jun 2019 13:43:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621134332/</guid>
      <description>   选择器 描述 返回 示例     :input 选取所有的&amp;lt;input&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;select&amp;gt;和&amp;lt;button&amp;gt;元素 集合元素 $(&amp;quot;:input&amp;quot;)选取所有&amp;lt;input&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;select&amp;gt;和&amp;lt;button&amp;gt;元素   :text 选取所有的单行文本框 集合元素 $(&amp;quot;:text&amp;quot;)选取所有的单行文本框   :password 选取所有的密码框 集合元素 $(&amp;quot;:password&amp;quot;)选取所有的密码框   :radio 选取所有的单选框 集合元素 $(&amp;quot;:radio&amp;quot;)选取所有的单选框   :checkbox 选取所有的复选框 集合元素 $(&amp;quot;:checkbox&amp;quot;)选取所有的复选框   :submit 选取所有的提交按钮 集合元素 $(&amp;quot;:submit&amp;quot;)选取所有的提交按钮   :image 选取所有的图像按钮 集合元素 $(&amp;quot;:image&amp;quot;)选取所有的图像按钮   :reset 选取所有的重置按钮 集合元素 $(&amp;quot;:reset&amp;quot;)选取所有的重置按钮   :button 选取所有按钮 集合元素 $(&amp;quot;:button&amp;quot;)选取所有的按钮   :file 选取所有的上传域 集合元素 $(&amp;quot;:file&amp;quot;)选取所有的上传域   :hidden 选取所有不可见元素 集合元素 $(&amp;quot;:hidden&amp;quot;)选取所有不可见元素（已经在不可见过滤选择器中讲解过）    </description>
    </item>
    
    <item>
      <title>表单对象属性过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621112044/</link>
      <pubDate>Fri, 21 Jun 2019 11:20:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621112044/</guid>
      <description>   选择器 描述 返回 示例     :enabled 选取所有可用的元素 集合元素 $(&#39;#form1:enabled&#39;);选取id为&amp;rdquo;form1&amp;rdquo;的表单内的所有可用元素   :disabled 选取所有不可用的元素 集合元素 $(&amp;quot;#form2:disabled&amp;quot;)选取id为&amp;rdquo;form2&amp;rdquo;的表单内的所有不可用的元素   :checked 选取所有被选中的元素（单选框，复选框） 集合元素 $(&amp;quot;input:checked&amp;quot;)；选取所有被选中的&amp;lt;input&amp;gt;元素   :selected 选取所有被选中的选项元素（下拉列表） 集合元素 $(&amp;quot;select option:checked&amp;quot;);选取所有被选中的选项元素    </description>
    </item>
    
    <item>
      <title>子元素过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621111026/</link>
      <pubDate>Fri, 21 Jun 2019 11:10:26 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621111026/</guid>
      <description>   选择器 描述 返回 示例     :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而:eq(index)是从0算起的   :first-child 选取每个父元素的第一个子元素 集合元素 :first只返回单个元素，而:first-child选择符将为每个父元素匹配第一个子元素。
例如$(&#39;ul li:first-child&#39;)；选取每个&amp;lt;ul&amp;gt;中第一个&amp;lt;li&amp;gt;元素   :last-child 选取每个父元素的最后子元素 集合元素 同样，:last只返回单个元素，而:last-child选择符将为每个父元素匹配最后一个子元素。
例如$(&#39;ul li:last-child&#39;);选择每个&amp;lt;ul&amp;gt;中最后一个&amp;lt;li&amp;gt;元素   :only-child 如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(&#39;ul li:only-child&#39;)
在&amp;lt;ul&amp;gt;中选取是唯一子元素的&amp;lt;li&amp;gt;元素    </description>
    </item>
    
    <item>
      <title>属性过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621104825/</link>
      <pubDate>Fri, 21 Jun 2019 10:48:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621104825/</guid>
      <description>   选择器 描述 返回 示例     [attribute] 选取拥有此属性的元素 集合元素 $(‘div[id]’)选取拥有属性id的元素   [attribute=value] 选取属性的值为value的元素 集合元素 $(‘div[title=test]’)选取属性title为“test”的&amp;lt;div&amp;gt;元素   [attribute!=value] 选取属性的值不等于value的元素 集合元素 $(&#39;div[title!=test]&#39;)选取属性title不等于&amp;rdquo;test&amp;rdquo;的&amp;lt;div&amp;gt;元素（注意：没有属性title的&amp;lt;div&amp;gt;元素也会被选取）   [attribute^=value] 选取属性的值以value开始的元素 集合元素 $(&#39;div[title^=test]&#39;)选取属性title以“test”开始的&amp;lt;div&amp;gt;元素   [attribute$=value] 选取属性的值以value结束的元素 集合元素 $(&#39;div[title$=test]&#39;)选取属性title以“test”结束的&amp;lt;div&amp;gt;元素   [attribute*=value] 选取属性的值含有value的元素 集合元素 $(&#39;div[title*=test]&#39;)选取属性title含有&amp;rdquo;test&amp;rdquo;的&amp;lt;div&amp;gt;元素   `[attribute =value]` 选取属性等于给定字符串或以该字符串为前缀（该字符串后跟一个连字符“-”）的元素 集合元素   [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(&#39;div[title~=&amp;quot;uk&amp;quot;]&#39;)选取属性title用空格分隔的值中包含字符uk的元素   [attribute1][attribute2]...[attributeN] 用属性选择器合并成一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围。 集合元素 $(&#39;div[id][title$=&amp;quot;test&amp;quot;]&#39;)选取拥有属性id，并且属性title以“test”结束的&amp;lt;div&amp;gt;元素    </description>
    </item>
    
    <item>
      <title>可见性过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621102607/</link>
      <pubDate>Fri, 21 Jun 2019 10:26:07 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621102607/</guid>
      <description>   选择器 描述 返回 示例     :hidden 选取所有不可见的元素 集合元素 $(&amp;quot;:hidden&amp;quot;)选取所有不可见的元素。包括&amp;lt;input type=&amp;quot;hidden&amp;quot;/&amp;gt;，&amp;lt;div style=&amp;quot;display:none&amp;quot;&amp;gt;和&amp;lt;div style=&amp;quot;visibility:hidden;&amp;quot;&amp;gt;等元素。如果只想选取&amp;lt;input&amp;gt;元素，可以使用$(&amp;quot;input:hiddden&amp;quot;)   :visible 选取所有可见的元素 集合元素 $(&amp;quot;div:visible&amp;quot;)选取所有可见的&amp;lt;div&amp;gt;元素    </description>
    </item>
    
    <item>
      <title>内容过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621101710/</link>
      <pubDate>Fri, 21 Jun 2019 10:17:10 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621101710/</guid>
      <description>   选择器 描述 返回 示例     :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(&#39;div:contains(&#39;我&#39;)&#39;)选取含有文本“我”的&amp;lt;div&amp;gt;元素   :empty 选取不包含子元素或者文本的空元素 集合元素 $(&#39;div:empty&#39;)选取不包含子元素（包括文本元素）的&amp;lt;div&amp;gt;空元素   :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(&#39;div:has(p)&#39;)选取含有&amp;lt;p&amp;gt;元素的&amp;lt;div&amp;gt;元素   :parent 选取含有子元素或者文本的元素 集合元素 $(&#39;div:parent&#39;)选取拥有子元素（包括文本元素）的&amp;lt;div&amp;gt;元素    </description>
    </item>
    
    <item>
      <title>基本过滤选择器</title>
      <link>https://mannuan.github.io/post/20190621100750/</link>
      <pubDate>Fri, 21 Jun 2019 10:07:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621100750/</guid>
      <description>   选择器 描述 返回 示例     :first 选取第一个元素 单个元素 $(&#39;div:first&#39;)选取所有&amp;lt;div&amp;gt;元素中第一个&amp;lt;div&amp;gt;元素   :last 选取最后一个元素 单个元素 $(&#39;div:last&#39;)选取所有元素最后一个`元素   :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(&#39;input:not(.myClass)&#39;)选取class不是myClass的&amp;lt;input&amp;gt;元素   :even 选取索引是偶数的所有元素，索引从0开始 集合元素 $(&#39;input:even&#39;)选取索引是偶数的&amp;lt;input&amp;gt;元素   :odd 选取索引是奇数的所有元素，索引从0开始 集合元素 $(&#39;input:odd&#39;)选取索引是奇数的&amp;lt;input&amp;gt;元素   :eq(index) 选取索引等于index的元素（index从0开始） 单个元素 $(&#39;input:eq(1)&#39;)选取索引等于1的元素   :gt(index) 选取索引大于index的元素(index从0开始) 集合元素 $(&#39;input:gt(1)&#39;)选取索引大于1的&amp;lt;input&amp;gt;元素（注：大于1，不包括1）   :lt(index) 选取索引小于index的元素(index从0开始) 集合元素 $(&#39;input:lt(1)&#39;)选取索引小于1的&amp;lt;input&amp;gt;元素（注：小于1，不包括1）   :header 选取所有的标题元素，例如h1，h2，h3等等 集合元素 $(&#39;:header&#39;)选取网页中所有的&amp;lt;h1&amp;gt;，&amp;lt;h2&amp;gt;，&amp;lt;h3&amp;gt;&amp;hellip;&amp;hellip;   :animated 选取当前正在执行动画的所有元素 集合元素 $(&#39;div:animated&#39;)选取正在执行动画的&amp;lt;div&amp;gt;元素   :focus 选取当前获取焦点的元素 集合元素 $(&#39;:focus&#39;)选取当前获取焦点的元素    </description>
    </item>
    
    <item>
      <title>层次选择器的4种选择器列表</title>
      <link>https://mannuan.github.io/post/20190621091652/</link>
      <pubDate>Fri, 21 Jun 2019 09:16:52 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621091652/</guid>
      <description>   选择器 描述 返回 示例     $(&amp;quot;ancestor descendant&amp;quot;) 选取ancestor元素里的所有descendant（后代）元素 集合元素span $(&amp;quot;div span&amp;quot;)
选取&amp;lt;div&amp;gt;里的所有的&amp;lt;span&amp;gt;元素   $(&amp;quot;parent &amp;gt; child&amp;quot;) 选取parent元素下的child（子）元素，与$(&amp;quot;ancestor descendant&amp;quot;)
有区别，$(&amp;quot;ancestor descendant&amp;quot;)
选择的是后代元素 集合元素 $(&amp;quot;div &amp;gt; span&amp;quot;)
选取&amp;lt;div&amp;gt;元素下元素名是&amp;lt;span&amp;gt;的子元素   $(&amp;quot;prev + next&amp;quot;) 选取紧接在prev元素后的next元素 集合元素 $(&amp;quot;.one + div&amp;quot;)
选取class为one的下一个&amp;lt;div&amp;gt;同辈元素   $(&amp;quot;prev ~ siblings&amp;quot;) 选取prev元素之后的所有siblings元素 集合元素 $(&amp;quot;#two ~ div&amp;quot;)
选取id为two的元素后面的所有&amp;lt;div&amp;gt;同辈元素    </description>
    </item>
    
    <item>
      <title>jQuery基本选择器</title>
      <link>https://mannuan.github.io/post/20190621090254/</link>
      <pubDate>Fri, 21 Jun 2019 09:02:54 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190621090254/</guid>
      <description>   选择器 描述 返回 示例     #id 根据给定的id匹配一个元素 单个元素 $(&amp;quot;#test&amp;quot;)选取id为test的元素   .class 根据给定的类名匹配元素 集合元素 $(&amp;quot;.test&amp;quot;)选取所有class为test的元素   element 根据给定的元素名匹配元素 集合元素 $(&amp;quot;p&amp;quot;)选取所有的&amp;lt;p&amp;gt;元素   * 匹配所有元素 集合元素 $(&amp;quot;*&amp;quot;)选取所有的元素   selector1, selector2, &amp;hellip;., selectorN 将每一个选择器匹配到的元素合并后一起返回 集合元素 $(&amp;quot;div, span, p.myClass&amp;quot;)选取所有&amp;lt;div&amp;gt;,&amp;lt;span&amp;gt;和拥有class为myclass的&amp;lt;p&amp;gt;标签的一组元素    </description>
    </item>
    
    <item>
      <title>SVD分解</title>
      <link>https://mannuan.github.io/post/20190620213838/</link>
      <pubDate>Thu, 20 Jun 2019 21:38:38 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190620213838/</guid>
      <description></description>
    </item>
    
    <item>
      <title>python3 快速替换多个字符的高效方法</title>
      <link>https://mannuan.github.io/post/20190620141309/</link>
      <pubDate>Thu, 20 Jun 2019 14:13:09 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190620141309/</guid>
      <description>前言 在我们遇到需要把字符串中多个指定字符转换成其他字符时，我们通常使用多个.replace()方法实现替换的目的。然而，当需要替换的字符很多的时候，使用.replace()就太麻烦了。
解决方案 str.maketrans(in_str1, out_str2), 这是一个类似于对字符串之间建立映射的一个方法，且两个输入字符串的长度必须相等。下面我将举一个简单例子来说明它的使用方法：
a = &amp;#34;hello-world!&amp;#34; trans = str.maketrans(&amp;#34;h-w&amp;#34;, &amp;#34;H W&amp;#34;) # 建立映射关系 a.translate(trans) // 输出&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>anki保留字</title>
      <link>https://mannuan.github.io/post/20190619223131/</link>
      <pubDate>Wed, 19 Jun 2019 22:31:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190619223131/</guid>
      <description>   保留字 备注     FrontSide 正面，   type 打字   cloze 填空    </description>
    </item>
    
    <item>
      <title>anki最新开发文档（2.1）</title>
      <link>https://mannuan.github.io/post/20190619215021/</link>
      <pubDate>Wed, 19 Jun 2019 21:50:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190619215021/</guid>
      <description>注意：开发文档里面不重要的内容，本篇博客不进行翻译，依然英文显示
 基础 卡片（Cards） 卡片就是问题和答案对——即正反两面分别是问题和答案。Anki的卡片不是一张真正的卡片，它一直显示问题，回答完显示答案。举一个例子：
 问题：氧气的化学符号是什么？
 当你考虑问题完毕，点击卡片就会显示如下内容：
 问题：氧气到的化学符号是什么？
回答：O
 然后在卡片的最下方，你可以选择一个选项告诉anki你的学习情况。
牌组（Desks） 牌组是卡片的集合。你可以把卡片放在不同的牌组中学习，而没有必要一次性全部学完。每个牌组都可以有不同的设置，比如每天显示多少张卡片，或卡片下一次复习的时间。
牌组之间可以多层嵌套，形成树形结构。Anki通过&amp;rdquo;::&amp;ldquo;来表明不同的层次。比如，一个名为“Chinese::Hanzi”的牌组，表示Hanzi牌组包含在Chinese牌组中。如果你选择“Hanzi”那么就只会显示“Hanzi”牌组中的卡片；如果你选择&amp;rdquo;Chinese&amp;rdquo;牌组就会显示全部包括在“Hanzi”牌组中的卡片。
为了形成树形结构，我们不仅可以通过“::“符号，还可以使用拖拽的方式。嵌套在其他牌组下面的牌组称为子牌组（名称中至少出现一次&amp;rdquo;::&amp;ldquo;）,最外面的牌组可以被称为超级牌组或父牌组。
Anki有一个默认牌组；任何其他牌组都是分离自这个默认牌组。Anki将会隐藏这个默认牌组当这个牌组中没有卡片，或已经存在其他的牌组。另外，你也可以重命名默认牌组并使用它。
牌组可以放不同话题的卡片，而不是特定的卡片。具体可以参看合理的使用牌组部分。
关于卡片在牌组中的显示顺序，可以查阅显示顺序部分。
笔记和字段（Notes &amp;amp; Fields） 当制作卡片的时候，我们通常希望一些信息可以通过多张卡片显示出来。比如，如果你学习法语，你学习”bonjour“的意思是”hello“,你可能希望创建一张卡片显示&amp;rdquo;bonjour&amp;rdquo;回答&amp;rdquo;hello&amp;rdquo;，然后另一张卡片问你”hello“回答&amp;rdquo;bonjour&amp;rdquo;。前面一张卡片让你辨别单词含义，后面一张卡片则让你把单词翻译成本国语言。
当使用纸质卡片的时候，你唯一的选择是两次写出信息，每张卡片一次。一些计算机卡片程序通过翻转正反面，使用更加轻松。这种程序对纸质情况有改进，但是存在两个缺点：
 Because such programs don’t track your performance of recognition and production separately, cards will tend not to be shown to you at the optimum time, meaning you forget more than you’d like, or you study more than is necessary. Reversing the question and answer only works when you want exactly the same content on each side.</description>
    </item>
    
    <item>
      <title>jquery要点</title>
      <link>https://mannuan.github.io/post/20190619170644/</link>
      <pubDate>Wed, 19 Jun 2019 17:06:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190619170644/</guid>
      <description> jQuery中最有特色的莫过于它的链式操作方式——即对发生在同一个jQuery对象上的一组动作，可以直接连写而无需重复获取对象。这一特点是jQuery的代码无比优雅。 百度CDN: https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js     window.onload与$(document).ready()的对比(p6) window.onload $(document).ready()     执行时机 必须等待网页中所有元素加载完毕后（包括元素的所有关联文件）完全加载到浏览器后才能执行——即js此时可以访问页面中的任何元素 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完—即DOM完全就绪   多次使用 不能同时编写多个以下代码无法正确执行：
window.onload = function(){
alert(&amp;quot;test1&amp;quot;)
};
window.onload = function(){
alert(&amp;quot;test2&amp;quot;);
}
结果只会输出“test2”
$(window).load(function(){
//编写代码
});
等价于JavaScript中的以下代码：
window.onload = function(){
//编写代码
} 能同时编写多个一下代码正确执行：
$(document).ready(function(){
alert(&amp;quot;Hello World!&amp;quot;);
});
$(document).ready(function(){
alert(&amp;quot;Hello again!&amp;quot;);
});
结果两次都输出   简化写法 无 $(document).ready(function(){
//...
})
可以简化为：
$function(){
//...
}
第二种方式为：
$().ready(function(){
//...
});    </description>
    </item>
    
    <item>
      <title>linux 和windows下使用ffmpeg将mkv转换为mp4</title>
      <link>https://mannuan.github.io/post/20190617145615/</link>
      <pubDate>Mon, 17 Jun 2019 14:56:15 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190617145615/</guid>
      <description>ffmpeg -i 名称.mkv -s hd720 -c:v libx264 -crf 23 -c:a aac -strict -2 名称.</description>
    </item>
    
    <item>
      <title>四六级信息匹配技巧</title>
      <link>https://mannuan.github.io/post/20190613104834/</link>
      <pubDate>Thu, 13 Jun 2019 10:48:34 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190613104834/</guid>
      <description> 标出每个问题的定位词； 然后对每一个选项分别进行定位词的查找，标出每个选项里面的定位词；  </description>
    </item>
    
    <item>
      <title>四六级仔细阅读技巧</title>
      <link>https://mannuan.github.io/post/20190612101223/</link>
      <pubDate>Wed, 12 Jun 2019 10:12:23 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190612101223/</guid>
      <description> 引言 四六级阅读中，真正与解题有关的句子总共占了文章的1/3，因此真正用到的高级词汇不会很多。使用一些技巧可以快速的通过考试，如下：
 浏览一遍问题的题干（不要翻译，只需要看句子的主谓宾），并标出定位词（最多由三个单词组成，找定位词主要靠个人感觉，需要多练） 读懂题干的意思 根据定位词定位1~2句话，优先选择定位词后面的句子，实在不行至多定位4句话，如果3句话定位不了，暂时先看后面的题目（定位的过程中，不要翻译，重要的事情说三遍，不要翻译，一般来说题目的序号和段落的序号是成正比的，举个例子，一般最后一题的答案会出现在最后一个段落） 精读定位句，遇到和答案长的一样的一定是正确答案，遇到绝对的词一定是错误选项 如果下一题的定位词也在这题的定位句中，那么可以把当前的定位句向后扩充到3句   表示绝对的词汇总（但出现在正确答案里面）：completely, 定位句前移的词（定位词后面的句子如果以这种词开头，就选择定位词前面的句子作为定位句）：if 表达否定的词：far from
 </description>
    </item>
    
    <item>
      <title>webpack如何设置是否自动开启浏览器</title>
      <link>https://mannuan.github.io/post/20190611225641/</link>
      <pubDate>Tue, 11 Jun 2019 22:56:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190611225641/</guid>
      <description> 当我们执行npm run dev命令的时候，我们想要自动开启浏览器，那么只需要在webpack-dev-server后面加上&amp;rdquo;&amp;ndash;open&amp;rdquo;参数，具体在package.json文件里面设置，配置文件内容如下：
 { &amp;#34;name&amp;#34;: &amp;#34;webpack-demo1&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;main.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;dev&amp;#34;: &amp;#34;webpack-dev-server --open&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack -p&amp;#34; }, &amp;#34;license&amp;#34;: &amp;#34;MIT&amp;#34; }</description>
    </item>
    
    <item>
      <title>在UEFI模式下，linux误删EFI分区后，重新恢复引导</title>
      <link>https://mannuan.github.io/post/20190611191355/</link>
      <pubDate>Tue, 11 Jun 2019 19:13:55 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190611191355/</guid>
      <description>遇到上面情况，我们通常使用boot-repair修复引导。但是这时会弹出一个错误： GPT detected. Please create a BIOS-Boot partition
 遇到这个情况以后，我就疯狂百度资料，一直在找现成的解决方案，但是都不是没有解决问题的方案。这个期间我大概花了我半天的时间在检索资料，之后由于实在找不到资料。我只能冷静地分析这个错误，&amp;rdquo;Please create Bios-Boot partition&amp;rdquo;这个提示其实是提醒你创建一个用于引导的分区。由于是在UEFI模式下面，所以我们要创建一个格式为fat32 标识为boot, esp的分区（右键可以设置标签），如下图所示：
创建好上面的分区以后，再使用boot-repair进行修复引导，就不会报错了😀😀😀😀😀</description>
    </item>
    
    <item>
      <title>python字体文件woff转xml</title>
      <link>https://mannuan.github.io/post/20190611170124/</link>
      <pubDate>Tue, 11 Jun 2019 17:01:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190611170124/</guid>
      <description>from fontTools.ttLib import TTFont def get(): font = TTFont(&amp;#39;./tyc-num.woff&amp;#39;) font.</description>
    </item>
    
    <item>
      <title>webpack安装教程</title>
      <link>https://mannuan.github.io/post/20190610215453/</link>
      <pubDate>Mon, 10 Jun 2019 21:54:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610215453/</guid>
      <description>cnpm install -g webpack cnpm install -g webpack-cli cnpm install -g webpack-dev-server</description>
    </item>
    
    <item>
      <title>npm快速国内源</title>
      <link>https://mannuan.github.io/post/20190610215220/</link>
      <pubDate>Mon, 10 Jun 2019 21:52:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610215220/</guid>
      <description>淘宝镜像( cnpm ) - 淘宝NPM 镜像，用法和npm一模一样只是把npm改为cnpm</description>
    </item>
    
    <item>
      <title>linux不需要重装系统就可以调整分区</title>
      <link>https://mannuan.github.io/post/20190610204627/</link>
      <pubDate>Mon, 10 Jun 2019 20:46:27 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610204627/</guid>
      <description>介绍 Gparted是一个针对于linux分区调整的可视化工具。它是一个微型的linux操作系统封装了一些分区的命令，以一个iso格式的文件存在，选择gparted- live-*.iso这样的文件点击下载。
刻录 下载完成之后，你需要准备一个刻录工具（比如软碟通）和一个8G以上的U盘。这个刻录的教程，百度一下就有很多。
使用 刻录完成以后，你在开机</description>
    </item>
    
    <item>
      <title>六级听力-连读词组</title>
      <link>https://mannuan.github.io/post/20190610155006/</link>
      <pubDate>Mon, 10 Jun 2019 15:50:06 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610155006/</guid>
      <description>   词组 备注     this year 2017.12.第一套.长对话(1).第九句话   result in =resulting   One major 2017.12.第一套.长对话(1)    </description>
    </item>
    
    <item>
      <title>六级词汇—程度词</title>
      <link>https://mannuan.github.io/post/20190610125532/</link>
      <pubDate>Mon, 10 Jun 2019 12:55:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610125532/</guid>
      <description>   单词 备注     outreach         </description>
    </item>
    
    <item>
      <title>六级词汇—动作词</title>
      <link>https://mannuan.github.io/post/20190610125120/</link>
      <pubDate>Mon, 10 Jun 2019 12:51:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610125120/</guid>
      <description>   单词 备注     poke     </description>
    </item>
    
    <item>
      <title>六级词汇—消极词</title>
      <link>https://mannuan.github.io/post/20190610124839/</link>
      <pubDate>Mon, 10 Jun 2019 12:48:39 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190610124839/</guid>
      <description>   单词 备注     indignant 愤慨的   impose 强加    </description>
    </item>
    
    <item>
      <title>可以查前后缀和形近词的词典</title>
      <link>https://mannuan.github.io/post/20190609125337/</link>
      <pubDate>Sun, 09 Jun 2019 12:53:37 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190609125337/</guid>
      <description>柯林斯词典(collins)
海词词典</description>
    </item>
    
    <item>
      <title>六级词汇—反义词</title>
      <link>https://mannuan.github.io/post/20190609112917/</link>
      <pubDate>Sun, 09 Jun 2019 11:29:17 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190609112917/</guid>
      <description>   单词a 单词b     indignity dignity        </description>
    </item>
    
    <item>
      <title>六级词汇—前后缀</title>
      <link>https://mannuan.github.io/post/20190608220718/</link>
      <pubDate>Sat, 08 Jun 2019 22:07:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190608220718/</guid>
      <description>   公共部分 单词 备注     ability accountability, liability, availability Responsibility includes liability, blame, and accountability, that is a deep threat to the emotions. 责任包括赔偿责任，归咎、问责制，这是威胁到深有所感。   in incur, inflict,    de derail    re reclaim, retailer,    dis discrete(不), disclose,     </description>
    </item>
    
    <item>
      <title>六级词汇—集体名词</title>
      <link>https://mannuan.github.io/post/20190608215625/</link>
      <pubDate>Sat, 08 Jun 2019 21:56:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190608215625/</guid>
      <description>   单词 备注     offspring         </description>
    </item>
    
    <item>
      <title>六级词汇—单复数</title>
      <link>https://mannuan.github.io/post/20190608161250/</link>
      <pubDate>Sat, 08 Jun 2019 16:12:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190608161250/</guid>
      <description>   单数 复数     criterion criteria    </description>
    </item>
    
    <item>
      <title>六级词汇—衍生词</title>
      <link>https://mannuan.github.io/post/20190608112053/</link>
      <pubDate>Sat, 08 Jun 2019 11:20:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190608112053/</guid>
      <description>词汇 quantity, quota,</description>
    </item>
    
    <item>
      <title>六级词汇—僻义词</title>
      <link>https://mannuan.github.io/post/20190608105534/</link>
      <pubDate>Sat, 08 Jun 2019 10:55:34 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190608105534/</guid>
      <description>   单词 僻义     treatment 待遇   presence 风度   clearance 结关    </description>
    </item>
    
    <item>
      <title>六级词汇—词性对比</title>
      <link>https://mannuan.github.io/post/20190607211234/</link>
      <pubDate>Fri, 07 Jun 2019 21:12:34 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190607211234/</guid>
      <description>vt. vi. adj. adv. n. prep. 备注     ascertain         certain          certain,
certainty
| |
accustom | | custom | | custom | |
expend | | | | expenditure | |
| | analytical | | analysis | |
magnify | magnify | | | magnitude | |</description>
    </item>
    
    <item>
      <title>六级词汇—形近词</title>
      <link>https://mannuan.github.io/post/20190607205418/</link>
      <pubDate>Fri, 07 Jun 2019 20:54:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190607205418/</guid>
      <description>   词汇     populate, popular,   dread,dead,   loom,room，   foster,faster ,   skeptical,sceptical ,   rely,relay ,   revive,retrieve ,   shutter,shelter,    </description>
    </item>
    
    <item>
      <title>六级词汇—近义词</title>
      <link>https://mannuan.github.io/post/20190607204020/</link>
      <pubDate>Fri, 07 Jun 2019 20:40:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190607204020/</guid>
      <description>在区分近义词的时候，没有必要详细的记忆每个单词的具体含义，只要记住每个近义词之间的区别和共有的含义，就可以很轻松的使用。
    近义词 备注     inhabit,populate, reside,dwell 居住于
reside书面用词，指合法的永久性居住，也指在豪华的住宅里居住；
inhabit强调人或动物居住在某个地区并已适应某种特殊环境；
populate强调有人居住，population的动词形式；
dwell文学上的用词，口语中通常用live代替。   amplify,magnify 放大，
maglify可指用光学仪器使物体看上去显得变大；也指事实上把某物增大，有时用于夸张意味。
amplify: 在科技中常指声音的扩大或电磁波的增强。也指补充了细节、详述或扩大内容等。此词系正式用语   prevalent, popular popular指适应大众爱好、需要，为大家所公认或接受。   deteriorate,crumble    intricate,complex complex侧重内在关系的复杂，需通过仔细研究与了解才能掌握和运用。
intricate着重指错综复杂，令人迷惑理解。   plea,appeal 请求   extinct,dead 无生命   additive,cumulative 附加的   female,feminine 女性的
female侧重于性别雌性；
feminine侧重于阴性   skeptical,suspicious 怀疑的
skeptical强调观点；
suspicious强调状态或外在的表现形式   timid,shy 害羞的
timid强调胆子小;   comply,obey comply指答应某人已经提出或可能要求做的某事，与with连用。   collide,conflict 冲突</description>
    </item>
    
    <item>
      <title>wkhtmltopdf：一个 Linux 中将网页转成 PDF 的智能工具</title>
      <link>https://mannuan.github.io/post/20190607174103/</link>
      <pubDate>Fri, 07 Jun 2019 17:41:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190607174103/</guid>
      <description>用法： wkhtmltopdf http://google.com google.pdf 下载（deb）： wkhtmlpdf
开源代码代码： wkhtmlpdf.git</description>
    </item>
    
    <item>
      <title>App can&#39;t be opened because it is from an unidentified developer</title>
      <link>https://mannuan.github.io/post/20190606141846/</link>
      <pubDate>Thu, 06 Jun 2019 14:18:46 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190606141846/</guid>
      <description></description>
    </item>
    
    <item>
      <title>html中文字体压缩工具</title>
      <link>https://mannuan.github.io/post/20190605214837/</link>
      <pubDate>Wed, 05 Jun 2019 21:48:37 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605214837/</guid>
      <description>字蛛是一个中文字体压缩器，让网页自由引入中文字体成为可能。</description>
    </item>
    
    <item>
      <title>反爬机制之字体反爬详解</title>
      <link>https://mannuan.github.io/post/20190605214530/</link>
      <pubDate>Wed, 05 Jun 2019 21:45:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605214530/</guid>
      <description>字体反爬，顾名思义就是利用自定义的字符编码与字体文件的映射呈现文字的一种反爬措施。下面我们通过例子来详细介绍字体反爬是怎么实现的以及解决方案。
 目录
字符编码
CSS3 @font-face 规则
html文件（example.html）:
woff字体文件（example.woff）:
html显示效果：
解决方案：
字符编码 字体爬虫就是使用类似自定义的字符编码的形式来呈现文字，字符编码的详细信息见HTML字符编码；
CSS3 @font-face 规则 在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。
通过 CSS3，web 设计师可以使用他们喜欢的任意字体。
当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。
您“自己的”的字体是在 CSS3 @font-face 规则中定义的。
html文件（example.html）: &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34;/&amp;gt; &amp;lt;title&amp;gt;example&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; @font-face{ font-family: &amp;#34;example&amp;#34;; src:url(&amp;#34;./example.woff&amp;#34;) format(&amp;#39;woff&amp;#39;); } .review { font-family: &amp;#34;example&amp;#34;; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt; 找了好久才 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe54b;&amp;lt;/svgmsti&amp;gt;到，问了 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe36d;&amp;lt;/svgmsti&amp;gt; &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xebb5;&amp;lt;/svgmsti&amp;gt;他 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xf3c6;&amp;lt;/svgmsti&amp;gt;己也不知 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xef46;&amp;lt;/svgmsti&amp;gt;看了点评 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xf75f;&amp;lt;/svgmsti&amp;gt; &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe8dd;&amp;lt;/svgmsti&amp;gt;电话才知 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xef46;&amp;lt;/svgmsti&amp;gt;，人挺多的上菜 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xee1a;&amp;lt;/svgmsti&amp;gt;慢 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe8dd;&amp;lt;/svgmsti&amp;gt;，凉菜都吃完 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe5bd;&amp;lt;/svgmsti&amp;gt;别的 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xeb5a;&amp;lt;/svgmsti&amp;gt;还没 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xf40e;&amp;lt;/svgmsti&amp;gt;来，凉 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xeb5a;&amp;lt;/svgmsti&amp;gt;很 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xe082;&amp;lt;/svgmsti&amp;gt;胃 &amp;lt;svgmsti class=&amp;#34;review&amp;#34;&amp;gt;&amp;amp;#xee1a;&amp;lt;/svgmsti&amp;gt;好吃的。 &amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; woff字体文件（example.</description>
    </item>
    
    <item>
      <title>HTML特殊字符编码对照表</title>
      <link>https://mannuan.github.io/post/20190605212304/</link>
      <pubDate>Wed, 05 Jun 2019 21:23:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605212304/</guid>
      <description> &amp;amp;开头的表示命名实体；&amp;amp;#开头的表示十进制的字符编码；&amp;amp;#x开头的表示十六进制的字符编码；
    特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码     Α &amp;amp;Alpha; &amp;amp;#913; Β &amp;amp;Beta; &amp;amp;#914; Γ &amp;amp;Gamma; &amp;amp;#915;   Δ &amp;amp;Delta; &amp;amp;#916; Ε &amp;amp;Epsilon; &amp;amp;#917; Ζ &amp;amp;Zeta; &amp;amp;#918;   Η &amp;amp;Eta; &amp;amp;#919; Θ &amp;amp;Theta; &amp;amp;#920; Ι &amp;amp;Iota; &amp;amp;#921;   Κ &amp;amp;Kappa; &amp;amp;#922; Λ &amp;amp;Lambda; &amp;amp;#923; Μ &amp;amp;Mu; &amp;amp;#924;   Ν &amp;amp;Nu; &amp;amp;#925; Ξ &amp;amp;Xi; &amp;amp;#926; Ο &amp;amp;Omicron; &amp;amp;#927;   Π &amp;amp;Pi; &amp;amp;#928; Ρ &amp;amp;Rho; &amp;amp;#929; Σ &amp;amp;Sigma; &amp;amp;#931;   Τ &amp;amp;Tau; &amp;amp;#932; Υ &amp;amp;Upsilon; &amp;amp;#933; Φ &amp;amp;Phi; &amp;amp;#934;   Χ &amp;amp;Chi; &amp;amp;#935; Ψ &amp;amp;Psi; &amp;amp;#936; Ω &amp;amp;Omega; &amp;amp;#937;   α &amp;amp;alpha; &amp;amp;#945; β &amp;amp;beta; &amp;amp;#946; γ &amp;amp;gamma; &amp;amp;#947;   δ &amp;amp;delta; &amp;amp;#948; ε &amp;amp;epsilon; &amp;amp;#949; ζ &amp;amp;zeta; &amp;amp;#950;   η &amp;amp;eta; &amp;amp;#951; θ &amp;amp;theta; &amp;amp;#952; ι &amp;amp;iota; &amp;amp;#953;   κ &amp;amp;kappa; &amp;amp;#954; λ &amp;amp;lambda; &amp;amp;#955; μ &amp;amp;mu; &amp;amp;#956;   ν &amp;amp;nu; &amp;amp;#957; ξ &amp;amp;xi; &amp;amp;#958; ο &amp;amp;omicron; &amp;amp;#959;   π &amp;amp;pi; &amp;amp;#960; ρ &amp;amp;rho; &amp;amp;#961; ς &amp;amp;sigmaf; &amp;amp;#962;   σ &amp;amp;sigma; &amp;amp;#963; τ &amp;amp;tau; &amp;amp;#964; υ &amp;amp;upsilon; &amp;amp;#965;   φ &amp;amp;phi; &amp;amp;#966; χ &amp;amp;chi; &amp;amp;#967; ψ &amp;amp;psi; &amp;amp;#968;   ω &amp;amp;omega; &amp;amp;#969; ϑ &amp;amp;thetasym; &amp;amp;#977; ϒ &amp;amp;upsih; &amp;amp;#978;   ϖ &amp;amp;piv; &amp;amp;#982; • &amp;amp;bull; &amp;amp;#8226; … &amp;amp;hellip; &amp;amp;#8230;   ′ &amp;amp;prime; &amp;amp;#8242; ″ &amp;amp;Prime; &amp;amp;#8243; ‾ &amp;amp;oline; &amp;amp;#8254;   ⁄ &amp;amp;frasl; &amp;amp;#8260; ℘ &amp;amp;weierp; &amp;amp;#8472; ℑ &amp;amp;image; &amp;amp;#8465;   ℜ &amp;amp;real; &amp;amp;#8476; ™ &amp;amp;trade; &amp;amp;#8482; ℵ &amp;amp;alefsym; &amp;amp;#8501;   ← &amp;amp;larr; &amp;amp;#8592; ↑ &amp;amp;uarr; &amp;amp;#8593; → &amp;amp;rarr; &amp;amp;#8594;   ↓ &amp;amp;darr; &amp;amp;#8595; ↔ &amp;amp;harr; &amp;amp;#8596; ↵ &amp;amp;crarr; &amp;amp;#8629;   ⇐ &amp;amp;lArr; &amp;amp;#8656; ⇑ &amp;amp;uArr; &amp;amp;#8657; ⇒ &amp;amp;rArr; &amp;amp;#8658;   ⇓ &amp;amp;dArr; &amp;amp;#8659; ⇔ &amp;amp;hArr; &amp;amp;#8660; ∀ &amp;amp;forall; &amp;amp;#8704;   ∂ &amp;amp;part; &amp;amp;#8706; ∃ &amp;amp;exist; &amp;amp;#8707; ∅ &amp;amp;empty; &amp;amp;#8709;   ∇ &amp;amp;nabla; &amp;amp;#8711; ∈ &amp;amp;isin; &amp;amp;#8712; ∉ &amp;amp;notin; &amp;amp;#8713;   ∋ &amp;amp;ni; &amp;amp;#8715; ∏ &amp;amp;prod; &amp;amp;#8719; ∑ &amp;amp;sum; &amp;amp;#8722;   − &amp;amp;minus; &amp;amp;#8722; ∗ &amp;amp;lowast; &amp;amp;#8727; √ &amp;amp;radic; &amp;amp;#8730;   ∝ &amp;amp;prop; &amp;amp;#8733; ∞ &amp;amp;infin; &amp;amp;#8734; ∠ &amp;amp;ang; &amp;amp;#8736;   ∧ &amp;amp;and; &amp;amp;#8869; ∨ &amp;amp;or; &amp;amp;#8870; ∩ &amp;amp;cap; &amp;amp;#8745;   ∪ &amp;amp;cup; &amp;amp;#8746; ∫ &amp;amp;int; &amp;amp;#8747; ∴ &amp;amp;there4; &amp;amp;#8756;   ∼ &amp;amp;sim; &amp;amp;#8764; ≅ &amp;amp;cong; &amp;amp;#8773; ≈ &amp;amp;asymp; &amp;amp;#8773;   ≠ &amp;amp;ne; &amp;amp;#8800; ≡ &amp;amp;equiv; &amp;amp;#8801; ≤ &amp;amp;le; &amp;amp;#8804;   ≥ &amp;amp;ge; &amp;amp;#8805; ⊂ &amp;amp;sub; &amp;amp;#8834; ⊃ &amp;amp;sup; &amp;amp;#8835;   ⊄ &amp;amp;nsub; &amp;amp;#8836; ⊆ &amp;amp;sube; &amp;amp;#8838; ⊇ &amp;amp;supe; &amp;amp;#8839;   ⊕ &amp;amp;oplus; &amp;amp;#8853; ⊗ &amp;amp;otimes; &amp;amp;#8855; ⊥ &amp;amp;perp; &amp;amp;#8869;   ⋅ &amp;amp;sdot; &amp;amp;#8901; ⌈ &amp;amp;lceil; &amp;amp;#8968; ⌉ &amp;amp;rceil; &amp;amp;#8969;   ⌊ &amp;amp;lfloor; &amp;amp;#8970; ⌋ &amp;amp;rfloor; &amp;amp;#8971; ◊ &amp;amp;loz; &amp;amp;#9674;   ♠ &amp;amp;spades; &amp;amp;#9824; ♣ &amp;amp;clubs; &amp;amp;#9827; ♥ &amp;amp;hearts; &amp;amp;#9829;   ♦ &amp;amp;diams; &amp;amp;#9830;  &amp;amp;nbsp; &amp;amp;#160; ¡ &amp;amp;iexcl; &amp;amp;#161;   ¢ &amp;amp;cent; &amp;amp;#162; £ &amp;amp;pound; &amp;amp;#163; ¤ &amp;amp;curren; &amp;amp;#164;   ¥ &amp;amp;yen; &amp;amp;#165; ¦ &amp;amp;brvbar; &amp;amp;#166; § &amp;amp;sect; &amp;amp;#167;   ¨ &amp;amp;uml; &amp;amp;#168; © &amp;amp;copy; &amp;amp;#169; ª &amp;amp;ordf; &amp;amp;#170;   « &amp;amp;laquo; &amp;amp;#171; ¬ &amp;amp;not; &amp;amp;#172; ­ &amp;amp;shy; &amp;amp;#173;   ® &amp;amp;reg; &amp;amp;#174; ¯ &amp;amp;macr; &amp;amp;#175; ° &amp;amp;deg; &amp;amp;#176;   ± &amp;amp;plusmn; &amp;amp;#177; ² &amp;amp;sup2; &amp;amp;#178; ³ &amp;amp;sup3; &amp;amp;#179;   ´ &amp;amp;acute; &amp;amp;#180; µ &amp;amp;micro; &amp;amp;#181; &amp;ldquo; &amp;amp;quot; &amp;amp;#34;   &amp;lt; &amp;amp;lt; &amp;amp;#60; &amp;gt; &amp;amp;gt; &amp;amp;#62; &amp;lsquo;  &amp;amp;#39;    </description>
    </item>
    
    <item>
      <title>大众点评评论反爬解决方案</title>
      <link>https://mannuan.github.io/post/20190605165530/</link>
      <pubDate>Wed, 05 Jun 2019 16:55:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605165530/</guid>
      <description>  目前大众点评主要有两种反爬的机制：css反爬和字体反爬。
 css反爬的解决方案 具体详见反爬机制之css反爬详解
字体反爬的解决方案 </description>
    </item>
    
    <item>
      <title>反爬机制之css反爬详解</title>
      <link>https://mannuan.github.io/post/20190605165242/</link>
      <pubDate>Wed, 05 Jun 2019 16:52:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605165242/</guid>
      <description>css反爬，顾名思义就是利用css样式移动背景图片达到呈现文字效果的一种反爬措施。下面我们通过例子来详细介绍css反爬是怎么实现的以及解决方法。
 目录
html代码（example.html）:
css文件（example.css）：
svg文件（example.svg）：
html显示效果：
规律总结：
解决方案实现代码（python）：
最终效果：
html代码（example.html）: &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;example&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34;/&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;./example.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt; 之前 &amp;lt;svgmsti class=&amp;#34;cmpubq&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;杭州，回 &amp;lt;svgmsti class=&amp;#34;cmpmdy&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;海前选择 &amp;lt;svgmsti class=&amp;#34;cmpcj2&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt; &amp;lt;svgmsti class=&amp;#34;cmpfaa&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;这里吃一顿，原 &amp;lt;svgmsti class=&amp;#34;cmpu0e&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt; &amp;lt;svgmsti class=&amp;#34;cmpug6&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;想吃 &amp;lt;svgmsti class=&amp;#34;cmpu6y&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt; &amp;lt;svgmsti class=&amp;#34;cmppiv&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;家 &amp;lt;svgmsti class=&amp;#34;cmp3wu&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;，无意间发现 &amp;lt;svgmsti class=&amp;#34;cmpcj2&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;这家 &amp;lt;svgmsti class=&amp;#34;cmpj8o&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;，所以决 &amp;lt;svgmsti class=&amp;#34;cmpq7h&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;要 &amp;lt;svgmsti class=&amp;#34;cmpfaa&amp;#34;&amp;gt;&amp;lt;/svgmsti&amp;gt;打卡！ &amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; css文件（example.css）： svgmsti[class^=&amp;#34;cmp&amp;#34;]{ width: 14px; height: 30px; margin-top: -9px; background-image: url(./example.svg); background-repeat: no-repeat; display: inline-block; vertical-align: middle; } .</description>
    </item>
    
    <item>
      <title>python with 打开多个文件</title>
      <link>https://mannuan.github.io/post/20190605154442/</link>
      <pubDate>Wed, 05 Jun 2019 15:44:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605154442/</guid>
      <description>with open(&amp;#34;./example.html&amp;#34;, &amp;#34;r&amp;#34;) as f1, open(&amp;#34;./example.css&amp;#34;, &amp;#34;r&amp;#34;) as f2, open(&amp;#34;./example.svg&amp;#34;, &amp;#34;r&amp;#34;) as f3: html = f1.read() css = f2.read() svg = f3.</description>
    </item>
    
    <item>
      <title>pyquery获取文本节点（TextNode）</title>
      <link>https://mannuan.github.io/post/20190605114530/</link>
      <pubDate>Wed, 05 Jun 2019 11:45:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605114530/</guid>
      <description>from pyquery import PyQuery as pq p = pq(字符串) for i in p.contents(): print(i)</description>
    </item>
    
    <item>
      <title>html解决中文乱码</title>
      <link>https://mannuan.github.io/post/20190605101458/</link>
      <pubDate>Wed, 05 Jun 2019 10:14:58 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190605101458/</guid>
      <description>&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;/&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</description>
    </item>
    
    <item>
      <title>pyquery如何读取xml或html文件不乱码</title>
      <link>https://mannuan.github.io/post/20190604142642/</link>
      <pubDate>Tue, 04 Jun 2019 14:26:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190604142642/</guid>
      <description># -*- coding: utf-8 -*- from pyquery import PyQuery as pq with open(&amp;#39;文件路径&amp;#39;, &amp;#34;r&amp;#34;) as f: str = f.read().encode(&amp;#34;utf-8&amp;#34;) #设置&amp;#34;utf-8&amp;#34;编码，这一步很重要 p = pq(str)</description>
    </item>
    
    <item>
      <title>pyquery如何解析xml</title>
      <link>https://mannuan.github.io/post/20190604140727/</link>
      <pubDate>Tue, 04 Jun 2019 14:07:27 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190604140727/</guid>
      <description>之前遇到pyquery解析svg文件(xml格式)的时候发现无法获取节点，比如下面这个svg文件：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; standalone=&amp;#34;no&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE svg PUBLIC &amp;#34;-//W3C//DTD SVG 1.1//EN&amp;#34; &amp;#34;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&amp;#34;&amp;gt; &amp;lt;svg xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; version=&amp;#34;1.1&amp;#34; xmlns:xlink=&amp;#34;http://www.w3.org/1999/xlink&amp;#34; width=&amp;#34;650px&amp;#34; height=&amp;#34;3030.0px&amp;#34;&amp;gt; &amp;lt;style&amp;gt;text {font-family:PingFangSC-Regular,Microsoft YaHei,&amp;#39;Hiragino Sans GB&amp;#39;,Helvetica;font-size:14px;fill:#282828;}&amp;lt;/style&amp;gt; &amp;lt;text x=&amp;#34;0&amp;#34; y=&amp;#34;35&amp;#34;&amp;gt;呜愉伸治译喊傲著逢循托从巨毒高翼阻聋巴垂级茧郎暑聚渣啦秘炊奋睁连撤宁畅搁刚轮蜂缺幕葵&amp;lt;/text&amp;gt; &amp;lt;text x=&amp;#34;0&amp;#34; y=&amp;#34;79&amp;#34;&amp;gt;搞陆林卵窝提格桑南隔选膛奸修担穴罐胖宅圆馒杏至鲁类痒宝拌让必油匀困双拢砖轧凑辜亦银牧&amp;lt;/text&amp;gt; &amp;lt;/svg&amp;gt; 我在用下面的python代码提取text节点的时候，发现无法提取，没有任何输出：
from pyquery import PyQuery as pq with open(文件路径, &amp;#34;r&amp;#34;) as f: svg = f.read().encode(&amp;#34;utf-8&amp;#34;) p = pq(svg) for i in p(&amp;#34;text&amp;#34;).items(): print(i) 之后，我把pyquery的解析方式，强制设置为 paser=&amp;quot;html&amp;quot; 后，就行了：
from pyquery import PyQuery as pq with open(文件路径, &amp;#34;r&amp;#34;) as f: svg = f.read().encode(&amp;#34;utf-8&amp;#34;) p = pq(svg, parser=&amp;#34;html&amp;#34;) for i in p(&amp;#34;text&amp;#34;).</description>
    </item>
    
    <item>
      <title>冒泡排序、选择排序和插入排序的比较</title>
      <link>https://mannuan.github.io/post/20190603215721/</link>
      <pubDate>Mon, 03 Jun 2019 21:57:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190603215721/</guid>
      <description> 冒泡排序 算法流程 假设存在一个长度为N的数组，按照从左至右的顺序升序排列。首先，通过N-1次数
javascript代码 function bubbleSort(){ var arr = arguments[0]; for(var end=arr.length-1; end&amp;gt;0; end--){ for(var i=0; i&amp;lt;end; i++){ if(arr[i] &amp;gt; arr[end]){ var tmp = arr[i]; arr[i] = arr[end]; arr[end] = tmp; } } } } function randomNum(max=100, start=33){ return Math.floor(Math.random() * max + start); } var arr = []; var length = randomNum(30, 1); for(var i=0; i&amp;lt;length; i++){ // 创建随机数组  arr.push(randomNum()); } console.log(arr); bubbleSort(arr); console.log(arr);  选择排序 </description>
    </item>
    
    <item>
      <title>markdown常用语法大全</title>
      <link>https://mannuan.github.io/post/20190603143536/</link>
      <pubDate>Mon, 03 Jun 2019 14:35:36 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190603143536/</guid>
      <description>标记 作用 备注     文字 字体加粗    连续两个空格 换行    连续两个回车 或 在空行处输出连续两个&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; 空行    &amp;amp;nbsp; 它叫不换行空格，全称是 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了&amp;amp;nbsp;，它是按下space键产生的空格。 在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。   &amp;amp;ensp; 它叫“半角空格”，全称是 En Space ，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。 此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。   &amp;amp;emsp; 它叫“全角空格”，全称是 Em Space ，em是字体排印学的计量单位，相当于当前指定的点数。例如，1em在16px的字体中就是16px。 此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。   &amp;amp;thinsp; 它叫“窄空格”，全称是 Thin Space    。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。     &amp;amp;zwnj; 它叫零宽不连字，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。 Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为：“‌”   !</description>
    </item>
    
    <item>
      <title>numpy softmax实现</title>
      <link>https://mannuan.github.io/post/20190602184249/</link>
      <pubDate>Sun, 02 Jun 2019 18:42:49 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190602184249/</guid>
      <description># -*- coding: utf-8 -*- import numpy as np def softmax(x): x_row_max = x.max(axis=-1) x_row_max = x_row_max.reshape(list(x.shape)[:-1]+[1]) x = x - x_row_max x_exp = np.exp(x) x_exp_row_sum = x_exp.sum(axis=-1).reshape(list(x.shape)[:-1]+[1]) softmax = x_exp / x_exp_row_sum return softmax if __name__ == &amp;#34;__main__&amp;#34;: m = np.random.randn(2, 2, 2) + 2 m = softmax(m) m = m.</description>
    </item>
    
    <item>
      <title>准确率、精准率、召回率和F1值详解</title>
      <link>https://mannuan.github.io/post/20190602173707/</link>
      <pubDate>Sun, 02 Jun 2019 17:37:07 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190602173707/</guid>
      <description>专业术语的中英文对照表 英文名     准确率 Accuracy   精准率 Precise   召回率 Recall   F1值 F1 measure    Precise和Recall是广泛应用在信息检索和统计学分类领域的两个度量值，用来评价结果的质量；F1 measure是综合Precise和Recall两个指标的评估指标，用于综合反映整体的指标。Precise、Recall和F1 measure都是通过混淆矩阵计算出来的，下表是对混淆矩阵的介绍：
混淆矩阵 &amp;nbsp; 预测的类别 &amp;nbsp; 实际的类别 &amp;nbsp; Positive Negative 合计 Positive TP FN 正样本 Negative FP TN 负样本 &amp;nbsp; 合计 样本被预测为Positive 样本被预测为Negative Positive+Negative   其中： TP表示正确地把正样本预测为正； FN表示错误地把正样本预测为负； FP表示错误地把负样本预测为正； TN表示正确地把负样本预测为负；
 Precise 表示正确预测正样本占实际预测为正样本的比例
$$Precise = \frac{TP}{TP+FP}$$
Recall 表示正确预测正样本占正样本的比例
$$Recall = \frac{TP}{TP+FN}$$</description>
    </item>
    
    <item>
      <title>linux实现内网穿透</title>
      <link>https://mannuan.github.io/post/20190602141130/</link>
      <pubDate>Sun, 02 Jun 2019 14:11:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190602141130/</guid>
      <description>穿透工具：frps
进程管理工具：supervisor</description>
    </item>
    
    <item>
      <title>linux常用命令</title>
      <link>https://mannuan.github.io/post/20190602135144/</link>
      <pubDate>Sun, 02 Jun 2019 13:51:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190602135144/</guid>
      <description> nohup 结合后台运行命令&amp;amp;使用 nohup command &amp;gt;&amp;gt; log_path 2&amp;gt;&amp;amp;1 &amp;amp; lsof 查看端口运行的程序 lsof -i :port find 查找文件(以nginx为例) sudo find / -name nginx* tar 打包文件 tar -cvf 文件名.tar 要打包的目录</description>
    </item>
    
    <item>
      <title>JavaScript-事件对象</title>
      <link>https://mannuan.github.io/post/20190601142818/</link>
      <pubDate>Sat, 01 Jun 2019 14:28:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190601142818/</guid>
      <description>触发某个事件时会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。
 事件的元素 事件的类型 其它与事件相关的信息  所有浏览器都支持event对象，但存在差异。
event对象在标准的现代浏览器中会作为参数传入到事件的事件处理函数。
DOM中的事件对象 属性/方法 类型 读写 说明 bubbles Boolean 只读 表明事件是否支持冒泡 cancelable Boolean 只读 表明是否可以取消默认行为 currentTarget Element 只读 表明事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为true表示已经调用了下面的preventDefault() detail Int 只读 与事件相关的细节信息 eventPhase Int 只读 触发事件处理程序的阶段：1表示捕获，2表示处于目标，3表示冒泡 preventDefault() Function —— 取消事件的默认行为，前提条件是cancelable属性为true stopImmediatePropagation() Function —— 取消事件的进一步捕获或冒泡，同时阻止任何（其他的）事件处理程序被调用 stopPropagation() Function —— 立即停止事件在DOM中的传播，取消进一步的时间捕获或冒泡，前提条件是：bubbles属性为true target Element 只读 事件的目标元素 trusted Boolean 只读 为true表示是浏览器生成的，为false表示是开发人员自定义的事件 type String 只读 被触发的事件类型 view AbstractView 只读 与事件相关的抽象视图，等于发生事件的window对象   在HTML事件处理程序时：变量event（固定）中保存着event对象，无需主动声明，也无需以参数形式传入：
 在DOM 0 级和DOM 2 级事件处理程序中，event对象会 以参数的形式传入事件处理函数 中；</description>
    </item>
    
    <item>
      <title>JavaScript客户端检测</title>
      <link>https://mannuan.github.io/post/20190601105750/</link>
      <pubDate>Sat, 01 Jun 2019 10:57:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190601105750/</guid>
      <description>应对各个厂商、各个版本的浏览器对特性支持度的差异，常采取的策略
 ”最小公分母“策略 客户端检测技术，突破和规避种种局限  不到万不得已不要使用客户端检测；先设计最通用的方案，然后使用特定于浏览器的技术增强该方案。
常用的客户端检测技术包括：
能力检测  最常用最方便，只关注能力，不关注浏览器品牌和版本； 两个原则  先检测达成目的的最常用特性，避免测试多个条件
必须测试实际用到的特性，一个特性存在不一定代表另一个特性也存在
 在可能的情况下，尽量使用typeof进行能力检测； 低版本IE下或其他非标准浏览器下，使用typeof检测的值不一定符合标准；  低版本IE的DOM以COM的形式实现，很容易出现typeof检测结果不标准的情况
 通过检测对象是否有某些原生属性时，要注意我们的代码是否定义了与要检测到的原生属性同名的属性，确保检测的目标是正确的； 一般通用方法：isHostMethod函数  function isHostMethod(object, property){ var t = typeof object[property]; return t == &amp;#39;function&amp;#39; || (!!(t == &amp;#39;object&amp;#39; &amp;amp;&amp;amp; object[property])) || t == &amp;#39;unknown&amp;#39;; } result = isHostMethod(document, &amp;#39;getElementById&amp;#39;);   根据浏览器不同将能力组合起来是更可取的方法； 如果你预先知道自己的程序需要使用某些特定的浏览器特性，那么最好一次性检测所有相关特性。  怪癖检测  目的是识别浏览器的特殊行为，与能级检测的检测能力刚好相反；
 怪癖是个别浏览器独有的，通常归类为bug；
 实例：IE8及更早版本中，如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么属性无法被for-in循环遍历
  // 怪癖检测 var hasDontEnumQuirk = function(){ var o = {toString: function(){}}; for(var prop in o){ if(prop == &amp;#39;toString&amp;#39;){ return false; } } return true; }(); hasDontEnumQuirk;// false 说明浏览器没有这个怪癖  用户代理检测  通过检测用户代理字符串来确定实际使用的浏览器； 通常是在最后才选择这样的方法，或者想实现某些特定的功能才使用用户代理检测； 主要使用navigator.</description>
    </item>
    
    <item>
      <title>javascript 事件处理程序</title>
      <link>https://mannuan.github.io/post/20190531215629/</link>
      <pubDate>Fri, 31 May 2019 21:56:29 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531215629/</guid>
      <description>响应某个事件的函数叫做 事件处理程序 （或 事件侦听器 ），例如：click 事件的处理程序就是 onclick
 HTML事件处理程序  某个元素支持的所有事件都可以使用一个与相应事件处理程序同名的HTML特性来指定；  &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;click me&amp;#34; onclick=&amp;#34;alert(&amp;#39;Clicked&amp;#39;)&amp;#34; /&amp;gt;  在这个特性里，不能使用未经转义的HTML语法字符：和号（&amp;amp;）、双引号（&amp;rdquo;&amp;ldquo;）、小于号（&amp;lt;）或大于号（&amp;gt;）；  &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;click me&amp;#34; onclick=&amp;#34;alert(&amp;amp;quot;Clicked&amp;amp;quot;)&amp;#34; /&amp;gt;  特性值也可以是调用页面中其他地方定义的脚本， HTML事件处理程序在执行时 有权访问全局作用域中的任何代码 ；  &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;click me&amp;#34; onclick=&amp;#34;showMessage()&amp;#34; /&amp;gt;  HTML事件处理程序内部可以 通过 event 变量直接访问事件对象 ，无需自己定义，也不用从函数的参数列表读取；
 HTML事件处理程序中的this等于事件的目标元素；
  &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;click me&amp;#34; onclick=&amp;#34;alert(this.value)&amp;#34; /&amp;gt;  HTML事件处理程序有着独特的扩展作用域：处理函数内部可以直接访问元素本身、document元素，类似使用with(this)、with(document)进行扩展一样；  &amp;lt;form method=&amp;#34;post&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; value=&amp;#34;&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; onclick=&amp;#34;alert(username.value)&amp;#34;&amp;gt; &amp;lt;/form&amp;gt;  删除HTML事件处理程序的方法：设置事件处理程序对应的HTML特性值为null；</description>
    </item>
    
    <item>
      <title>javascript 事件流</title>
      <link>https://mannuan.github.io/post/20190531210541/</link>
      <pubDate>Fri, 31 May 2019 21:05:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531210541/</guid>
      <description> 事件流 描述的是从页面中 接收事件的顺序 。
对待事件流的问题上，IE和Netscape提出了完全相反的两个概念：IE的事件流是 冒泡流 ，而Netscape的事件流是 捕获流。
事件冒泡  IE的 事件流类型；现已被所有现代浏览器支持； 时间开始时由最具体的元素——文档中嵌套层次最具体的元素（可理解为最小的同心圆）接收，然后事件沿DOM树向上传播到document对象； 所有的现代浏览器都支持冒泡，各浏览器之间的差异  IE8- 事件冒泡到document即停止；
其他现代浏览器支持一直冒泡到window对象；
事件捕获  Netscape浏览器的事件流机制； 事件开始时由不具体的节点——文档中嵌套层次最上级的元素（可理解为最大的同心圆）最早接收，然后事件沿着DOM树向下传播，直到传播到最具体的节点； 现代浏览器都支持 事件捕获 模型； DOM2级 事件规范要求：从document对象开始传播；但一般的现代浏览器都从window对象开始捕获。  DOM事件流  ”DOM 2级事件“规定的事件包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段； 实例：document&amp;gt;html&amp;gt;body&amp;gt;div  在DOM事件流中，实际的目标(div)在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到html再到body后就会停止。下一个阶段就是处于&amp;rdquo;处于目标&amp;rdquo;阶段，于是事件在div上发生，并 在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播到文档。
 ”DOM2级事件“规定：捕获阶段不涉及事件目标；但一般的现代浏览器都会在捕获阶段触发事件对象上的事件；导致的结果就是：有两个机会（捕获、冒泡）在目标对象上面操作事件； IE8- 不支持DOM事件流。  </description>
    </item>
    
    <item>
      <title>JavaScript 事件</title>
      <link>https://mannuan.github.io/post/20190531204033/</link>
      <pubDate>Fri, 31 May 2019 20:40:33 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531204033/</guid>
      <description>JavaScript与HTML之间的交互是通过事件实现的。
事件 ：文档或浏览器窗口中发生的一些交互瞬间；可以使用 侦听器 （或处理程序） 预订 事件，以便事件发生时执行相应的代码。
这种 侦听事件——执行操作 的模式在传统软件过程中叫做 观察者模式 。
DOM2级规范开始规范标准化DOM事件，IE8是最后一个仍然使用其专有事件系统的浏览器。
除了DOM事件，还有BOM事件，HTML5致力于规范BOM事件。
所有事件：</description>
    </item>
    
    <item>
      <title>DOM专有扩展</title>
      <link>https://mannuan.github.io/post/20190531153512/</link>
      <pubDate>Fri, 31 May 2019 15:35:12 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531153512/</guid>
      <description>插入文本： innerText, outerText
innerText  读取元素中包含的所有文本内容，只读取文本内容； 写入时会删除元素的所有节点，插入文本内容； 不同浏览器处理空白和换行的方式不一样； firefox不支持innerText，但支持textContent属性；   textContent与innerText的不同点在于：innerText会忽略行内的样式和脚本，textContent不会；
最佳实践 ：从不包含行内样式和行内脚本的DOM中读取文本
  使用innerText可以过滤标签，快捷地获得纯文本。  function getInnerText(element){ return (typeof element.textContent == &amp;#39;string&amp;#39;) ? element.textContent : element.innerText; } function setInnerText(element, text){ if(typeof element.textContent == &amp;#39;string&amp;#39;){ elemnt.textContent = text; }else{ element.innerText = text; } }  滚动相关  scrollIntoView()：对元素调用此方法可以使页面滚动到与元素顶部平齐； scrollIntoViewIfNeeded(alignCenter)：调用方法的元素不可见的情况下运行，接受一个参数：是否垂直居中，布尔值； scrollByLines(lineCount)：将元素内容滚动到指定的行高； scrollByPages(pageCount)：将元素内容滚动至指定的页面高度；  以上三个方法支持性都不是很好！</description>
    </item>
    
    <item>
      <title>HTML5之插入标记innerHTML</title>
      <link>https://mannuan.github.io/post/20190531113301/</link>
      <pubDate>Fri, 31 May 2019 11:33:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531113301/</guid>
      <description>处于安全等方面的考虑：
 通过innerHTML直接插入&amp;lt;script&amp;gt;元素在大多数浏览器中并不会执行其中的脚本； 通过innerHTML直接插入&amp;lt;style&amp;gt;在一些浏览器中无效。   在这些浏览器中，这两个元素被认为是”无作用域的元素“（不会在页面上显示的元素），如果通过innerHTML插入的字符串开头就是”无作用域的元素“，那么这些浏览器就会解决这个字符串前先删除该元素。解决的方法：在这些”无作用域的元素“前临时增加一个有作用域的元素，之后再将临时元素删除，同时为脚本元素设置defer特性。
  部分元素不支持innerHTML; 冷知识：firefox浏览器在XHTML文档中设置innerHTML是要求XHTML必须严格符合要求，否则，innerHTML将会静默地失败； 最佳实践：使用innerHTML插入代码片时，请通过特定的方法过滤掉script标签（可能引入恶意脚本）。  </description>
    </item>
    
    <item>
      <title>Javascript焦点管理—document.hasFocus()</title>
      <link>https://mannuan.github.io/post/20190531104239/</link>
      <pubDate>Fri, 31 May 2019 10:42:39 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531104239/</guid>
      <description> 该方法用于确定文档是否获得焦点； 可以通过检测文档是否获得焦点得知用户是否正在与页面交互。  </description>
    </item>
    
    <item>
      <title>Javascript焦点管理-document.activeElement</title>
      <link>https://mannuan.github.io/post/20190531103901/</link>
      <pubDate>Fri, 31 May 2019 10:39:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531103901/</guid>
      <description> document.activeElement指向页面中当前获得焦点的元素； 元素获得焦点的方式； 文档刚加载完，document.activeElement指向document.body； 文档加载期间，document.activeElement指向null。  </description>
    </item>
    
    <item>
      <title>元素获得焦点的方式</title>
      <link>https://mannuan.github.io/post/20190531103310/</link>
      <pubDate>Fri, 31 May 2019 10:33:10 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531103310/</guid>
      <description> 页面加载 Tab切换 元素的focus()方法  </description>
    </item>
    
    <item>
      <title>orcle jdk linux 安装教程</title>
      <link>https://mannuan.github.io/post/20190531102524/</link>
      <pubDate>Fri, 31 May 2019 10:25:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190531102524/</guid>
      <description> 将*.tar.gz解压（以jdk8.144为例）：
tar -xzvf jdk-8u144-linux-x64.tar.gz  得到的文件夹为jdk1.8.0_144，将其移动到/usr/lib/jvm中： bash sudo mv jdk1.8.0_144 /usr/lib/jvm   设置环境变量：
sudo gedit /etc/profile 打开文件，在结尾处输入：
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 export JRE_HOME=/usr/lib/jvm/jdk1.8.0_144/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 生效配置文件：
  source /etc/profile  创建jdk软链接：  update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_144/bin/java 300 update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_144/bin/javac 300  设置默认jdk：  update-alternatives --config java  查看jdk版本，检查是否安装完成：  java -version</description>
    </item>
    
    <item>
      <title>HTML5的特性</title>
      <link>https://mannuan.github.io/post/20190530225803/</link>
      <pubDate>Thu, 30 May 2019 22:58:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530225803/</guid>
      <description>HTML5规范定义了一系列与DOM规范重叠的API;
HTML5的规范涉及面非常广，新增的DOM API只是其一部分。
 getElementsByClassName()  可以通过document和所有HTML元素对象调用此方法；
 返回带有指定类的NodeList;
 传入的一个字符串参数可以包含多个类；
  classList属性  所有元素都拥有，是新集合类型DOMTokenList的对象实例； 访问classList的项: []、item()、classList对象属性; 对象属性: length; 删除一个元素多个类名中的某个类名的旧版方法：  function removeClass(element, toDelClass){ var classNames = element.className.split(/\s+/); var pos = -1, i, len = className.length; for(i=0; i&amp;lt;len; i++){ if(classNames[i] == toDelClass){ pos = i; break; } } classNames.splice(i, 1); element.className = classNames.join(&amp;#39; &amp;#39;); } removeClass(document.body, &amp;#39;any-class&amp;#39;);   使用classList对象的方法操作元素的className：  var element = document.getElementById(&amp;#39;myDiv&amp;#39;); // add(value) -- 如果存在就不添加了 element.</description>
    </item>
    
    <item>
      <title>DOM扩展-元素遍历</title>
      <link>https://mannuan.github.io/post/20190530192147/</link>
      <pubDate>Thu, 30 May 2019 19:21:47 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530192147/</guid>
      <description> 使用循环语句进行常规遍历的不方便性：  元素间的空格(空行)的对待方式不一致，除IE9-外的浏览器都视作文本节点，所以未使用新API之前遍历元素都需要检测节点的类型，跳开空格（空行）代表文本节点。
 W3C的Element Traversal规范新定义了一组属性：IE9+支持：  childElementCount: 子元素节点的个数； firstElementChild: 第一个子元素节点； lastElementChild: 最后一个子元素节点； previousElementSibling: 后一个元素节点  旧的写法： var i, len, child = element.firstChild; while(child != element.lastChild){ if(child.nodeType == 1){ // 检查是不是元素  processChild(child); } child = child.nextSubling; }  新API下的写法： var i, len, child = element.firstElementChild; while(child != element.lastElementChild){ processChild(child); child = child.nextElementSibling; } </description>
    </item>
    
    <item>
      <title>pyspider如何刷新项目的状态</title>
      <link>https://mannuan.github.io/post/20190530170113/</link>
      <pubDate>Thu, 30 May 2019 17:01:13 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530170113/</guid>
      <description> 关闭pyspider 进入data目录 删除目录下面除了project.db之外的文件 重新启动pyspider  </description>
    </item>
    
    <item>
      <title>mongodb常用命令大全</title>
      <link>https://mannuan.github.io/post/20190530161620/</link>
      <pubDate>Thu, 30 May 2019 16:16:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530161620/</guid>
      <description>关键字的名称：test
数据表名：test
搜索关键字：test
    作用 命令 例子     列出所有包含test的item {&amp;quot;test&amp;quot;: {&amp;quot;$exists&amp;quot;: true}} db.getCollection(&#39;test&#39;).find({&amp;quot;test&amp;quot;: {&amp;quot;$exists&amp;quot;: true}})   根据test进行排序 新版本：[(&amp;quot;test&amp;quot;, 1或-1)]
老版本：{&amp;quot;test&amp;quot;:1或-1}
，&amp;rdquo;1&amp;rdquo;表示升序，”-1“表示降序 db.getCollection(&#39;test&#39;).find().sort([(&amp;quot;test&amp;quot;, -1)])   列出所有符合正则表达式的item {&amp;quot;test&amp;quot;: {&amp;quot;$regex&amp;quot;: &amp;quot;test&amp;quot;}} db.getCollection(&#39;test&#39;).find({&amp;quot;test&amp;quot;: {&amp;quot;$regex&amp;quot;: &amp;quot;test&amp;quot;}})   限制列出的item的数量 数字 db.getCollection(&#39;test&#39;).find().limit(自定义数字)   列出所有符合字符串长度的item {&amp;quot;$where&amp;quot;: &amp;quot;(this.test.length &amp;gt; 自定义长度)&amp;quot;} db.getCollection(&#39;test&#39;).find({&amp;quot;$where&amp;quot;: &amp;quot;(this.test.length &amp;gt; 自定义长度)&amp;quot;})   统计item的数量 collection.count_documents({}) db.getCollection(&amp;quot;test&amp;quot;).count_documents({})    持续更新&amp;hellip;</description>
    </item>
    
    <item>
      <title>百度知道爬虫</title>
      <link>https://mannuan.github.io/post/20190530153141/</link>
      <pubDate>Thu, 30 May 2019 15:31:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530153141/</guid>
      <description>工具： pyspider
数据库： mongodb
思路：  假设你要根据两个关键字搜索百度知道答案，比如：”购物“和”价格“； 组建爬虫的url，需要把这两个关键字转化为url编码的格式，url编码教程详见； 取出搜索页面列表上面所有项的url链接; 然后，爬取步骤3的url，取出页面上面的question和最佳答案； 循环往复，进行2、3、4步骤；  代码： #!/usr/bin/env python # -*- encoding: utf-8 -*- from pyspider.libs.base_handler import * from urllib.parse import quote, unquote from pymongo import MongoClient import datetime import time import random client = MongoClient(&amp;#34;自定义数据库接口&amp;#34;) db = client.自定义数据库名 class Handler(BaseHandler): crawl_config = { } key_word1 = quote(&amp;#34;自定义关键字1&amp;#34;.encode(&amp;#34;GB2312&amp;#34;)) key_word2_list = [&amp;#34;自定义关键字2&amp;#34;] key_word2_list = [quote(i.encode(&amp;#34;GB2312&amp;#34;)) for i in key_word2_list] url_format = &amp;#34;https://zhidao.baidu.com/search?word={}&amp;amp;ie=gbk&amp;amp;site=-1&amp;amp;sites=0&amp;amp;date=0&amp;amp;pn={}&amp;#34; page_num = 76 # 最大页码 start_page = 0 # 开始的页码 max_random = 5 # 随机数的最大值 headers1 = { &amp;#34;Accept&amp;#34;: &amp;#34;text/html,application/xhtml+xml,application/xml;q=0.</description>
    </item>
    
    <item>
      <title>百度搜索-url编码</title>
      <link>https://mannuan.github.io/post/20190530113844/</link>
      <pubDate>Thu, 30 May 2019 11:38:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530113844/</guid>
      <description>  百度搜索编码的格式与国际上面其他搜索的格式有所不同，比如google的是UTF-8，但是百度使用的是GB2312编码。
 应用场景  在爬虫当中我们经常需要组装url来进行页面的爬虫，这个时候我们就需要把搜索的关键字编码为url的形式，下面我们以python3代码为例讲解url的编码和解码：  # -*- coding: utf-8 -*- from urllib.parse import quote, unquote key_word = &amp;#34;购车&amp;#34;; # url编码 key_word_quote = quote(key_word.encode(&amp;#34;GB2312&amp;#34;), &amp;#39;gbk&amp;#39;) print(key_word_quote) # url解码 print(unquote(key_word_quote, &amp;#39;gbk&amp;#39;))</description>
    </item>
    
    <item>
      <title>DOM扩展-选择符API</title>
      <link>https://mannuan.github.io/post/20190530105836/</link>
      <pubDate>Thu, 30 May 2019 10:58:36 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530105836/</guid>
      <description>  选择符API允许直接使用CSS选择器来选取页面元素，众多库推进了选择符API的标准化。
选择符API性能因为原生，所以性能必定强于各个库同类型的查询操作。
 querySelector()  Selector API Level 1;
 接收一个css选择符（可复杂）,返回匹配的第一个元素或返回null;
 传入不支持的选择符会抛出错误；
 能调用querySelector()的对象为：Document类型，Element类型，DocumentFragment类型。
  querySelectorAll()  Selector API Level 1; 接收一个CSS选择符（可复杂），返回所有匹配元素组成的NodeList实例或null; 传入不支持的选择符会抛出错误； 能调用querySelector()的对象为：Document类型，Element类型，DocumentFragment类型。  matchesSelector()  Selector API Level 2; 接收一个css选择器做参数，比较选择符与调用方法的元素是否匹配，返回布尔值； 各个浏览器支持性不同：IE9+通过document.body.msMatchesSelector()支持该方法，Firefox3.6通过document.body.mozMatchesSelector()支持该方法，Safari5+和Chrome通过document.body.webkitMatchesSelector()支持该方法。下面是一个包装的函数：  function matchesSelector(element, selector){ if(element.matchesSelector){ return element.matchesSelector(selector); }else if(element.msMatchesSelector){ return element.msMatchesSelector(selector); }else if(element.mozMatchesSelector){ return element.mozMatchesSelector(selector); }else if(element.webkitMatchesSelector){ return element.webkitMatchesSelector(selector); }else{ throw new Error(&amp;#34;Not supported.&amp;#34;); } } if(matchesSelector(document.body, &amp;#34;body.page1&amp;#34;)){ //执行操作 } </description>
    </item>
    
    <item>
      <title>DOM扩展的发展和现状</title>
      <link>https://mannuan.github.io/post/20190530103703/</link>
      <pubDate>Thu, 30 May 2019 10:37:03 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530103703/</guid>
      <description>2008年之前，几乎所有的DOM扩展都是专有的，之后W3C着手将一些已经成为事实的专有扩展标准化并写入规范当中；
大部分扩展都来自社区的呼声，虽然现在标准已经涵盖了大量的以前的DOM扩展，但是各个浏览器的专有扩展依然存在。</description>
    </item>
    
    <item>
      <title>table, tbody, tr 元素的属性和方法</title>
      <link>https://mannuan.github.io/post/20190530100359/</link>
      <pubDate>Thu, 30 May 2019 10:03:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190530100359/</guid>
      <description>&amp;lt;table&amp;gt;元素的属性和方法：  caption：返回表格的caption元素节点，没有则返回null； tHead, tBodies, tFoot: 返回表格&amp;lt;thead&amp;gt;, &amp;lt;tbody&amp;gt;, &amp;lt;tfoot&amp;gt;元素； rows: 返回元素所有行&amp;lt;tr&amp;gt;元素的HTMLCollection; createTHead(), createTFoot(), createCaption(): 创建&amp;lt;thead&amp;gt;, &amp;lt;tfoot&amp;gt;, &amp;lt;caption&amp;gt;空元素，将其放到表格中，返回创建的&amp;lt;thead&amp;gt;, &amp;lt;tfoot&amp;gt;, &amp;lt;caption&amp;gt;元素节点； deleteTHead(), deleteTFoot(), deleteCaption(): 删除&amp;lt;thead&amp;gt;, &amp;lt;tfoot&amp;gt;, &amp;lt;caption&amp;gt;空元素，无返回值（或返回值为undefined） deleteRow(pos): 删除指定位置（注意参数不是索引，而是从0开始的位置）的行，返回undefined; insertRow(pos): 向rows集合中的指定位置（不是索引）插入一行；  &amp;lt;tbody&amp;gt;元素的属性和方法：  rows: 返回&amp;lt;tbody&amp;gt;元素下所有行&amp;lt;tr&amp;gt;元素的HTMLCollection; deleteRow(pos): 删除指定位置（注意参数不是索引，而是从0开始的位置）的行，返回undefined; insertRow(pos):向rows集合中的指定位置（不是索引）插入一行；  &amp;lt;tr&amp;gt;元素的属性和方法：  cells: 返回&amp;lt;tr&amp;gt;元素中单元格的HTMLCollection; deleteCell(pos): 删除指定位置（不是索引）的单元格； insertCell(pos): 向cells集合中的指定位置（不是索引）插入一个单元格，返回对新插入单元格的引用；   &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; // 创建table  var table = document.createElement(&amp;#39;table&amp;#39;); table.border = 1; table.width = &amp;#39;100%&amp;#39;; // 创建caption  var caption = table.</description>
    </item>
    
    <item>
      <title>DOM操作技术</title>
      <link>https://mannuan.github.io/post/20190529225444/</link>
      <pubDate>Wed, 29 May 2019 22:54:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529225444/</guid>
      <description>DOM操作最大的两个麻烦就是：操作效率问题、浏览器兼容问题
 动态脚本  通过修改DOM动态添加的脚本的两种模式：插入外部文件，插入JavaScript代码 插入外部文件  var script = document.createElement(&amp;#39;script&amp;#39;); script.src = &amp;#39;client.js&amp;#39;; document.body.appendChild(script);   封装为外部脚本插入函数  fucntion loadScript(url){ var script = document.createElement(&amp;#39;script&amp;#39;); script.src = url; document.body.appendChild(script); } loadScript(&amp;#39;script.js&amp;#39;);   插入行内代码：不兼容IE,它将&amp;lt;script&amp;gt;视为一个特殊的元素，不允许DOM访问其子节点： ```javascript
var script = document.createElement(&amp;lsquo;script&amp;rsquo;); var textNode = document.createTextNode(&amp;lsquo;function sayHi(){alert(\&amp;lsquo;Hi!\&amp;lsquo;)}&amp;rsquo;); script.appendChild(textNode);  document.body.appendChild(script);
 3. 插入行内代码的兼容性解决方案：行内脚本插入封装函数 ```javascript function loadScript(code){ var script = document.createElement(&#39;script&#39;); try{ script.appendChild(document.createTextNode(code)); }catch(err){ script.text = code; } document.body.appendChild(script); } loadScript(&#39; function sayHi(){alert(&amp;quot;Hi!</description>
    </item>
    
    <item>
      <title>javascript的Comment、CDATASection、DocumentType、DocumentFragment、Attr类型</title>
      <link>https://mannuan.github.io/post/20190529223557/</link>
      <pubDate>Wed, 29 May 2019 22:35:57 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529223557/</guid>
      <description> Comment类型  nodeType为8，nodeName为#comment，nodeValue为注释内容； Comment类型拥有除splitText()之外的所有的属性和方法； 创建注释节点只需要传入注释内容即可  document.createComment(&amp;#39;Hi&amp;#39;);   一般浏览器不会识别位于后面的注释；
 在IE8中，注释节点被视作标签名为&amp;rdquo;!&amp;rdquo; 的元素，注释节点可以使用getElementsByTagName(&#39;!&#39;)取得；
  CDATASection类型  nodeType为4，nodeName为#cdata-section，nodeValue为CDATA区域的内容； CDATASection类型针对的是XML文档，表示的是CDATA区域，在HTML文档中会错误地把CDATA区域解析为Comment或Element； 针对XML文档，可以使用document.createCDATASection()来创建CDATASection类型对象，接收一个参数：CDATA区域的内容； CDATASection类型继承自Text类型，除了splitText()方法外所有的属性和方法都拥有；  DocumentType类型  nodeType为0；nodeName为#document，nodeValue为null； 不能动态的创建，只能有html文档规定； document.doctype.name(entities、notations这两个属性没有用)属性； 使用document.doctype访问DocumentType对象；  DocumentFragment类型  文档碎片； DocumentFragment节点类型在文档中没有对应标记，它是游离于文档之外的； DocumentFragment类型是一种轻量级的文档（类似完整的HTML文档），可以包含和控制节点，但不会像完整的文档那样占用额外的资源； nodeType为11;nodeName为#document-fragment；nodeValue为null；可以包含任意类型的子节点； DocumentFrgment类型一般作为一个节点仓库来使用，可以在里面保存将来可能添加到文档的节点，然后DocumentFragment整体插入到文档内； DocumentFragment类型继承了node类型的所有方法； 创建：document.createDocumentFragment(); 文档碎片可以通过appendChild(DoCFrag), insertBefore(DocFrag)来插入文档，此时文档碎片便成为了文档的一部分；  Attr类型  元素的特性在DOM中以Attr类型来表示； 特性就是存在于元素的attributes属性对象中的节点； 三个属性：name, value, specified; 创建特性节点：document.createAttribute(attrName); 新创建的特性节点需要添加到元素上，使用元素的setAttribute(attrName)方法； html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;123&amp;quot; style=&amp;quot;height: 20px;&amp;quot;&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; ele.setAttribute(&#39;align&#39;, &#39;left&#39;); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;  6. 不建议直接访问元素的特性节点（getAttributeNode()等），而使用getAttribute(), setAttribute(), removeAttribute()来访问和操作元素的特性。  </description>
    </item>
    
    <item>
      <title>javascript Text类型</title>
      <link>https://mannuan.github.io/post/20190529203530/</link>
      <pubDate>Wed, 29 May 2019 20:35:30 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529203530/</guid>
      <description>nodeType为3, nodeName为#text; 不支持子节点； 可以包含转义的HTML字符； 文本节点的值可以通过nodeValue属性或data属性访问；  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;123&amp;#34; style=&amp;#34;height: 20px;&amp;#34;&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; var text = document.createTextNode(&amp;#34;Hello world!&amp;#34;); console.log(text.nodeType); // 输出：3  console.log(text.nodeName); // 输出：#text  console.log(text.nodeValue); // 输出：Hello world!  console.log(text.data); // 输出：Hello world!  console.log(text.nodeValue.length); // 输出：12  console.log(text.data.length); // 输出：12  &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;  操作文本节点的方法
 默认情况下。每个包含内容的元素最多只能有一个文本节点，而且必须有内容存在；
 创建和修改文本节点时，字符串会经过HTML（或XML）编码转义，防止对原文档造成解析错误；
  div.firstChild.nodeValue = &amp;#34;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;#34;; // &amp;#34;&amp;amp;lt;p&amp;amp;gt;Hello world!&amp;amp;lt;/p&amp;amp;gt;&amp;#34;  创建文本节点  document.createTextNode(); 可以人为使一个元素包含多个文本节点，虽然多个文本节点的表现形式与单个节点的表现形式没什么两样；  &amp;lt;!</description>
    </item>
    
    <item>
      <title>javascript操作文本节点的方法</title>
      <link>https://mannuan.github.io/post/20190529203109/</link>
      <pubDate>Wed, 29 May 2019 20:31:09 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529203109/</guid>
      <description> appendText(text); deleteData(offset, count); insertData(offset, count); replaceData(offset, count, text); splitText(offset); substringData(offset, count);  </description>
    </item>
    
    <item>
      <title>javascript Element类型</title>
      <link>https://mannuan.github.io/post/20190529160524/</link>
      <pubDate>Wed, 29 May 2019 16:05:24 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529160524/</guid>
      <description>Element节点是Element类型的实例； Element节点的nodeName与tagName属性元素的标签名的大写;nodeValue为null;  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;123&amp;#34;&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; var _div = document.getElementById(&amp;#34;123&amp;#34;); console.log(_div.nodeName); console.log(_div.tagName); console.log(_div.nodeValue); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;  最佳实践：在比较标签名与字符串时，最好先将标签名转为为全小写。  HTML元素  所有HTML元素都由HTMLElement类型表示，HTMLElement类型继承自Element类型并添加了一些属性和方法；   所有HTML元素都是由HTMLElement或者其子类型表示的，每个HTML元素都由与之关联的类型，如：HTMLAnchorElement, HTMLBodyElement, HTMLDivElement&amp;hellip;, 这些类型都继承HTMLElement类型的属性和方法，也有着自己的扩展
  大部分HTML标签的原生特性作为Element节点对象的属性都可以直接通过&amp;rdquo;.&amp;ldquo;或&amp;rdquo;[]&amp;ldquo;操作符读写，但无法读写自定义的特性（见下面的取得特性一节）  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;123&amp;#34;&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; var _div = document.getElementById(&amp;#34;123&amp;#34;); console.log(_div.id); console.log(_div.className); console.log(_div.name); console.log(_div[&amp;#34;id&amp;#34;]); console.log(_div[&amp;#34;className&amp;#34;]); console.log(_div[&amp;#34;name&amp;#34;]); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;  class为ES的保留字，使用“.” 或&amp;rdquo;[]&amp;ldquo;访问元素类名需要使用className。  取得特性 getAttribute(), setAttribute(), removeAttribute()三个特性操作的方法：
 传递给getAttribute()的特性名字符串与实际的特性名相同，比如：要获取class的特性值，应该传入&amp;rsquo;class&amp;rsquo;,而不是&amp;rsquo;className&amp;rsquo;; 通过getAttribute()方法可以取得自定义特性； 最佳实践：根据HTML5的规范推荐，自定义特性应该加上data-前缀以便验证； getAttribute()方法与节点的访问方法&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>getElementById()的注意事项</title>
      <link>https://mannuan.github.io/post/20190529111342/</link>
      <pubDate>Wed, 29 May 2019 11:13:42 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529111342/</guid>
      <description> 传入参数对应的ID的元素不存在，返回null； 传入参数大小写需与实际元素id特性严格匹配； 多个元素的id特性相同，方法返回文档中第一次出现的那个；  </description>
    </item>
    
    <item>
      <title>Document类型</title>
      <link>https://mannuan.github.io/post/20190529094341/</link>
      <pubDate>Wed, 29 May 2019 09:43:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190529094341/</guid>
      <description>文档的子节点  使用documentElement属性快捷访问页面的元素； 使用body属性可以快捷的访问页面的元素; doctype属性可在部分浏览器下访问文档的类型声明；各个浏览器对于文档声明的支持方式存在较大差异：IE8-:文档类型声明被解释为一个注释，当做comment节点，document.doctype返回值为null；大部分浏览器：文档类型声明作为文档的第一个子节点，是一个DocumentType节点，可以通过document.doctype, document.childNodes[0], document.firstChild访问  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.doctype); // 输出: &amp;lt;!DOCTYPE html&amp;gt;  console.log(document.childNodes[0]); // 输出: &amp;lt;!DOCTYPE html&amp;gt;  console.log(document.firstChild); // 输出: &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;  各个浏览器对于元素外的注释的解析方式不同，比如  &amp;lt;!--第一条注释--&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.childNodes.length); // chrome输出: 3 &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; &amp;lt;!--第二条注释--&amp;gt; 部分浏览器会为两个注释都建立注释节点，部分浏览器会忽略第二条，只为第一条创建注释节点，大部分浏览器现在回完全忽略第二条注释，比如这里的chrome。
文档信息  title属性用于便捷读写title标签； URL属性只读，referrer属性只读； domain属性可读可写，但不能设置为当前URL中不包含的域，通过设置domain属性相同可实现框架间不同子域页面的JavaScript通信； document.domain只能往上级域名方向设置，设置为非上级域名会报错，不能设置为顶级域名; 使用document.domain实现跨父子域  查找元素  getElementById()的注意事项; getElementByTagName() 方法返回的是HTMLCollection对象；  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.</description>
    </item>
    
    <item>
      <title>vscode快捷键大全</title>
      <link>https://mannuan.github.io/post/20190528191941/</link>
      <pubDate>Tue, 28 May 2019 19:19:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190528191941/</guid>
      <description>名称 快捷键     上下移动行 Alt(option) + 上下键   删除行 \( \Uparrow \) + command + K   打开输出窗口 \( \Uparrow \) + command + U    持续更新中&amp;hellip;</description>
    </item>
    
    <item>
      <title>Document类型、HTMLDocument类型和document对象的区别</title>
      <link>https://mannuan.github.io/post/20190528111913/</link>
      <pubDate>Tue, 28 May 2019 11:19:13 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190528111913/</guid>
      <description> Dcoment表示文档，这里的文档可以是HTML文档，也可以是XML文档，换句话说Document类型能表示HTML和XML等文档； HTMLDocument对象继承自Document对象，专用于表示HTML文档； document对象是HTMLDocument对象的一个实例，表示整个HTML页面，又叫做页面的根节点；  Document对象（根节点）的特征：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.nodeType); console.log(document.nodeName); console.log(document.nodeValue); console.log(document.parentNode); console.log(document.ownerDocument); console.log(document.childNodes); // 其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment  &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;</description>
    </item>
    
    <item>
      <title>Javascript-DOM中NodeList对象转数组的通用方法</title>
      <link>https://mannuan.github.io/post/20190528101901/</link>
      <pubDate>Tue, 28 May 2019 10:19:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190528101901/</guid>
      <description>举例说明：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&amp;#34;ul&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 123 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 456 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 789 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; var _childNodes = document.getElementById(&amp;#34;ul&amp;#34;).childNodes; function convertToArray(nodes) { var array = null; try { array = Array.prototype.slice.call(nodes, 0); // 针对非IE浏览器  } catch (ex) { array = new Array(); for (var i = 0, len = nodes.length; i &amp;lt; len; i++) { array.push(nodes[i]); } } return array; } console.log(convertToArray(_childNodes)); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;</description>
    </item>
    
    <item>
      <title>function中的arguments转数组的标准方法</title>
      <link>https://mannuan.github.io/post/20190528095304/</link>
      <pubDate>Tue, 28 May 2019 09:53:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190528095304/</guid>
      <description>举例说明:
function arr(){ console.log(arguments); // 输出：[Arguments] { &amp;#39;0&amp;#39;: 1, &amp;#39;1&amp;#39;: 2, &amp;#39;2&amp;#39;: 3 }  _array = Array.prototype.slice.apply(arguments); console.log(_array); // 输出：[ 1, 2, 3 ] } arr(1, 2, 3) </description>
    </item>
    
    <item>
      <title>DOM-Node基本类型</title>
      <link>https://mannuan.github.io/post/20190527223544/</link>
      <pubDate>Mon, 27 May 2019 22:35:44 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190527223544/</guid>
      <description>DOM1级定义了一个Node接口，该接口作为Node类型实现;  // 节点类型（nodeType）1~12 Node.ELEMENT_NODE; // 1 Node.ATTRIBUTE_NODE; // 2 Node.TEXT_NODE; // 3 Node.CDATA_SECTION_NODE; // 4 Node.ENTITY_REFERENCE_NODE; // 5 Node.ENTITY_NODE; // 6 Node.PROCESSING_INSTRUCTION_NODE; // 7 Node.COMMENT_NODE; // 8 Node.DOCUMENT_NODE; // 9 Node.DOCUMENT_TYPE_NODE; // 10 Node.DOCUMENT_FRAGMENT_NODE; // 11 Node.NOTATION_NODE; // 12   JavaScript中所有节点类型都继承自Node类型，所有的节点类型都共享相同的基本属性和方法；
 最佳实践：对节点进行操作时，最好使用nodeType检测节点的类型;
  nodeName和nodeValue 对于元素节点(nodeType === 1)，nodeName是元素标签名的大写，nodeValue的值始终是null;
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;ele&amp;#34;&amp;gt; some text &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; var ele = document.getElementById(&amp;#34;ele&amp;#34;); console.log(ele.nodeType === 1); // 输出：true  console.</description>
    </item>
    
    <item>
      <title>用闭包实现命令模式</title>
      <link>https://mannuan.github.io/post/20190527140401/</link>
      <pubDate>Mon, 27 May 2019 14:04:01 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190527140401/</guid>
      <description>var Tv = { open: function(){ console.log(&amp;#39;打开电视机&amp;#39;); }, close: function(){ console.log(&amp;#39;关上电视机&amp;#39;); }, }; var OpenTvCommand = function(receiver){ this.receiver = receiver; }; OpenTvCommand.prototype.execute = function(){ this.receiver.open(); // 执行命令，打开电视机 }; OpenTvCommand.prototype.undo = function(){ this.receiver.close(); // 撤销命令，关闭电视机 }; command = new OpenTvCommand(Tv); command.execute() // 输出：打开电视机 command.undo() // 输出：关上电视机  博客参考自JavaScript设计模式与开发实践，[p41-p42]</description>
    </item>
    
    <item>
      <title>闭包和面向对象设计的等价实现举例</title>
      <link>https://mannuan.github.io/post/20190527113008/</link>
      <pubDate>Mon, 27 May 2019 11:30:08 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190527113008/</guid>
      <description>下面这段是闭包的代码：
var extent = function(){ var value = 0; return { call: function(){ value++; console.log(value); } } }; var extent = extent(); extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3  转换成面向对象的写法是：
var extent = { value: 0, call: function(){ this.value++; console.log(this.value); } }; extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3  原型链写法：
var extent = function(){ this.value = 0; }; Extent.prototype.call = function(){ this.value++; console.log(this.value); } var extent = new Extent(); extent.</description>
    </item>
    
    <item>
      <title>javascript闭包详解</title>
      <link>https://mannuan.github.io/post/20190527104504/</link>
      <pubDate>Mon, 27 May 2019 10:45:04 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190527104504/</guid>
      <description>闭包的两个知识点：  变量搜索方向：在javascript中，函数可以创造函数作用域。在函数作用域里面可以看到外面的变量，而函数的外面无法访问到函数里面的变量。因此，在作用域里面的变量搜索方向是：自内向外。比如，下面这段代码就验证了这个搜索方向：  var a = 1; var func1 = function(){ var b = 2; var func2 = function(){ var c = 3; console.log(b); // 输出：2  console.log(a); // 输出：1  } func2(); console.log(c); // 输出：Uncaught ReferenceError: c is not defined }; func1();   变量的生存的周期：全局变量的生存周期是永久的，局部变量随着函数调用的结束而销毁。  // 例一 var func = function(){ var a = 1; // 退出函数后局部变量a将被销毁  console.log(a); }; func(); // 例二 var func = function(){ var a = 1; return function(){ a++; console.</description>
    </item>
    
    <item>
      <title>交换机断网的原因分析</title>
      <link>https://mannuan.github.io/post/20190527102625/</link>
      <pubDate>Mon, 27 May 2019 10:26:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190527102625/</guid>
      <description>网卡扩展坞由于带电会影响交换机，导致局域网断网  持续更新&amp;hellip;</description>
    </item>
    
    <item>
      <title>javascript函数递归实现</title>
      <link>https://mannuan.github.io/post/20190522223920/</link>
      <pubDate>Wed, 22 May 2019 22:39:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522223920/</guid>
      <description>在非严格模式下：  主要通过arguments.callee实现递归，它是一个指向正在执行的函数的指针。
 function factorial(num){ if(num &amp;lt;= 1){ return 1; }else{ return num * arguments.callee(num - 1); } }  在严格模式下：  虽然访问arguments.callee这个属性会导致错误，但是可以使用函数表达式来达成相同的结果。
 var factorial = function f(num){ if(num &amp;lt;= 1){ return 1; }else{ return num * f(num-1); } };  本篇博客参考自JavaScript高级程序设计，[p177-p178]</description>
    </item>
    
    <item>
      <title>v8引擎源码—Array.prototype.push实现详解</title>
      <link>https://mannuan.github.io/post/20190522211458/</link>
      <pubDate>Wed, 22 May 2019 21:14:58 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522211458/</guid>
      <description>具体实现如下： function ArrayPush(){ var n = TO_UINT32(this.length); // 被push的对象的length  var m = %_AraumentsLength(); // push的参数个数  for(var i=0; i&amp;lt;m; i++){ this[i+n] = %_Arguments(i); // 复制元素 （1）  } this.length = n + m; // 修正length属性的值  return this.length; }   从上面的代码可以看出，Array.prototype.push实际上是一个属性复制的过程，把参数按照下标依次添加到被push的对象上面，同时修改了对象的length属性，不需要关注被修改的对象是数组还是类数组。 因此，我们可以把任意类型的对象传入到Array.prototype.push中，比如下面这个例子：
 var a = {}; Array.prototype.push.call(a, &amp;#34;first&amp;#34;, &amp;#34;second&amp;#34;); console.log(a);   观察上面这个例子我们发现如果要实现javascript中call和apply的区别与联系中&amp;rdquo;借用其他对象的方法&amp;rdquo;，需要满足下面的条件：
 对象本身可以存取属性；
 对象的length属性可读写；
   本篇博客参考自JavaScript设计模式与开发实践，[p33-p34]</description>
    </item>
    
    <item>
      <title>javascript中call和apply的区别与联系</title>
      <link>https://mannuan.github.io/post/20190522204729/</link>
      <pubDate>Wed, 22 May 2019 20:47:29 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522204729/</guid>
      <description>apply接收两个参数：  指定了函数体内this对象的指向； 一个带下标的集合（可以是数组或类数组）   var func = function(a, b, c){ console.log([a, b, c]); // 输出[1, 2, 3] } func.apply(null, [1, 2, 3]);  call接收一个或多个参数：  指定了函数体内this对象的指向； 从第二个参数往后，每个参数被依次传入函数；   var func = function(a, b, c){ console.log([a, b, c]); // 输出[1, 2, 3] } func.call(null, 1, 2, 3);   从上面的两个例子我们可以看出apply和call的唯一的区别就是：传入参数的数量是否固定。通常call在以下情况使用：  函数传入的参数数量确定； 需要清晰地表达形参和实参之间的对应关系  apply和call使用注意点：  如果传入的第一个参数是null，this就会指向全局对象，在浏览器上面是window，在nodejs上是global; 在1的条件下，如果使用严格模式，函数体内的this还是为null;   var func = function(a, b, c){ &amp;#34;use strict&amp;#34;; console.</description>
    </item>
    
    <item>
      <title>javascript中的this</title>
      <link>https://mannuan.github.io/post/20190522152759/</link>
      <pubDate>Wed, 22 May 2019 15:27:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522152759/</guid>
      <description>ES5  this的指向分为4种：
 隐式的this指向  作为对象的方法调用，this指向的是当前对象
 var obj = { a: 1, getA: function(){ console.log(this == obj); // true  console.log(this.a); // 1  } } obj.getA();  硬指定的this  作为普通函数调用，this指向的是全局对象
 name = &amp;#39;globalName&amp;#39;; var getName = function(){ console.log(this == window); console.log(name); }; getName();  或者 将对象的方法加入全局对象中，会改变原本的this指向
name = &amp;#39;globalName&amp;#39;; var myObject = { name: &amp;#34;sven&amp;#34;, getName: function(){ console.log(this == window); console.log(this.name); } } var getName = myObject.</description>
    </item>
    
    <item>
      <title>js通过代码来理解构造函数的实现过程</title>
      <link>https://mannuan.github.io/post/20190522102308/</link>
      <pubDate>Wed, 22 May 2019 10:23:08 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522102308/</guid>
      <description>原生实现
 function Person(name){ this.name = name; }; Person.prototype.getName = function(){ return this.name; } var a = new Person(&amp;#39;sven&amp;#39;); console.log(a.name); console.log(a.getName()); console.log(Object.getPrototypeOf(a) === Person.prototype);  代码实现
function Person(name){ this.name = name; }; Person.prototype.getName = function(){ return this.name; } var objectFactory = function(){ var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === &amp;#34;object&amp;#34; ? ret: obj; } var a = objectFactory(Person, &amp;#34;sven&amp;#34;); console.</description>
    </item>
    
    <item>
      <title>js: new Object()与Object.create()的区别</title>
      <link>https://mannuan.github.io/post/20190522093759/</link>
      <pubDate>Wed, 22 May 2019 09:37:59 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190522093759/</guid>
      <description>语法：  Object.create(proto, [propertiesObject])
//方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。
 参数：   proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是null， 对象， 函数的prototype属性 （创建空的对象时需传null , 否则会抛出TypeError异常）。 propertiesObject : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。  3 返回值：
在指定原型对象上添加新属性后的对象。
 案例说明：  1）创建对象的方式不同
new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。
Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。
// new Object() 方式创建 var a = { rep : &amp;#39;apple&amp;#39; }; var b = newObject(a); console.log(b); // {rep: &amp;#34;apple&amp;#34;} console.log(b.__proto__); //{} console.log(b.rep); // {rep: &amp;#34;apple&amp;#34;} // Object.create() 方式创建 var a = { rep: &amp;#39;apple&amp;#39; }; var b = Object.</description>
    </item>
    
    <item>
      <title>js 引用类型的判断</title>
      <link>https://mannuan.github.io/post/20190520112215/</link>
      <pubDate>Mon, 20 May 2019 11:22:15 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190520112215/</guid>
      <description> result = 变量 instanceof 数据类型; //ECMAScript 提供了 instanceof 操作符来检测引用类型   Array,Regex和Date等引用数据类型都是Object的实例，因此&amp;rdquo;instanceof&amp;rdquo;返回的都是&amp;rdquo;object&amp;rdquo;
 </description>
    </item>
    
    <item>
      <title>js Function详解</title>
      <link>https://mannuan.github.io/post/20190520110931/</link>
      <pubDate>Mon, 20 May 2019 11:09:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190520110931/</guid>
      <description> Function不介意传入多少个参数，也不在乎传入参数的类型（参数在内部使用数组来表示，在函数内部可以通过arguments访问）； Function没有重载 Function传入的参数只能按值传递(即使传入的是引用类型)，详细请看js Function 参数按值传递详解 Function可以设置默认参数，比如：  function randomNum(max=100, start=33){ return Math.floor(Math.random() * max + start) } console.log(randomNum(1000, 33)); </description>
    </item>
    
    <item>
      <title>js Function 参数按值传递详解</title>
      <link>https://mannuan.github.io/post/20190520110829/</link>
      <pubDate>Mon, 20 May 2019 11:08:29 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190520110829/</guid>
      <description>  如果传入参数是基本数据类型，那么按值传递是很容易理解的； 如果传入参数是引用数据类型，那么会很容易陷入误区，错误地认为是引用传递；   错误例子一：
function setColor(obj){ obj.color = &amp;#34;red&amp;#34;; } var picture = new Object(); setColor(picture); console.log(picture); //&amp;#34;red&amp;#34;  看到上面这个例子后，很容易认为：”函数的值是传入了引用，然后通过引用修改了对象的属性。“
纠正例子二：
function setColor(obj){ obj.color = &amp;#34;red&amp;#34;; obj = new Object(); obj.color = &amp;#34;blue&amp;#34;; } var picture = new Object(); setColor(picture); console.log(picture.color); //&amp;#34;red&amp;#34;  我们发现，如果函数传入的是引用，那么在函数内部的修改picture的引用就会对象把指向color为”blue“的对象；但是根据输出的结果，很显然是错误；
 结论：因此，不管函数传入的是什么数据类型，都是按值传递的。
 </description>
    </item>
    
    <item>
      <title>javascript的数据类型</title>
      <link>https://mannuan.github.io/post/20190520102008/</link>
      <pubDate>Mon, 20 May 2019 10:20:08 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190520102008/</guid>
      <description>基本数据类型  Number Boolean String null undefined  复杂数据类型 Object Array 待更新&amp;hellip;
Date 待更新&amp;hellip;</description>
    </item>
    
    <item>
      <title>js 相等和不相等操作符总结</title>
      <link>https://mannuan.github.io/post/20190517165040/</link>
      <pubDate>Fri, 17 May 2019 16:50:40 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190517165040/</guid>
      <description>操作符两边操作数先转换数据类型，然后再比较它们的相等性，具体的规则如下：
   操作符规则 操作符a的数据类型 操作符b的数据类型 == != 备注     Boolean转为Number — — — Boolean无条件转为Number类型   String转为Number Number — — —   Object转为a.valueOf() 除了Object之外的所有类型 — — —   null undefined true false null等于underfined   NaN — false true NaN不等于NaN   Object Object — — 如果a和b指向同一个对象，相等操作符返回true，否则返回false     上述表格归纳自javascript高级程序设计，[p51-p53]
 </description>
    </item>
    
    <item>
      <title>jupyter_notebook_config.py的配置详解</title>
      <link>https://mannuan.github.io/post/20190515155513/</link>
      <pubDate>Wed, 15 May 2019 15:55:13 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190515155513/</guid>
      <description># Configuration file for jupyter-notebook. #------------------------------------------------------------------------------ # Application(SingletonConfigurable) configuration #------------------------------------------------------------------------------ ## This is an application. ## The date format used by logging formatters for %(asctime)s #c.Application.log_datefmt = &amp;#39;%Y-%m-%d %H:%M:%S&amp;#39; ## The Logging format template #c.Application.log_format = &amp;#39;[%(name)s]%(highlevel)s %(message)s&amp;#39; ## Set the log level by value or name. #c.Application.log_level = 30 #------------------------------------------------------------------------------ # JupyterApp(Application) configuration #------------------------------------------------------------------------------ ## Base class for Jupyter applications ## Answer yes to any prompts. #c.JupyterApp.answer_yes = False ## Full path of a config file.</description>
    </item>
    
    <item>
      <title>jupyter_notebook_config.py常用配置</title>
      <link>https://mannuan.github.io/post/20190515154121/</link>
      <pubDate>Wed, 15 May 2019 15:41:21 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190515154121/</guid>
      <description># -*- coding: utf-8 -*- # notebook服务会监听的IP地址，这个ip地址最好不要填任意的，否则不安全 c.NotebookApp.ip = &amp;#39;localhost&amp;#39; # 这条命令会与下面的一条命令hostnames冲突，如果这个设置为True,这下面这条命令不生效，反之，则生效 c.NotebookApp.allow_remote_access = True # 为本地主机取多个ip别名 c.NotebookApp.local_hostnames = [&amp;#39;localhost&amp;#39;] c.NotebookApp.open_browser = False c.NotebookApp.password = &amp;#34;密码&amp;#34; c.NotebookApp.port = 8888 c.NotebookApp.notebook_dir = &amp;#34;文件路径&amp;#34; 密码的生成详见jupyter如何设置密码
如果，想要在其他主机上面访问 jupyter, 必须设置
c.NotebookApp.allow_remote_access = True</description>
    </item>
    
    <item>
      <title>jupyter 如何设置密码</title>
      <link>https://mannuan.github.io/post/20190515153220/</link>
      <pubDate>Wed, 15 May 2019 15:32:20 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190515153220/</guid>
      <description>打开python命令行，输入
from notebook.auth import passwd passwd() 以密码&amp;rdquo;123&amp;rdquo;为例，输出结果得到如下
&amp;#39;sha1:da00fa1e950a:0adb64c8359ef97932e5dde02d6167e140bac4e0&amp;#39; 然后把上面的sha写入到配置文件&amp;rdquo;jupyter_notebook_config.py&amp;rdquo;, 这个文件一般需要使用命令生成
完整的一条配置命令如下：
c.NotebookApp.password = &amp;#39;sha1:da00fa1e950a:0adb64c8359ef97932e5dde02d6167e140bac4e0&amp;#39; 上面这条配置命令可以放在配置文件任意位置</description>
    </item>
    
    <item>
      <title>jupyter_notebook_config.py 文件的生成命令</title>
      <link>https://mannuan.github.io/post/20190515151225/</link>
      <pubDate>Wed, 15 May 2019 15:12:25 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190515151225/</guid>
      <description>jupyter notebook --generate-config</description>
    </item>
    
    <item>
      <title>apt-get: error loading libgcc_s.so.1的解决方案</title>
      <link>https://mannuan.github.io/post/20190513111449/</link>
      <pubDate>Mon, 13 May 2019 11:14:49 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190513111449/</guid>
      <description>出现这个问题的主要原因是&amp;rdquo;/lib/x86_64-linux-gnu/&amp;ldquo;目录下缺少libgcc_s.so.1
解决方案：从其他相同操作系统的主机上的&amp;rdquo;/lib/x86_64-linux-gnu/&amp;ldquo;目录，拷贝libgcc_s.so.1</description>
    </item>
    
    <item>
      <title>dpkg error package `x&#39; contains empty filename</title>
      <link>https://mannuan.github.io/post/20190513111048/</link>
      <pubDate>Mon, 13 May 2019 11:10:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190513111048/</guid>
      <description>原因分析 后面的错误Sub-process /usr/bin/dpkg returned an error code (2)是由于前面的一个错误引起的
因此，只需要解决前面的错误就行了
查找资料 解决这个错误其实很简单，只需要理解前面一个错误里面的empty filename就行了
我看过很多教程，说只要删除/var/lib/dpkg/info/x.list就可以了，我试过，每次删除，之后这个目录下面都会重新生成x.list文件
解决方案 之后我找到解决方案，发现只要把x.list改为x.list.broke就可以了，之后就没有empty filename的报错&amp;rdquo;</description>
    </item>
    
    <item>
      <title>阿里云免费ssl证书申请</title>
      <link>https://mannuan.github.io/post/20190502140132/</link>
      <pubDate>Thu, 02 May 2019 14:01:32 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190502140132/</guid>
      <description> 第一步：在阿里云申请域名  登录阿里云， 在搜索框中输入&amp;rdquo;域名 控制台&amp;rdquo;， 进行域名的购买或则注册。   我强烈不推荐购买阿里云的二手域名，虽然价格很便宜，但是大多数域名都有问题，比如被注册局暂停解析等等
 第二步：在阿里云申请免费的ssl证书  同样在搜索框中输入&amp;rdquo;dns 控制台&amp;rdquo;， 在域名的列表里面可以看到你已经购买的域名， 然后在列表的每个item中点击“更多”，出现&amp;rdquo;ssl&amp;rdquo;证书的字样，点击进去。 选择免费版的ssl证书（这里只能单个子域名进行注册） 点击申请，跳到ssl证书列表页面， 点击验证，大概过5-6分钟，ssl证书就可以审核通过， 下载证书我推荐下载nginx版本的，nginx配置域名最方便，配置域名的教程可以参看我的https服务器搭建详细教程(ubuntu系统实测可行)这个教程  </description>
    </item>
    
    <item>
      <title>linux如何查看文件夹占用磁盘空间</title>
      <link>https://mannuan.github.io/post/20190502134205/</link>
      <pubDate>Thu, 02 May 2019 13:42:05 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190502134205/</guid>
      <description>du -h -d 1  查看当前目录下面所有文件夹所占的空间
 </description>
    </item>
    
    <item>
      <title>https服务器搭建详细教程(ubuntu系统实测可行)</title>
      <link>https://mannuan.github.io/post/20190501225058/</link>
      <pubDate>Wed, 01 May 2019 22:50:58 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190501225058/</guid>
      <description>第一步：把指定的域名绑定到服务器指定的端口 1、安装nginx sudo apt-get install nginx  查看nginx版本，确认安装成功
nginx -v  安装完nginx以后，通过浏览器访问127.0.0.1，再次确认安装成功（访问127.0.0.1其实等价于访问127.0.0.1:80）  2、修改nginx配置文件 sudo vim /etc/nginx/nginx.conf  通过上面的命令打开文件以后，键盘按 “i” 键，进入编辑模式，然后找到类似下面的内容：   ssl的获取可以参看我的阿里云免费ssl证书申请
http { #在这里填写你的配置  #下面省略若干行..... }  完整的配置是这样的（第一个server配置的是http服务，第二个server配置的https服务）：  http { server { listen 80; server_name 指定的域名; root html; index index.html index.htm; location / { proxy_pass http://127.0.0.1:指定的端口/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &amp;#34;upgrade&amp;#34;; proxy_redirect off; } } server { listen 443; server_name 指定的域名; ssl on; root html; index index.</description>
    </item>
    
    <item>
      <title>linux修改设备名</title>
      <link>https://mannuan.github.io/post/20190501213953/</link>
      <pubDate>Wed, 01 May 2019 21:39:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190501213953/</guid>
      <description>只要修改两个文件：
 /etc/hostname
 /etc/hosts
  </description>
    </item>
    
    <item>
      <title>视频下载4大神器</title>
      <link>https://mannuan.github.io/post/20190404094748/</link>
      <pubDate>Thu, 04 Apr 2019 09:47:48 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190404094748/</guid>
      <description> 1、downie 可以下载🌎上面所有你想的到的视频网站的视频，而且下载速度很快。
2、ykdl 可以通过命令行下载爱奇艺的视频，还有其他网站的视频
3、you-get 4、youtube-dl </description>
    </item>
    
    <item>
      <title>在开启用户验证的情况下，如何登录mongodb用户</title>
      <link>https://mannuan.github.io/post/20190212155427/</link>
      <pubDate>Tue, 12 Feb 2019 15:54:27 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190212155427/</guid>
      <description> 1、以test用户和数据库admin为例：
 use admin db.auth(&amp;#34;test&amp;#34;,&amp;#34;test&amp;#34;) # 两个test分别是用户名和密码</description>
    </item>
    
    <item>
      <title>mongodb创建root和普通user</title>
      <link>https://mannuan.github.io/post/20190212154741/</link>
      <pubDate>Tue, 12 Feb 2019 15:47:41 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190212154741/</guid>
      <description>1、创建管理员，下面以用户test1为例：
use admin db.createUser({user: &amp;#34;test1&amp;#34;, pwd: &amp;#34;test1&amp;#34;, roles: [{role: &amp;#34;root&amp;#34;, db: &amp;#34;admin&amp;#34;}]}) 2、创建test2db对应的test2用户:
use test2db db.createUser({user: &amp;#34;test2&amp;#34;, pwd: &amp;#34;test2&amp;#34;, roles: [{role: &amp;#34;readWrite&amp;#34;, db: &amp;#34;test2db&amp;#34; }]})</description>
    </item>
    
    <item>
      <title>mongodb多实例启动和开启用户验证</title>
      <link>https://mannuan.github.io/post/20190212144306/</link>
      <pubDate>Tue, 12 Feb 2019 14:43:06 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190212144306/</guid>
      <description>在这里，我不废话，直接给出mongodb配置文件模板
# mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # Where and how to store data. storage: dbPath: mongodb数据库的路径（自己可以随便取，只要不与默认的一样就行了） journal: enabled: true # engine: # mmapv1: # wiredTiger: # where to write logging data. systemLog: destination: file logAppend: true path: mongodb日志路径（自己可以随便取，只要不与默认的一样就行了） # network interfaces net: port: 端口0~65536(不常用的端口可以随便取，不可以和默认的一样) bindIp: 0.0.0.0 # how the process runs processManagement: # timeZoneInfo: /usr/share/zoneinfo fork: false #开启用户认证 security: authorization: enabled #operationProfiling: #replication: #sharding: ## Enterprise-Only Options: #auditLog: #snmp:  </description>
    </item>
    
    <item>
      <title>linux创建用户并给用户sudo权限</title>
      <link>https://mannuan.github.io/post/20190211224353/</link>
      <pubDate>Mon, 11 Feb 2019 22:43:53 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190211224353/</guid>
      <description>这些年，我看了很多关于创建linux用户的博客。发现当中都是写了一大堆废话，都是复制粘贴的，而且介绍的一点都不全面，有些甚至直接是错误的。
我在这里将按如下步骤来详细的描述创建用户的过程。以用户名test为例：
1、
useradd -d /home/test -m test 上面表示的是创建一个名为test的用户，且同时给他在home目录下面创建了文件夹。
2、
passwd test 上面的命令是给test用户设置密码。
3、
usermod -s /bin/bash test 上面这段代码的含义是，把命令行的模式换为bash，默认是sh。你肯定会问为什么要这样，因为如果使用默认的sh，你打开终端的提示符显示的是$，不是“用户名$主机名”这种形式。
4、
usermod -a -G sudo test usermod -a -G adm test 上面这个代码的意思是，把test用户添加到sudo和admin用户组里面。这里要注意的是系统里面的admin的用户组的名字是&amp;rdquo;adm&amp;rdquo;。
还有，我经常看到博客说只要改/etc/sudoers文件就可以了。虽然这种方法可行，但是这种方法不利于管理用户。最重要的是，这种方法很low，很垃圾，我很看不起这种方法。做为高水平的技术人才，该装逼的地方还是要装逼的，这样才可彰显牛逼之处。
5、
groups test 上面这个命令的意思是检查test所在的用户组
6、
sudo su 首先，你要重新登录一下，然后输入上面这个命令，密码就是使用该用户的密码，然后你就发现可以sudo了，哈哈哈哈啊哈哈，这样你就成功了。</description>
    </item>
    
    <item>
      <title>mac修改默认终端为iterm2</title>
      <link>https://mannuan.github.io/post/20180830110337/</link>
      <pubDate>Thu, 30 Aug 2018 11:03:37 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180830110337/</guid>
      <description></description>
    </item>
    
    <item>
      <title>brew安装卡死原因</title>
      <link>https://mannuan.github.io/post/20180829101640/</link>
      <pubDate>Wed, 29 Aug 2018 10:16:40 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180829101640/</guid>
      <description>1.command line tools没有安装，如果执行在线安装的命令也卡死，请看我的上一篇博客的离线安装方法；</description>
    </item>
    
    <item>
      <title>mac command line tools离线安装</title>
      <link>https://mannuan.github.io/post/20180829101005/</link>
      <pubDate>Wed, 29 Aug 2018 10:10:05 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180829101005/</guid>
      <description>https://developer.apple.com/download/more/</description>
    </item>
    
    <item>
      <title>详解面向对象、构造函数、原型与原型链</title>
      <link>https://mannuan.github.io/post/20190806190331/</link>
      <pubDate>Mon, 06 Aug 2018 19:03:31 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190806190331/</guid>
      <description> 参考资料  链接 链接  </description>
    </item>
    
    <item>
      <title>正则表达式符号大全</title>
      <link>https://mannuan.github.io/post/20180731192512/</link>
      <pubDate>Tue, 31 Jul 2018 19:25:12 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180731192512/</guid>
      <description>字符 描述     \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。   ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。   $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。   * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。   + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。   ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。   {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。   {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。   {n,m} m和n均为非负整数，其中n&amp;lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。   ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。   . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“`(.   (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。   (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(   (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95   (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95   (?</description>
    </item>
    
    <item>
      <title>python教程之pip使用国内源</title>
      <link>https://mannuan.github.io/post/20180726111905/</link>
      <pubDate>Thu, 26 Jul 2018 11:19:05 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180726111905/</guid>
      <description>配置文件格式：  以阿里云为例
 [global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com  配置文件路径：  放置配置文件的位置各个操作系统各部相同，下面我将一一列举。
 linux系统: 超级用户： 如果存在/etc/xdg/目录，则使用/etc/xdg/pip/pip.conf路径；不存在使用/etc/pip.conf路径
普通用户： 使用.config/pip/pip.conf
mac系统: 超级用户： .config/pip/pip.conf 普通用户： .pip/pip.conf windows系统： 全局配置（win7及以上系统，这里文件名改为pip.ini）： C:\ProgramData\pip\pip.ini ###</description>
    </item>
    
    <item>
      <title>对mongodb的aggregate管道用法的理解</title>
      <link>https://mannuan.github.io/post/20180723195612/</link>
      <pubDate>Mon, 23 Jul 2018 19:56:12 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180723195612/</guid>
      <description>最近看了一些关于mongodb的教程，感觉很费力，尤其涉及到了一些复杂的操作。比如很多贴上了大段数据来描述样例、或者翻译了大段官方文档的文字，这些都让我感觉疲劳。 下面我用自己写的一些话来描述我对mongodb聚合的理解：
 注： &amp;lt;&amp;gt;用来标识变量（即里面的内容可以替换成其他），可以按照&amp;lt;&amp;gt;里面的单词的含义来理解下面的代码。
 例子：假设你有一组数据，需要按照顺序做这些操作：筛选、分组、求和，你可以用如下代码实现：
db.&amp;lt;collection_name&amp;gt;.aggregate([ {$match:key}, {$group:{_id:$&amp;lt;group_filed_name&amp;gt;, &amp;lt;dispaly_field_name&amp;gt;:{$first:&amp;lt;nonkey_name&amp;gt;}}}, {$group:{_id:null, &amp;lt;sum_name&amp;gt;:{$sum:$&amp;lt;sum_field_name&amp;gt;}}} ]).next().get(&#39;&amp;lt;sum_name&amp;gt;&#39;)    &amp;lt; key&amp;gt;表示用来筛选的关键字，它的里面结构形如
 {&amp;lt;key1_name&amp;gt;:&amp;lt;key1_value&amp;gt;, &amp;lt;key2_name&amp;gt;:&amp;lt;key2_value&amp;gt;, ...}   表示用来给数据分组的字段名称，其中 _id 是一个内置的关键字，在_id所在字段的值用来划分分组。
 表示最后输出的字段的名称，表示某个非关键字字段的名称
 在第二步分组操作做完显示的数据结构是这样的
 {_id:&amp;lt;group_field1_value&amp;gt;,  :}
 {_id:, :}
&amp;hellip;
  * 表示最后要显示的求和字段的名称，表示要求和的字段的名称,_id:null表示不分组，这里使用$group符号的原因是$sum必须在$group实现
 在求和之后数据的结构是这样的
 {_id:null,&amp;lt;sum_name&amp;gt;:&amp;lt;sum_value&amp;gt;}     从上面的例子，我们不难看出mongodb的聚合管道操作它允许分组、求和、筛选等等不同的操作依次进行，从代码里面使用了”[]“这个列表操作符，可以想像mongodb的聚合操作就像python的列表一样依次进行读取、操作，而且聚合操作允许重复多次进行的相同的操作。因此，我认为不管多复杂的操作只要分成一些基本操作，都可以用mongodb的聚合操作实现。</description>
    </item>
    
    <item>
      <title>算法题编码如何躲坑</title>
      <link>https://mannuan.github.io/post/20180723113409/</link>
      <pubDate>Mon, 23 Jul 2018 11:34:09 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180723113409/</guid>
      <description>   错误的代码 正确代码 备注     break; break 在任何语言中break后面都没有&amp;rdquo;;&amp;rdquo;
比如在牛客的在线js中会出现”数组越界的提示“   True和true
False和false 正确区分大小写 js中小写
python中大写    </description>
    </item>
    
    <item>
      <title>算法题读题注意点</title>
      <link>https://mannuan.github.io/post/20180723093847/</link>
      <pubDate>Mon, 23 Jul 2018 09:38:47 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180723093847/</guid>
      <description> 算法题尤其要注意细节
    描述 解读 备注     非减排序的数组 包含了两种情况：
1. 递增
2.数字保持不变 剑指offer-06-翻转的数组   若干个 表示\(\geq 0\) 剑指offer-06-翻转的数组   计算机浮点数之间的误差在-0.0000001和0.0000001之间，两个数相等 计算机浮点数存在误差    高效的算法基本上最多使用两个指针     链表问题的关键点：
1.确定头节点；
2.保存上一个指针的状态；     循环问题的解决思路 找到前后不变的状态作为终止条件    具有很多标志位的问题 必须找到不变的规律(终止条件)    做二叉树类型的题目 必用递归 因为二叉树太复杂了，一般在面试的时候不用非递归实现    </description>
    </item>
    
    <item>
      <title>机器学习面试知识点一(无监督和有监督算法的区别)</title>
      <link>https://mannuan.github.io/post/20180720170528/</link>
      <pubDate>Fri, 20 Jul 2018 17:05:28 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180720170528/</guid>
      <description>对监督学习的理解： 监督学习，通俗来讲就是分类，就是把训练样本，在某种评价下得到最佳的模型，然后再利用这个模型将输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的。在人对事物的认识中，我们从孩时就被大人们教授这是鸟，那是房子等等。我们所见到的景物就是输入数据，而大人们对这些事物的判断结果就是相应的输出。当我们见识多了以后，脑子就慢慢地得到了一些泛化的模型，这就是训练得到的那个函数，从而没有大人在旁边指点的时候，我们就可自己分辨哪些是房子，哪些是鸟。
对无监督学习的理解： 它与非监督学习的不同之处，在于我们事先没有任何训练样本，而直接对数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知,但是欣赏完多幅作品之后，我们也能把它们分成不同的派别。比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分成两个类。无监督学习的里典型的例子就是聚类。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法只需要知道如何计算相似度就可以开始工作了。</description>
    </item>
    
    <item>
      <title>个人简历</title>
      <link>https://mannuan.github.io/post/20180704142218/</link>
      <pubDate>Wed, 04 Jul 2018 14:22:18 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20180704142218/</guid>
      <description>联系方式  手机：13588796263 Email：wujunleiwang@gmail.com 微信号：bubaizhansheng  个人信息   吴俊磊/男/1994 本科/西南民族大学/网络工程 硕士/杭州电子科技大学/计算机科学与技术 技术博客：https://mannuan.github.io Github：http://github.com/mannuan 期望职位：Web前端初级程序员 期望城市：杭州       校园项目经历 研究生期间 智慧旅游-爬虫管理系统 (2018年1月~2018年8月)  项目描述：对大众点评、携程和马蜂窝等旅游网站进行爬虫，并用页面展示数据； 项目职责：  对python库selenium进行封装，爬取动态网页； 使用ip代理和爬虫策略解决服务器403拒绝请求问题； 使用预先加载cookie的方式，解决登录验证问题； 总结爬虫的字体反爬和css反爬的解决方案； 使用mongodb存储数据，并使用aggregate查询数据； 使用基于nodejs的koa作为web后端开发框架，接收post和get请求； 使用vue和element-ui完成页面的布局，利用ajax进行数据解析显示和查询；  项目成果：  每天可以稳定的爬取几万条数据。在几十万条数据中，从数据的查询到页面完成数据加载花费的时间不超过3秒。   河长信息管理系统-爬虫脚本开发 (2017年10月~2018年1月)  项目描述：对万方数据、浙江省水利厅和百度百科等含有河流信息的网站进行爬虫； 项目职责：  使用pyspider作为爬虫框架，编写爬虫脚本； 使用正则表达式编写一套通用的爬虫脚本模板； 制定爬虫策略解决服务器403拒绝请求的问题；  项目成果：在该系统上线以后，每天都可以稳定地获取到最新的数据。  本科阶段 基于LLDP协议捎带式服务质量采集机制(2016年3月~2017年3月)  项目描述：这是一个软件定义网络的创新项目，目的是在占用少量的网络带宽的情况下，使用链路发现协议(LLDP)来传递网络的服务质量信息(QoS)。 项目职责：  在网络控制器Floodlight上创建一个修改LLDP数据包结构的模块； 修改虚拟网络交换机Vswitch的源代码，把网络QoS信息填写到LLDP数据包中； 使用网络仿真器Mininet，完成网络的一键式部署； 使用jquery和dataTable等javascript库完成页面布局，使用ajax异步加载网络的QoS信息；  项目成果：  在2016年的第三届全国高校软件定义网络（SDN）应用创新开发大赛中获得了二等奖。 发表了一篇sci 4区的论文-The Top-K QoS-aware Paths Discovery for Source Routing in SDN。我是这篇论文的第二作者，我对这篇论文的主要贡献就是提高实验数据。   技能清单 以下均为我熟练使用的技能</description>
    </item>
    
  </channel>
</rss>