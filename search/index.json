[{"content":" The Golden Rule is that there are no golden rules.  — Fuller\n ","href":"/","title":"Home"},{"content":"","href":"/post/","title":"Blog"},{"content":"","href":"/docs/","title":"Documentation"},{"content":" Here is a paragraph. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nHeading 2 Another one. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\nHeading 3 Yet another, but centered! Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Heading 4  First item Second item  Nested unordered item  Third item  Nested ordered item 1 Nested ordered item 2   Heading 5 Where are the quotes!!!\n Simplify, then add lightness.\n— Colin Chapman\n Now, time for some links!\n GoHugo  Hugo Themes   Heading 6 Inline code: echo \u0026quot;What is the meaning of life?\u0026quot;. Who knows?\n// Codeblock  var meaningOfLife = 42; console.log(\u0026#39;The meaning of life is: \u0026#39;, meaningOfLife);  Who wants some table?\n   Minimo Caption More Caption     Cool What? Now, wut?!    Ah, enough for today, eh?\n","href":"/typography/","title":"Typography"},{"content":"Mínimo is a Spanish word that roughly translate to Minimal.\nMinimo is a minimalist theme for Hugo.\nMinimo keeps the focus on your content and lets it shine!\n","href":"/about/","title":"About"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/categories/ide/","title":"ide"},{"content":"","href":"/authors/mannuan/","title":"mannuan"},{"content":"","href":"/tags/vscode/","title":"vscode"},{"content":" 设置中文环境  刚开始的时候vscode默认是英文环境 \\(\\Uparrow\\) + command + P 输入configure language 点击zh-cn  ","href":"/post/20190801090920/","title":"vscode常用设置"},{"content":"","href":"/tags/%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","title":"常用设置"},{"content":"","href":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"二叉树"},{"content":" 二叉排序树  又称为二叉排序树，或二叉搜索树\n 如果它的左子树不为空，那么左子树上所有的结点值都小于它的根结点的值；如果它的右子树不为空，那么右子树上所有的结点值都大于它的根节点的值。\n二叉树的前序遍历 ","href":"/post/20190726162722/","title":"二叉树的知识点整理"},{"content":"","href":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":"","href":"/tags/%E5%8E%9F%E7%A0%81/","title":"原码"},{"content":" 编码方式 对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是计算机存储一个具体数字的编码方式。\n存储方式 数值在计算机是以补码的方式存储的。\n机器数 一个数在计算机中的二进制表示形式，比如补码就是机器数的形式。\n格式 机器数分为两部分：符号位和数据部分。\n符号位 正数为0，负数为1；\n 例1: 在字长为8位的计算机中，十进制的\u0026rdquo;+2\u0026rdquo;，转换为二进制为\u0026rdquo;00000010\u0026rdquo;。 例2: 在字长为8位的计算机中，十进制的\u0026rdquo;-2\u0026rdquo;，转换为二进制为\u0026rdquo;10000010\u0026rdquo;。  机器数的真值 带符号位的机器数对应的真正数值。\n原码 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值；\n反码 反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反；\n补码 补码的表示方式是：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）\n举例:\n   十进制数 原码 反码 补码     85 01010101 01010101 01010101   -85 11010101 10101010 10101011   9 00001001 00001001 00001001   -9 10001001 11110110 11110111    使用补码的原因 反码的来历 计算机底层只有加法器，不支持减法运算，在进行减法运算，会转换为加法运算。即：1-1=1+(-1)。为了解决这个问题，不得不让符号位参与运算，从而产生了反码。\n补码的来历 在用反码进行计算时，出现了\u0026rdquo;0\u0026rdquo;这个特殊的数值，0带符号是没有任何意义的。即有\u0026rdquo;00000000\u0026rdquo;和\u0026rdquo;10000000\u0026rdquo;两个编码表示0。于是设计了补码，负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码到的问题：用\u0026rdquo;00000000\u0026rdquo;表示0，用\u0026rdquo;10000000\u0026rdquo;表示-128。\n 注意：-128实际上是使用-0的补码来表示的，所以-128并没有原码和反码。而使用补码之后，就修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用补码表示的范围为[-128, 127]。\n 更加详细的解释\n","href":"/post/20190723204549/","title":"原码，反码和补码"},{"content":"","href":"/tags/%E5%8F%8D%E7%A0%81/","title":"反码"},{"content":"","href":"/tags/%E8%A1%A5%E7%A0%81/","title":"补码"},{"content":"","href":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","title":"计算机基础"},{"content":"","href":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","title":"计算机组成原理"},{"content":"iText - OCR \u0026amp; Translator\n","href":"/post/20190723090032/","title":"MAC下OCR识别文字的软件"},{"content":"","href":"/categories/mac/","title":"mac"},{"content":"","href":"/tags/ocr/","title":"ocr"},{"content":"","href":"/tags/%E5%B7%A5%E5%85%B7/","title":"工具"},{"content":" 摘要 该语料库有130万条讽刺性陈述 - 比之前的数据集多10倍 - 并且比非讽刺陈述的例子多几倍，允许在平衡和不平衡的标签系统中学习。每个语句都是自我注释的 - 具有讽刺意味的是作者，而不是独立的注释者 - 并提供用户，主题和对话上下文。\n介绍 讽刺检测在数据集中的例子很少、人类难以辨别和现有的数据集平衡的数据标签（数据标签大致相同）这些原因，所以检测讽刺很难。\n我们提供了一个用于具有不平衡和自注释标签的讽刺检测的语料库。因为Reddit的评论结构以及经常使用和标准化的讽刺注释。有超过100万个讽刺的例子，每个例子都提供了作者，主题和上下文信息。\n我们在第3节讨论了语料库结构和相关统计数据，在第4节手动评估我们语料库的噪声，第5节，我们为讽刺检测系统构建合适的基准，并检查这些子集上的简单基线方法和人类评估者的表现。\n相关工作 由于我们的主要贡献是语料库而不是讽刺检测方法。\n反讽数据集会有很大的区别，由于获取讽刺或非讽刺陈述的来源，手工标注的数量，和数据集平衡与否。Wallace et al.(2015) 等人使用不平衡的标签，它们不利用自我注释的标签并生成了大约10000各个手工标注的句子。推特的数据集也被用的很多，由于#sarcasm, #notsarcasm和#irony等主题提供了自注释。4.2节提到的，Twitter的缩写语言和其他属性使其变得不那么吸引人。虽然，Twitter是目前最大的原始数据来源并且之前都致力于不平衡的语料库。另外一个评论来源是IAC,这个语料库可以进一步通过人类或机器学习注释为讽刺，大概有产生了10000个带标签的陈述。\n语料库细节 Reddit数据集的结构和注释 reddit是一个社交媒体网站，用户通过帖子中的评论进行交流，每一个评论包含了嵌入式媒体，外部链接，和文字，这些发布在指定主题模块的帖子被称为subredddits;这些subreddits包含了搞笑，图片，科学。用户对提交和其他评论进行评论，从而产生了类似树的会话结构。我们把reddit树中的任何节点称为元素（即提交或评论）\nreddit用户采用了常用的讽刺注释方法，在讽刺语句的末尾标记\u0026rsquo;/s\u0026rsquo;;这个标记来源于\u0026lt;sarcasm\u0026gt;\u0026lt;/sarcasm\u0026gt;。和Twitter主题标签一样，使用这些标记作为讽刺的指标是嘈杂的，特别是很多用户不使用标记，不知道是不是讽刺，仅仅在讽刺意图不明显的地方使用它，我们在4.1节讨论这种噪音的程度。\n构造SARC 我们使用网络爬虫抓取数据，去除了噪音数据。对于每个评论，我们提供一个讽刺标签，作者，subreddit, 用户投票的评论分数，评论的日期，以及回到原始数据集所有评论的标识符。\n为了减少噪音，我们使用多个滤镜来消除噪音和无信息的评论。其中许多是标准的预处理步骤，例如排除URL和字符限制在ASCII中。为了处理Reddit数据，我们还排除了作为对话树中的讽刺评论后代的评论，因为在这种表达下，注释非常嘈杂，没有标记作者是否同意先前自己的讽刺表达的讽刺与否。\n我们的原始语料库包含了三个文件： 1. 一种CSV格式的数组，包含5.33亿条评论，其中约130万条是讽刺性的。此文件仅包含作者了解标准讽刺注释的注释；这取决于他们是否在评论发布的同一个月或之前使用过注释。添加此限制是为了减少由于作者为注释其讽刺而导致的漏报。每行还包含父注释。 2. 第二个是json格式的哈希表，包含讽刺评论的对话线程中的所有评论和帖子以及所有讽刺评论的兄弟姐妹。 3. csv格式的数组，每行包含一系列导致讽刺的评论，对该序列中的最后一个元素进行(讽刺和非讽刺)的响应。每个元素都作为前一个文件的键。\n这种原始语料库非常大，适用于大规模机器学习和统计分析，以及用于评估讽刺检测系统的较小基准任务。这些基准，无论是在平衡还是不平衡的情况下，都需要对语料库进行进一步的子采样，以及在稀疏信号面前处理噪声数据的方法。我们在5.1节评估了这样的方法，然后在输出上评估学习算法。\n语料库评估 评估我们的语料库有三个主要的衡量指标：（1）规模，（2）讽刺与非讽刺评论的比例，以及（3）误报率和漏报率。令人感兴趣的还有语料库中的文本质量以及其对其他NLP任务的适用性。因此，在本节中，我们评估原始语料库中的错误，并提供与用于构建讽刺数据集的其他语料库的比较。我们还讨论了我们方法的潜在局限性。\n手动评估 为了研究使用Reddit作为自我注释讽刺来源的嘈杂，我们估计了由我们的过滤引起的假阳性和假阴性的比例。 这是通过手动检查来自SARC标记为讽刺和500标记为非讽刺的500条评论的随机子集来完成的，并且可以完全访问评论的上下文。 如果“/ s”标签不是注释而是句子的一部分，并且如果评论作者明显对人类评估者讽刺，则评论被确定为误报。 该程序产生1.0％的假阳性率和2.0％的假阴性率。 虽然假阳性率是合理的，但假讽率与讽刺比例（0.25％）相比是显着的，表明讽刺的工作定义存在很大差异，并且需要能够处理不平衡设置中的噪声数据的方法。 在平衡设置中，这仍然是相当少量的噪音。\n与其他数据源进行比较 如前所述，Twitter在以前的语料库中是最常见的讽刺来源; 这可能是由于其主题标签提供的显式注释。 然而，使用Reddit作为讽刺评论的来源具有许多研究优势。 与不受长度约束且包含较少主题标签的Reddit注释不同，推文是用缩写英语编写的。 Hashtagged标记也经常被用作语句本身的一部分（例如“那是#sarcasm”），模糊了文本和注释之间的界限; 在Reddit上，“/ s”通常仅在用作注释时用作注释以外的其他东西（例如“你忘了/ s”）。 由于单个帖子的浅树结构及其注释，Reddit上的完整对话上下文也更容易提供。\n此外，从2014年7月的Twitter和Reddit数据的子样本中，我们确定Twitter作者中使用讽刺注释（＃sarcasm，＃sarcastic或#sarcastictweet）的百分比（.002％对.927％）要小得多。 我们假设Reddit用户需要更频繁地以更标准化的形式进行讽刺注释，因为它们主要是匿名的，因此不能依赖共享的上下文来传达讽刺。 最后，Reddit还受益于subreddits，它可以基于明确的主题分配实现特征化和数据探索。\nInternet Argument Corpus（IAC）也被用作讽刺评论的来源（Walker等，2012）。 语料库开发人员发现IAC中有12％的例子是讽刺性的，这对于讽刺检测来说比我们的更好。 由于Reddit数据由任意对话组成，而不仅仅是参数，因此即使考虑到假阴性，我们的讽刺百分比也要小得多也就不足为奇了; 此属性还使我们的数据集更加真实。 与Reddit和Twitter不同，IAC还需要手动注释讽刺。\n我们方法的局限性 我们收集自注释讽刺数据集的方法有一些值得注意的局限性。 尽管我们努力过滤嘈杂的“/s”标签，但仍存在没有简单规则可靠地消除不正确标签的情况。 我们描述了误报和漏报的困难： * 误报是由于存在“/ s”标记而将评论错误地标记为讽刺的情况。 这种情况仅在评论中出现“/ s”标签时出现，其含义与指示讽刺有所不同。 如前所述，如果用户不知道“/ s”符号，则更有可能发生这种可能性。 类似地，如果“/ s”用于指代其用作注释的约定，那么仅仅检测“/ s”字符串的简单方法也会失败。 最后，“/ s”可能还有其他含义：例如，在HTML中，\u0026lt;s\u0026gt; ... \u0026lt;/s\u0026gt;表示删除。 因此，例如，专注于网络编程讨论的子编辑可能包括“/ s”以不同含义使用的实例。 为了解决第一个问题，我们通过确保他们之前使用过“/ s”来限制用户了解讽刺符号。 此过滤器有助于确保用户了解“/ s”的语义用法。 对于第二种情况，我们只保留评论末尾带有“/ s”的评论。 我们检查的所有以“/ s”结尾的注释都使用注释来表示讽刺。 第三种情况相当于解决词义消歧，我们没有找到一种简单的方法来减少这种形式的噪音。 然而，通过限制已知不具有“/ s”（例如，政治）的替代意义的子编辑，可以降低这种形式的感觉不匹配的可能性。\n 假阴性是评论是讽刺性的，但没有用“/ s”注释的情况。 假阴性比假阳性更难检测，因为没有讽刺注释的评论部分比做出的部分要大得多。 有两种主要方式可能出现假阴性：用户不知道“/ s”约定，或者用户认为他们对讽刺的使用明显足以保证不包括标签。 值得注意的是，这种信念取决于用户正在进行通信的社区，用户正在与之通信的用户（他们经常与之争吵的另一个用户，或陌生人），以及先前对该线程的评论。 如前所述，讽刺性的评论经常会产生一系列随后的评论，这些评论都是讽刺性的，但缺乏“/ s”符号。 简而言之，上下文对于确定讽刺性评论是否显而易见至关重要。 我们的第一个过滤器解决了第一个问题。 第二个问题很难解决，仍然是我们方法的局限。 我们通过在线程中丢弃讽刺评论的子评论来避免讽刺评论链的特定情况。  我们所有的过滤器都通过手动评估第4.1节中描述的误报率和误报率进行验证，这在实施过滤器后得到了显着改善。 我们的手动评估方法有一个中心限制：虽然我们为人类注释者提供本地背景，但如果区分评论的讽刺意图的能力依赖于评论者的评论历史或相关新闻的知识，那么人类注释者可能 表现不佳。 我们试图通过使用投票方案来解决这个问题，该投票方案要求几个人同意关于其背景的评论是否是讽刺性的。\n讽刺检测的基准 我们语料库的直接应用是用于训练和评估讽刺检测系统。 因此，我们使用第3节中描述的原始语料库来构建几个有用的基准，用于将语句分类为讽刺或非讽刺。 所有基准测试都提供了完整的会话线程，其中包括学习算法的目标语句以及注释元数据。 根据他们的规范，我们考虑一些无上下文的基线方法，仅依赖于简单特征的线性分类。 重现我们的结果的代码在https://github.com/NLPrinceton/SARC中提供。\n评估任务 在最一般的情况下，我们使用提供的原始文件来构建系统的数据点以学习以下任务：给定一个帖子和一系列注释，确定对序列中最后一个注释的响应中的哪些注释是讽刺性的。 因此，每个数据点由一个会话线程和一系列响应和讽刺标签组成。 此任务的表现以平均精确度，召回率和F1分数来衡量。 在构建这个子类之前，我们首先考虑所有非完整句子而不是2到50个令牌之间的注释，以便在评估中提供更清晰的评论。 尽管响应仍然主要是非讽刺的，但是这里的讽刺评论的比例要大得多，因为每个数据点必须对应于至少发生一个讽刺注释的线程。 总共我们构建了844万个序列，其中讽刺反应的平均比例为28.1％。\n平衡的标签 我们通过从评论序列的每组响应中仅采用一个讽刺和一个非讽刺的响应来构建平衡的学习任务。 然后，任务变为选择共享上下文的两个语句中的哪一个是讽刺性的，其中性能通过准确度来衡量。 虽然只有至少有一个讽刺反应的帖子是有用的，但它也会增加假阴性率，因为评论需要讽刺性反应时经常会得到其他讽刺性陈述，这些陈述内容与标记的讽刺回应相似，但本身可能没有标注。 因此，为了在选择非讽刺陈述时减少这个问题，我们使用常用爬行GloVe嵌入单词的归一化总和来强调所有陈述，并仅从那些与讽刺陈述具有相似性≤0.95的非讽刺陈述中挑选（Pennington et al., 2014）。\n政治 检测讽刺的难度不仅取决于理解先前陈述的背景的需要，而且取决于理解所讨论主题的背景信息。 甚至人类也会挣扎于从不熟悉的主题中汲取的讽刺性评论，例如，晦涩的爱好或艺术形式。 因此，我们还在仅从政治子评级中提取的评论上测试人和机器的表现，这是一个所有评估者都有足够背景信息的主题。 该子样本包含17000个序列，讽刺响应的平均比例为23.2％\n方法 对于平衡标签的情况，上述任务的简单，无背景基线方法是对两个响应进行特征化，并训练逻辑回归分类器以区分讽刺和非讽刺响应。类。 在测试集上，我们选择具有被标记为讽刺的概率最高的响应作为讽刺性的响应。 我们将我们测试的两个数据集分成80％ - 20％在训练测试子集之间，并在表2中报告以下三种方法的结果。\nBag-of-n-Grams Bag-of-n-Grams表示包括使用文档的n-gram计数作为向量中的要素。 我们测试了两种变体，Bag-of-Words和Bag-of-Bigrams。 对于包含所有subreddits的子样本，我们仅使用在训练评论中至少出现5次的那些特征。 我们考虑包括其他评论功能，例如评论长度和分数，但实证结果和这些特征的分布（见图3和图4）表明它们不是特别提供信息。 更复杂的特征化，例如（Wallace等，2014）提出的名词短语和特征交互指标，留待未来的工作。\n句子嵌入 给定一个文档，采用其单词嵌入的元素总和提供了一个简单的低维文档表示。 这种构建单词序列特征的特定技术先前已经被研究并建立为多个受监督的NLP预测任务的强基线（Arora等，2017）。 我们使用在亚马逊产品语料库上训练的1600维GloVe表示，由于情感和讽刺之间的语义接近而使用它代替共同爬行（McAuley等，2015）。\n手工 通过给5个人类评估者100个样本并要求他们执行与算法相同的任务来测量人类讽刺检测性能：确定两个陈述中的哪一个是讽刺性的。 我们提供了完整语料库5以及政治子评估6的评估链接。 提供了完整的背景，最终的人类分类器被视为所有5名评估员的多数投票。\n随机 我们使用一个简单的基线，其中所有响应都以固定概率随机且独立地标记为讽刺。 选择该概率作为训练集中讽刺的响应的平均分数。\n结果 基准线 表2中的基线表现相当好，并且比随机基线好得多，但它们都不匹配任何数据集上的人类表现。 机器学习方法有明显的改进空间，首先是使用提供的上下文来做出更好的讽刺决策。 如表2所示，Bag-of-Word和Bag-of-Bigram表示比句子嵌入表现更好; 但是，在未来的方法中结合上下文可能需要分布式表示。\n手工 正如预期的那样，与基线方法相比，人类评估员在多数和平均水平上表现得更好。 注释者之间存在显着但不完美的一致性：在主要数据集上，Fleiss kappa评分（Fleiss，1971）为0.5，表明中等一致，而在政治子样本上则为0.67，表明达成了实质性协议。 有趣的是，虽然从所有次级数据中抽取的序列的平均人类表现平均比政治子样本更差，但在人类中获得多数投票导致前者的表现更好。 这种性能提升表明，虽然个人可能没有足够的上下文来讨论Reddit的所有讨论主题，但总体上有足够的信息可以做得很好，甚至超过政治等知名话题的表现。\n结论 我们引入了一个基于自带注释的Reddit注释的大型讽刺数据集。 原始数据和评估子样本都是免费提供的，前者有超过100万个讽刺句子，比任何现有数据集都大。 我们评估简单机器学习方法的基线性能，并将其与人类表现进行比较。 我们希望该数据集的未来用户能够改进这些基准并找到利用我们提供的大量自注释信息的新方法。\n","href":"/post/20190722090749/","title":"A Large Self-Annotated Corpus for Sarcasm"},{"content":"","href":"/tags/%E5%8F%8D%E8%AE%BD/","title":"反讽"},{"content":"","href":"/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/","title":"数据集"},{"content":"","href":"/tags/%E7%BF%BB%E8%AF%91/","title":"翻译"},{"content":"","href":"/categories/%E8%AE%BA%E6%96%87/","title":"论文"},{"content":"","href":"/post/20190722084636/","title":"反讽论文的研究反向"},{"content":"","href":"/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/","title":"研究方向"},{"content":"","href":"/tags/%E8%AE%BD%E5%88%BA/","title":"讽刺"},{"content":"","href":"/tags/http%E5%8D%8F%E8%AE%AE/","title":"http协议"},{"content":" 前言 前端工程师打交道最多的就是浏览器，不管做什么都离不开浏览器，其中HTTP协议往往会被我们忽略，但其实资源缓存、CDN加载、页面性能优化等等都离不开对HTTP协议的了解。\n介绍 HTTP也叫作超文本传输协议，全称：Hyper Transfer Protocol。最初HTTP只能传输HTML文件，慢慢的现在可以传输文字、图像、视频和各种文件。 HTTP是无状态的：同一个客户端，连续发起多次请求，对HTTP服务器来说，都是新的请求，HTTP没办法知道来自一个客户端。\n消息结构 Header  分为request/response line和request/response header。\n  request/response line：包括请求的方法Method（GET/POST）、请求资源的路径path to resource和http协议的版本号。 request/response header：这边就是各种请求头了。  Body 响应体，一般是HTML文件。如果是get请求，是没有响应体的。\nHTTP请求方法 GET 请求获取Request-URI所标识的资源\nPOST 在Request-URI所标识的资源后附加新的数据\nHEAD 请求获取由Request-URI所标识的资源的响应消息报头\nPUT 请求服务器存储一个资源，并用Request-URI作为其标识\nDELETE 请求服务器删除Request-URI所标识的资源\nTRACE 请求服务器回送收到的请求信息，主要用于测试或诊断\nCONNECT 保留将来使用\nOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n对于我们来说，常用的就是GET、和POST。再次声明，不用表单提交，get不存在跟post比较有安全性问题。\nHTTP状态码 1XX 提示信息 - 表示请求已被成功接收，继续处理。\n2XX 成功 - 表示请求已被成功接收，理解，接受\n3XX 重定向 - 要完成请求必须进行更进一步的处理\n4XX 客户端错误 - 请求有语法错误或请求无法实现\n5XX 服务器端错误 - 服务器未能实现合法的请求\n状态码很多，可以自行了解，我觉得有几个是必须知道的。\nHTTP通信过程：根据URL查询DNS、查找服务器、建立TCP连接、发送请求、服务器响应。 总结 对于HTTP，我觉得基础的要知道HTTP是无状态的、HTTP的消息结构、基本请求方法、基本状态码这四部分。\n","href":"/post/20190717220231/","title":"http协议"},{"content":"","href":"/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","title":"前端开发"},{"content":"/** * 冒泡，插入，选择排序 * * Author: nameczz */ // 冒泡排序 const bubbleSort = (arr) =\u0026gt; { if (arr.length \u0026lt;= 1) return for (let i = 0; i \u0026lt; arr.length; i++) { let hasChange = false for (let j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { const temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp hasChange = true } } // 如果false 说明所有元素已经到位  if (!hasChange) break } console.log(arr) } // 插入排序 const insertionSort = (arr) =\u0026gt; { if (arr.length \u0026lt;= 1) return for (let i = 1; i \u0026lt; arr.length; i++) { const temp = arr[i] let j = i - 1 // 若arr[i]前有大于arr[i]的值的化，向后移位，腾出空间，直到一个\u0026lt;=arr[i]的值  for (j; j \u0026gt;= 0; j--) { if (arr[j] \u0026gt; temp) { arr[j + 1] = arr[j] } else { break } } arr[j + 1] = temp } console.log(arr) } // 选择排序 const selectionSort = (arr) =\u0026gt; { if (arr.length \u0026lt;= 1) return // 需要注意这里的边界, 因为需要在内层进行 i+1后的循环，所以外层需要 数组长度-1  for (let i = 0; i \u0026lt; arr.length - 1; i++) { let minIndex = i for (let j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[minIndex]) { minIndex = j // 找到整个数组的最小值  } } const temp = arr[i] arr[i] = arr[minIndex] arr[minIndex] = temp } console.log(arr) } const test = [4, 5, 6, 3, 2, 1] bubbleSort(test) const testSort = [4, 1, 6, 3, 2, 1] insertionSort(testSort) const testSelect = [4, 8, 6, 3, 2, 1, 0, 12] selectionSort(testSelect) ","href":"/post/20190717114226/","title":"冒泡、选择、插入排序"},{"content":"","href":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"排序算法"},{"content":" 摘要  The literature in automated sarcasm detection has mainly focused on lexical-, syntactic- and semantic-level analysis of text. However, a sarcastic sentence can be expressed with contextual presumptions, background and commonsense knowledge. In this paper, we propose a ContextuAl SarCasm DEtector (CASCADE), which adopts a hybrid approach of both content- and context-driven modeling for sarcasm detection in online social media discussions. For the latter, CASCADE aims at extracting contextual information from the discourse of a discussion thread. Also, since the sarcastic nature and form of expression can vary from person to person, CASCADE utilizes user embeddings that encode stylometric and personality features of users. When used along with content-based feature extractors such as convolutional neural networks, we see a significant boost in the classification performance on a large Reddit corpus.  自动讽刺检测的文献主要集中在文本的词法，句法和语义层面分析。 然而，讽刺性的句子可以用语境假设，背景和常识知识来表达。 在本文中，我们提出了一个ContextuAl SarCasm检测器（CASCADE），它采用内容和上下文驱动建模的混合方法，用于在线社交媒体讨论中的讽刺检测。 对于后者，CASCADE旨在从讨论主题的话语中提取上下文信息。 此外，由于讽刺性质和表达形式因人而异，CASCADE利用用户嵌入来编码用户的风格和个性特征。 当与基于内容的特征提取器（如卷积神经网络）一起使用时，我们看到大型Reddit语料库的分类性能得到显着提升。 \n Sarcasm is a linguistic tool that uses irony to express contempt. Its figurative nature poses a great challenge for affective systems performing sentiment analysis (Cambria et al., 2017). Previous research in automated sarcasm detection has primarily focused on lexical and pragmatic cues found in sentences (Kreuz and Caucci, 2007). In the literature, interjections, punctuations, and sentimental shifts have been considered as major indicators of sarcasm (Joshi et al., 2017). When such lexical cues are present in sentences, sarcasm detection can achieve high accuracy. However, sarcasm is also expressed implicitly, i.e., without the presence of such lexical cues. This use of sarcasm also relies on context, which involves the presumption of commonsense and background knowledge of an event. When it comes to detecting sarcasm in a discussion forum, it may not only be required to understand the context of previous comments but also the necessary background knowledge about the topic of discussion. The usage of slangs and informal language also diminishes the reliance on lexical cues (Satapathy et al., 2017). This particular type of sarcasm is tough to detect (Poria et al., 2016).  讽刺是一种语言工具，用讽刺来表达蔑视。它的比喻性质对进行情绪分析的情感系统提出了巨大的挑战（Cambria等，2017）。以前关于自动讽刺检测的研究主要集中在句子中的词汇和语用提示（Kreuz和Caucci，2007）。在文献中，插入，标点和感情变化被认为是讽刺的主要指标（Joshi等，2017）。当句子中存在这样的词汇提示时，讽刺检测可以实现高精度。然而，也暗示地表达了讽刺，即没有这种词汇提示。这种讽刺的使用也依赖于语境，其涉及对事件的常识和背景知识的推定。在讨论论坛中检测讽刺时，可能不仅需要了解先前评论的背景，还需要了解有关讨论主题的必要背景知识。俚语和非正式语言的使用也减少了对词汇线索的依赖（Satapathy等，2017）。这种特殊类型的讽刺难以察觉（Poria等，2016）。 \n Contextual dependencies for sarcasm can take many forms. As an example, a sarcastic post from Reddit1, “I’m sure Hillary would’ve done that, lmao.” requires background knowledge about the event, i.e., Hillary Clinton’s action at the time the post was made. Similarly, sarcastic posts like “But atheism, yeah that’s a religion!” requires the knowledge that topics like atheism often contain argumentative discussions and, hence, they are more prone towards sarcasm.  讽刺的上下文依赖可以采取多种形式。 作为一个例子，来自Reddit1的讽刺帖子，“我确信希拉里会做到这一点，lmao。”需要有关事件的背景知识，即希拉里克林顿在帖子制作时的行动。 同样，讽刺性的帖子如“但无神论，是的*那是一种宗教！”需要知道像无神论这样的话题经常包含争论性讨论，因此，他们更倾向于讽刺。 \n  这项工作的主要目的是在在线论坛中进行讽刺检测。特别是，我们提出了一个名为CASCADE的混合网络，它利用了讽刺检测所需的内容和上下文。它首先以两种方式处理上下文信息。首先，它执行用户分析以创建捕获讽刺的指示性行为特征的用户嵌入。最近的研究结果表明，对用户及其偏好的这种建模对于给定的任务非常有效（Amir等，2016）。它利用用户的历史帖子来模拟他们的写作风格（样式）和个性指标，然后使用多视图融合方法将其融合到综合用户嵌入中，称为典型相关分析（CCA）（Hotelling，1936）。其次，它从讨论论坛中的评论话语中提取背景信息。这是通过属于同一论坛的这些合并评论的文档建模来完成的。我们假设这些话语特征将提供重要的语境信息，背景线索以及检测讽刺所需的主题信息。 \n After the contextual modeling phase, CASCADE is provided with a comment for sarcasm detection. It performs content-modeling using a convolutional neural network (CNN) to extract its syntactic features. This CNN representation is then concatenated with the relevant user embedding and discourse features to get the final representation which is used for classification. The overall contribution of this work can be summarized as:  在上下文建模阶段之后，CASCADE会提供一个用于讽刺检测的注释。 它使用卷积神经网络（CNN）执行内容建模以提取其语法特征。 然后将该CNN表示与相关用户嵌入和话语特征连接以获得用于分类的最终表示。 这项工作的总体贡献可归纳为：   我们提出了一种新颖的混合讽刺检测器CASCADE，它对内容和上下文信息进行建模。   我们模拟用户的风格和个性细节以及讨论论坛的话语特征，以学习信息性的上下文表示。 在大型Reddit语料库上进行的实验表明，与最先进的自动化讽刺探测器相比，性能有了显着提高。   \n相关工作   自动讽刺检测是一个相对较新的研究领域。 以前的作品可以分为两大类：基于内容和上下文的讽刺检测模型。 \n基于内容的模型   这些网络将讽刺检测问题建模为标准分类任务，并试图找到词汇和实用指标来识别讽刺。许多作品采取了这条道路，并提出了创新的方法来挖掘讽刺的有趣线索。泰珀曼等人。 （2006）使用韵律和光谱线索调查口语对话系统中的讽刺检测。 Carvalho等。 （2009）使用语言特征，如积极谓词，插入和手势线索，如表情符号，引号等.Davidov等。 （2010），Tsur等。 （2010）使用句法模式来构造分类器。 Gonza lezIba nez等。 （2011）也研究表情符号的使用，主要是在推文中。 Riloff等。 （2013）断言讽刺与积极情绪词和消极情境形成鲜明对比。乔希等人。 （2015）使用包括词汇，语用，隐式和显式上下文不一致的多个特征。在明确的案例中，它们包括相关特征，以检测句子中受挫的情感期望。对于隐含的不协调，他们概括了Riloff等人。 （2013）通过识别在两个极性中包含对比度的动词 - 名词短语。 \n基于上下文的模型   近年来，语境讽刺的使用有所增加，尤其是在线平台。在微博，论坛和社交媒体中发现的文本受到语法不准确性的困扰，并且包含高度时间和语境的信息。在这种情况下，挖掘语言信息变得相对低效，并且需要额外的线索（Carvalho等，2009）。华莱士等人。 （2014）通过展示传统分类器在人类需要额外背景的情况下如何失败来证明这种需求。它们还表明了与文本相关的发言者和专题信息对于收集这种背景的重要性。 Poria等。 （2016）通过输入文本的情感，情感和个性表示来使用附加信息。以前的作品主要使用用户的历史帖子来理解讽刺倾向（Rajadesingan等，2015; Zhang等，2016）。 Khattri等人。 （2015）尝试发现用户对其历史实体的情绪，以找到对比鲜明的证据。华莱士等人。 （2015）利用论坛中使用的情感和名词短语来收集该论坛的典型背景。这种基于论坛的建模模拟用户社区。我们的工作遵循类似的动机，因为我们探索用户剖析提供的上下文以及讨论论坛（subreddits2）中评论话语中的主题知识。 \n实验结果 数据集 我们在大型自注释讽刺语料库sarc上进行实验（Khodak等人，2017）。这个数据集包含了超过一百万个在Reddit上发表的讽刺/非讽刺性声明的例子。Reddit由特定主题的讨论论坛（也称为Subreddits）组成，每个论坛的标题都是一篇文章。在每个论坛中，用户通过评论标题的帖子或其他人的评论进行交流，从而形成一个树形的对话结构。这种结构可以分解成一种线性格式，从而通过保持拓扑约束不变来创建注释的论述。每个注释都附有作者详细信息和父注释（如果有的话），这些注释随后用于我们的上下文处理。值得注意的是，SARC中几乎所有的评论都是由一句话组成的。我们在实验中考虑了SARC数据集的三种变体。\n主要的平衡 这是主要的数据集，其中包含了讽刺和非讽刺评论的平衡分布。数据集包含来自1246058个用户（培训中118940个用户，测试集中56118个用户）的评论，分布在6534个论坛（培训中3868个用户，测试集中2666个用户）。\n主要的不平衡 为了模拟现实场景，讽刺性评论通常比非讽刺性评论少，我们使用主数据集的不平衡版本。具体地说，我们在两个培训/测试集中的讽刺和非讽刺评论之间保持20∶80的比率（大约）。\npol 为了进一步测试我们的用户嵌入的有效性，我们在主要的一个子集上执行实验，包括与政治主题相关的论坛。表1提供了所提到的所有数据集变量的注释分布。\n","href":"/post/20190717110201/","title":"CASCADE: Contextual Sarcasm Detection in Online Discussion Forums翻译和解读"},{"content":"","href":"/tags/%E8%A7%A3%E8%AF%BB/","title":"解读"},{"content":"","href":"/tags/javascript/","title":"javascript"},{"content":"   element next         /** * 1）单链表的插入、删除、查找操作； * 2）链表中存储的是int类型的数据； */ // 创建节点对象 class Node { constructor (element) { this.element = element this.next = null } } class LinkedList { constructor () { this.head = new Node(\u0026#39;head\u0026#39;) } // 根据value查找节点  findByValue (item) { let currentNode = this.head.next; while (currentNode !== null \u0026amp;\u0026amp; currentNode.element !== item) { currentNode = currentNode.next; } console.log(currentNode); return currentNode === null ? -1 : currentNode; } // 根据index查找节点，下标从0开始  findByIndex (index) { let currentNode = this.head.next let pos = 0 while (currentNode !== null \u0026amp;\u0026amp; pos !== index) { currentNode = currentNode.next pos++ } console.log(currentNode) return currentNode === null ? -1 : currentNode } // 向链表末尾追加节点  append(newElement) { const newNode = new Node(newElement) let currentNode = this.head while(currentNode.next) { currentNode = currentNode.next } currentNode.next = newNode } // 指定元素向后插入  insert (newElement, element) { const currentNode = this.findByValue(element) if (currentNode === -1) { console.log(\u0026#39;未找到插入位置\u0026#39;) return } const newNode = new Node(newElement) newNode.next = currentNode.next currentNode.next = newNode } // 查找前一个  findPrev (item) { let currentNode = this.head while (currentNode.next !== null \u0026amp;\u0026amp; currentNode.next.element !== item) { currentNode = currentNode.next } if (currentNode.next === null) { return -1 } return currentNode } // 根据值删除  remove (item) { const prevNode = this.findPrev(item) if (prevNode === -1) { console.log(\u0026#39;未找到元素\u0026#39;) return } prevNode.next = prevNode.next.next } // 遍历显示所有节点  display () { let currentNode = this.head.next // 忽略头指针的值  while (currentNode !== null) { console.log(currentNode.element) currentNode = currentNode.next } } } // Test const LList = new LinkedList() LList.append(\u0026#39;chen\u0026#39;) LList.append(\u0026#39;curry\u0026#39;) LList.append(\u0026#39;sang\u0026#39;) LList.append(\u0026#39;zhao\u0026#39;) // chen -\u0026gt; curry -\u0026gt; sang -\u0026gt; zhao console.log(\u0026#39;-------------insert item------------\u0026#39;) LList.insert(\u0026#39;qian\u0026#39;, \u0026#39;chen\u0026#39;) // 首元素后插入 LList.insert(\u0026#39;zhou\u0026#39;, \u0026#39;zhao\u0026#39;) // 尾元素后插入 LList.display() // chen -\u0026gt; qian -\u0026gt; curry -\u0026gt; sang -\u0026gt; zhao -\u0026gt; zhou console.log(\u0026#39;-------------remove item------------\u0026#39;) LList.remove(\u0026#39;curry\u0026#39;) LList.display() // chen -\u0026gt; qian -\u0026gt; sang -\u0026gt; zhao -\u0026gt; zhou console.log(\u0026#39;-------------find by item------------\u0026#39;) LList.findByValue(\u0026#39;chen\u0026#39;) console.log(\u0026#39;-------------find by index------------\u0026#39;) LList.findByIndex(2) console.log(\u0026#39;-------------与头结点同值元素测试------------\u0026#39;) LList.insert(\u0026#39;head\u0026#39;, \u0026#39;sang\u0026#39;) LList.display() // chen -\u0026gt; qian -\u0026gt; sang -\u0026gt; head -\u0026gt; zhao -\u0026gt; zhou LList.findPrev(\u0026#39;head\u0026#39;) // sang LList.remove(\u0026#39;head\u0026#39;) LList.display() // chen -\u0026gt; qian -\u0026gt; sang -\u0026gt; zhao -\u0026gt; zhou ","href":"/post/20190717084321/","title":"单链表"},{"content":"","href":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":" 格式化输出yyyy-mm-dd HH:MM:SS.msmsms function padbyZero(){ // 用零填充  var val = arguments[0]|0; var len = arguments[1]|2; var res = null; for(var i=1;i\u0026lt;len;i++){ res = val\u0026lt;Math.pow(10, i)?\u0026#39;0\u0026#39;+val:\u0026#39;\u0026#39;+val; } return res; } var d=new Date(); //获取年，getFullYear()返回4位的数字 var year=d.getFullYear(); //获取月，月份比较特殊，从0开始计数 var month=padbyZero(d.getMonth()+1); //获取日 var day=padbyZero(d.getDate()); var hour=padbyZero(d.getHours()); var minute=padbyZero(d.getMinutes()); var second=padbyZero(d.getSeconds()); var millisceond=padbyZero(d.getMilliseconds(), 3); formatStr = year+\u0026#39;-\u0026#39;+month+\u0026#39;-\u0026#39;+day+\u0026#39; \u0026#39;+hour+\u0026#39;:\u0026#39;+minute+\u0026#39;:\u0026#39;+second+\u0026#39;.\u0026#39;+millisceond; console.log(formatStr); ","href":"/post/20190714155323/","title":"javascript内置对象Date的使用"},{"content":"","href":"/tags/chrome/","title":"Chrome"},{"content":" 设置调试的网速 设置network传输的文件图标 ","href":"/post/20190713135841/","title":"chrome浏览器的调试技巧"},{"content":"","href":"/categories/%E8%B0%83%E8%AF%95/","title":"调试"},{"content":" 代码片段效率工具-snippet 查看教程snippet，让你编码效率翻倍\n微型的http服务器-Express  Hosts current worksapce with Express web server. - Compulim\n  在商店里面搜索express 安装完毕以后，快捷键Shift + command + P，输入Host Current Workspace with ... 点击，就可开启了一个http服务器 之后，在浏览器输入文件相对于vscode的绝对路径  \u0026gt; 快一点的方法就是对着文件右键，选择Copy Relative Path  最后，就可以看到你写的网页了  python代码自动补全 { \u0026#34;python.autoComplete.extraPaths\u0026#34;: [ \u0026#34;包的绝对路径， 通常名为site-packages\u0026#34;, \u0026#34;脚本的路径，比如pip,python等命令行脚本\u0026#34;, ], } 文件-\u0026gt;设置-\u0026gt;首选项，搜索python.jediEnabled,去掉前面的√， 使用Microsoft python analysis engine\npython代码静态检查工具-pylint pip install pylint yapf 默认设置\n{ \u0026#34;python.linting.enabled\u0026#34;: true, \u0026#34;python.linting.lintOnSave\u0026#34;: true, \u0026#34;python.linting.pylintEnabled\u0026#34;: true }","href":"/post/20190713105721/","title":"vscode常用插件"},{"content":"","href":"/tags/%E6%8F%92%E4%BB%B6/","title":"插件"},{"content":"","href":"/tags/vue/","title":"vue"},{"content":" Vue.js 第一部分 课程介绍 前面5个部分：学习Vue的基本的语法和概念；打包工具Webpack，Gulp 后面5个部分：以项目驱动教学\n什么是Vue.js  Vue.js是目前最火的一个框架，React是最流行的一个框架（React除了开发网站，还可以开发手机App） Vue.js是前端的主流框架之一，和Angular.js、React.js一起，并称为前端三大主流框架! Vue.js是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；  为什么要学习流行的框架  企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；\n 企业中，使用框架，能够提高开发的效率；  提高开发效率的发展历程：原生JS-\u0026gt;Jquery之类的类库-\u0026gt;前端模板引擎-\u0026gt;和Angular.js/ Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念[通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了]）\n 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以有更多的时间去关注业务逻辑；\n 增强自己就业时候的竞争力\n 人无我有，人有我优   框架和库的区别  框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。\n node中的express  库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。\n 1. 从Jquery切换到Zepto 2. 从EJS切换到art-template   Node（后端）中的MVC与前端中的MVVM之间的区别  MVC是后端的分层开发概念；\n MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分Model，View，VM ViewModel\n 为什么有了MVC还要有MVVM\n  \nVue.js 基本代码和MVVM之间的对应关系 Vue之 基本的代码结构和插值表达式、v-clock Vue基本的代码结构和插值表达式\nVue指令之 v-text和v-html Vue指令之 v-bind的三种用法  直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=\u0026quot;btnTitle + '，这是追加的内容'\u0026quot;  Vue指令之v-on和跑马灯效果 v-clock，v-text, v-html, v-bind, v-on\n跑马灯效果  HTML效果：  跑马灯效果   Vue指令之v-on的缩写和事件修饰符 事件修饰符：  .stop阻止冒泡 .prevent阻止默认事件 .capture添加事件侦听器时使用事件捕获模式 .self只当事件在该元素本身（比如不是子元素）触发时触发回调 .once事件只触发一次  事件修饰符demo\n","href":"/post/20190712145655/","title":"vue学习笔记（第一部分）"},{"content":"","href":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/","title":"前端开发框架"},{"content":"","href":"/categories/linux/","title":"linux"},{"content":"","href":"/tags/nginx/","title":"nginx"},{"content":"","href":"/tags/nginx%E5%AE%89%E8%A3%85/","title":"nginx安装"},{"content":" linux 安装nginx sudo apt-get install nginx 配置文件路径 /etc/nginx  mac 安装nginx brew install nginx 配置文件路径 /usr/local/etc/nginx/  ","href":"/post/20190711153813/","title":"nginx安装和配置教程"},{"content":"","href":"/tags/nginx%E9%85%8D%E7%BD%AE/","title":"nginx配置"},{"content":"","href":"/tags/brew/","title":"brew"},{"content":"  将brew改为国内镜像，主要分为两个步骤：修改brew.git和修改homebrew-core.git\n 替换brew.git cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 重置brew.git cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://github.com/Homebrew/brew.git 替换homebrew-core.git cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 重置homebrew-core.git cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://github.com/Homebrew/homebrew-core.git","href":"/post/20190711144859/","title":"brew国内镜像"},{"content":"","href":"/tags/%E5%9B%BD%E5%86%85%E6%BA%90/","title":"国内源"},{"content":"","href":"/tags/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/","title":"国内镜像"},{"content":"","href":"/tags/html/","title":"html"},{"content":"","href":"/tags/snippet/","title":"snippet"},{"content":"","href":"/tags/template/","title":"template"},{"content":"","href":"/categories/vscode/","title":"vscode"},{"content":"{ \u0026#34;vue\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;vue-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html lang=\\\u0026#34;zh\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;head\u0026gt;\u0026#34;, \u0026#34; \u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;title\u0026gt;${1:$CURRENT_DATE}\u0026lt;/title\u0026gt;\u0026#34;, \u0026#34; \u0026lt;style type=\\\u0026#34;text/css\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;/style\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://cdn.staticfile.org/vue/2.2.2/vue.min.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://server.lab421.top/前端开发/我自己的js库/wlib.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;script\u0026gt;\u0026#34;, \u0026#34;var data = {};\u0026#34;, \u0026#34;var vm = new Vue({\u0026#34;, \u0026#34; el: \u0026#39;#app\u0026#39;,\u0026#34;, \u0026#34; data: data,\u0026#34;, \u0026#34; methods: {}\u0026#34;, \u0026#34;});\u0026#34;, \u0026#34;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/html\u0026gt;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, }, \u0026#34;basic\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;basic-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html lang=\\\u0026#34;zh\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;head\u0026gt;\u0026#34;, \u0026#34; \u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;title\u0026gt;${1:$CURRENT_DATE}\u0026lt;/title\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/html\u0026gt;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, } }","href":"/post/20190711103532/","title":"vscode snippet html template"},{"content":"","href":"/tags/markdown/","title":"markdown"},{"content":"{ \u0026#34;table\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;html-table-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;table\u0026gt;\u0026#34;, \u0026#34;\u0026lt;thead\u0026gt;\u0026#34;, \u0026#34;\u0026lt;tr\u0026gt;\u0026#34;, \u0026#34;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/thead\u0026gt;\u0026#34;, \u0026#34;\u0026lt;tbody\u0026gt;\u0026#34;, \u0026#34;\u0026lt;tr\u0026gt;\u0026#34;, \u0026#34;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/tbody\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/table\u0026gt;\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, } }","href":"/post/20190711103224/","title":"vscode snippet markdown template"},{"content":"","href":"/tags/shadowsocks/","title":"Shadowsocks"},{"content":"  以ubuntu为例\n 下载shadowsocks-qt5 打开链接, 点击Shadowsocks-Qt5-xxx-x86_64.AppImage文件下载\n赋予执行权限 sudo chmod +x Shadowsocks-Qt5-xxx-x86_64.AppImage 打开shadowsocks-qt5的两种方式  直接点击 命令行输入  ./Shadowsocks-Qt5-xxx-x86_64.AppImage 生成autoproxy.pac文件  由于在国内生成autoproxy.pac的速度很慢，为了加快这一过程，我们先用shadowsocks配置一个全局代理\n 配置全局代理 依次点击ubuntu的设置\u0026gt;系统设置\u0026gt;网络\u0026gt;网络代理\u0026gt;手动\n然后把除了socks主机的所有其他行的选项都清空，端口无法清空，可以设置为0\n最后，点击应用到整个系统\nautoproxy.pac文件生成 安装genpac pip install genpac 使用在线的gfwlist genpac --pac-proxy \u0026#34;SOCKS5 127.0.0.1:1080\u0026#34; --gfwlist-proxy=\u0026#34;SOCKS5 127.0.0.1:1080\u0026#34; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=\u0026#34;autoproxy.pac\u0026#34; 使用离线的gfwlist genpac --pac-proxy \u0026#34;SOCKS5 127.0.0.1:1080\u0026#34; --gfwlist-proxy=\u0026#34;SOCKS5 127.0.0.1:1080\u0026#34; --gfwlist-local=你的路径/gfwlist.txt --output=\u0026#34;autoproxy.pac\u0026#34; 配置系统代理 关键一步，把autoproxy.pac使用本地http协议访问\n再次回到网络代理界面，选择自动，在配置URL的框中输入http://127.0.0.1/autoproxy.pac\n","href":"/post/20190710221501/","title":"linux使用shadowsocks-qt5实现自动代理"},{"content":"","href":"/tags/pac%E6%A8%A1%E5%BC%8F/","title":"pac模式"},{"content":"","href":"/tags/shadowsocks-qt5/","title":"shadowsocks-qt5"},{"content":"","href":"/tags/ubuntu/","title":"ubuntu"},{"content":"","href":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","title":"科学上网"},{"content":"","href":"/categories/%E7%BF%BB%E5%A2%99/","title":"翻墙"},{"content":"","href":"/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/","title":"软件使用"},{"content":"","href":"/tags/vim/","title":"vim"},{"content":"","href":"/tags/vim%E5%91%BD%E4%BB%A4/","title":"vim命令"},{"content":"   功能 命令      打开快捷命令窗口      ","href":"/post/20190710153911/","title":"vim常用命令"},{"content":"","href":"/categories/%E7%BC%96%E8%BE%91%E5%99%A8/","title":"编辑器"},{"content":" 与 Java 、PHP 等语言不同，在 JavaScript 中，数组其实是一种特殊的对象。\n数组的创建与读写 以下两种方式都可创建数组：\n// 字面量方式,常用 var num = [1,5,6,10]; print(num.length); // 4  // 构造函数方式 var num = new Array(1,5,6,10); print(num.length); // 4  值得注意的是，JavaScript 中的数组数据可以是不同类型，它的语法相对宽松，例如可以指定不同类型数据var example = [1,\u0026quot;Mike\u0026quot;,true,null];另外，可以通过Array.isArray()来判断一个对象是否是数组，例如：\nvar num = [1,5,6,10]; print(Array.isArray(num)); // true  如何读写数组呢？可以使用循环。\nvar num = [1,5,6,10]; for (var i = 0; i \u0026lt; num.length; i++) { console.log(num[i]+\u0026#34; \u0026#34;); }  数组的深复制与浅复制 当我们把数组赋给另外一个数组，然后改变其中一个数组的值，另一数组也会随之改变，这就是数组的浅复制。而深复制指的就是不改变原来的数组而去创建一个新的数组，这种情况是经常使用的，为了不破坏原数组。下面的代码展示了这两种复制\n// 浅复制 var num = [1,2,3,4,5]; var newNum = num; num[0] = 10; console.log(newNum[0]); // 10  // 深复制 function copy (arr1,arr2) { for(var i=0;i\u0026lt;arr1.length;i++){ arr2[i] = arr1[i]; } } var num = [1,5,6,7,9]; var newNum = []; copy(num,newNum); num[0] = 10; console.log(newNum[0]); // 仍然为 1  存取函数 JavaScript 提供了一组用来访问数组元素的函数，叫存取函数。最常用的存取函数就是 indexOf() 函数，该函数返回指定查找的值在目标值中是否存在，如果存在，返回该值在数组中的索引，不存在则返回 -1。\nvar word = [\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;]; var result = word.indexOf(\u0026#34;A\u0026#34;); console.log(result); // 0 var test = word.indexOf(\u0026#34;F\u0026#34;); console.log(test); // -1  除此之外，还有 join 和 toString 函数，concat 和 splice 函数。前两个函数可以将数组转化为字符串，后面两个函数可以通过已有的数组创建新数组，其中 concat 方法通过合并多个数组来形成新数组，而 splice 方法是截取一个数组的子集作为一个新数组。它们的使用示例如下\nvar arr = [\u0026#34;Mike\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Hexo\u0026#34;]; console.log(arr.join()); // Mike,John,Hexo console.log(arr.toString()); // Mike,John,Hexo  var arr1 = [1,10,\u0026#34;Mike\u0026#34;]; var arr2 = [8,7,6]; var cat = arr1.concat(arr2); console.log(cat); // [1, 10, \u0026#34;Mike\u0026#34;, 8, 7, 6] var num = [1,2,3,4,5,6,7]; var a = num.splice(3,2); // 3 表示索引，2 表示删除 2 个 console.log(num); // [1, 2, 3, 6, 7]  可变函数 不去引用数组中的某个元素，就能改变数组内容，这种函数称它为可变函数。\npush() 和 unshift()、pop() 和 shift() push() 方法可以在数组末尾添加元素，而 unshift() 方法可以在数组开头添加元素；相对应的，pop 可以删除数组末尾的元素，而 shift 删除数组的第一个元素。\nvar nums = [9,58,15,16,23]; nums.push(111); console.log(nums); // 9, 58, 15, 16, 23, 111 nums.unshift(1); console.log(nums); // 1, 9, 58, 15, 16, 23, 111 nums.pop(); console.log(nums); // 1, 9, 58, 15, 16, 23 nums.shift(); console.log(nums); // 9, 58, 15, 16, 23  splice()、sort()、reverse() 前面提到的 splice 不仅可以用来删除元素，还可以添加元素进数组。用 sort 可以为数组排序，reverse 将数组内的元素翻转。\nvar num = [98,99,100,101]; num.splice(1,0,89); // 1 表示索引，0 表示不删除元素，89 表示将 89 这个元素添加进数组 console.log(num); // 98, 89, 99, 100, 101 num.reverse(); console.log(num); // 101, 100, 99, 89, 98  关于 sort 方法非常有意思，它只能对那些字符串类型的元素排列得比较准确，但如果是数字，结果就不那么令人满意了。看看例子.\nvar str = [\u0026#34;hello\u0026#34;,\u0026#34;client\u0026#34;,\u0026#34;zero\u0026#34;]; str.sort(); console.log(str); // [\u0026#34;client\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;zero\u0026#34;] 按照字母 a-z 排列准确 var nums = [1,200,51,66,88]; nums.sort(); console.log(nums); // [1, 200, 51, 66, 88] 有趣的事情来了，因为 200 的 2 比 51 的 5 先，所以 200 排在 51 前头  那如何解决这种排序的错误呢？方法就是在调用 sort() 的时候传入一个函数，该函数可以比较出大小。\nfunction compare(num1,num2){ return num1 - num2; } var nums = [3,1,2,100,4,200]; nums.sort(compare); console.log(nums); // 1, 2, 3, 4, 100, 200  可以看到，已经排序正确了，compare 函数就是利用了两数相减，如果结果为正，那么被减数大于减数，如果结果为 0，则两数相等，而如果结果为负，说明被减数小于减数。\n迭代器方法 迭代函数通过对数组中的元素逐个应用，来操作返回相应的值。\n不返回新数组的 forEach() 、every()、some()、reduce() // 用 forEach 开方 function square(num) { console.log(num,num*num); } var num = [1,2,3,4,5]; num.forEach(square); console.log(num); /* 1 1 2 4 3 9 4 16 5 25 */ /* every() 返回值为布尔类型，对于应用的所有元素，该函数返回 true，则该方法返回 true */ function isEven(num){ return num % 2 == 0; } var num = [2,4,6,8,10]; var even = num.every(isEven); if(even){ console.log(\u0026#34;所有的数字都是偶数\u0026#34;); }else{ console.log(\u0026#34;不是所有的数字都是偶数\u0026#34;); } /* some() 与 every() 的不同就是只要有一个元素使改函数返回 true ，那么该方法就返回 true */ function isEven(num){ return num % 2 == 0; } var num = [1,2,3,4,5,6,7,8]; var someEven = num.some(isEven); if(someEven){ console.log(\u0026#34;有些数字是偶数\u0026#34;); }else{ console.log(\u0026#34;没有数字是偶数\u0026#34;); } /* reduce() 有两个功能，一是可以对数组元素进行求和，二是将数组元素连接成字符串。 */ fucntion add(num1,num2){ return num1 + num2; } var num = [1,2,3,4]; var sum = num.reduce(add); console.log(sum); // 10  function concat(str,i) { return str + i; } var words = [\u0026#34;I am \u0026#34;,\u0026#34;a \u0026#34;,\u0026#34;coder \u0026#34;]; var re = words.reduce(concat); console.log(re); // I am a coder  返回新数组的 map() 和 filter() map 的作用与 forEach 是一样的，区别就是 map 函数返回的是一个新数组。\nfunction addFive(grade){ return grade += 5; } var grade = [77,82,88,95,90]; var result = grade.map(addFive); console.log(result); // 82, 87, 93, 100, 95  而 filter 和 every 相似，区别在于当所有的元素使改函数为 true 时，它并不返回布尔类型，而是返回一个新数组。下面这个例子十分有趣，它随机产生10个 0 到 100 的数字作为分数，然后把大于 60 的及格分数筛选出来。\nfunction passing(num){ return num \u0026gt;= 60; } var grades = []; for(var i = 0;i \u0026lt; 11;i++){ grade[i] = Math.floor(Math.random() * 101); } var pass = grades.filter(passing); console.log(\u0026#34;随机产生的 10 个同学的分数为：\u0026#34;); console.log(grades); console.log(\u0026#34;及格的分数有：\u0026#34;); console.log(pass);  上述代码的输出结果为 \u0026gt; 随机产生的 10 个同学的分数为： 21, 4, 89, 45, 5, 51, 71, 7, 46, 53, 47 及格的分数有： 89, 71\n二维数组 JavaScript 可以通过在数组里在嵌套一个数组来形成二维数组。\nvar grades = [ [88,86,82], [91,82,83], [77,72,79], [86,80,82] ]; console.log(grades[1][2]); // 83  处理二维数组 对于二维数组的处理可以分为两种，一种按列访问，一种是按行访问。 按列访问，外层循环对应行，内层循环对应列。例如，上述的数组，每一行对应一个学生三门科目的成绩记录，可以通过相加所有成绩，然后除以科目数来得到该生的平均成绩。\nvar grades = [ [88,86,82], [91,82,83], [77,72,79], [86,80,82] ]; var total = 0; var average = 0.0; for(var row = 0;row\u0026lt;grades.length;++row){ for(var col = 0;col\u0026lt;grades[row].length;++col){ total += grades[row][col]; } average = total/grades[row].length; console.log(\u0026#34;student \u0026#34;+parseInt(row+1)+\u0026#34; average: \u0026#34;+average.toFixed(2)); // toFixed 表示按照 2 位来保留小数  total = 0; average = 0.0; }  上述代码的输出结果为\n student 1 average: 85.33 student 2 average: 85.33 student 3 average: 76.00 student 4 average: 82.67\n 对于按行访问，则外层循环对应列，内层循环对应行，例如还是上述数组，现在的数组表示一个学生三场考试四门科目的各科分数，我们来求每场考试的平均成绩\nvar grades = [ [88,86,82], [91,82,83], [77,72,79], [86,80,82] ]; var total = 0; var average = 0.0; //这里假设每场考试的科目都一样，所以可以通过grades[0].length来获取考试数量 for(var col = 0;col \u0026lt;grades[0].length;++col ){ for(var row= 0;row\u0026lt;grades.length;++row){ total += grades[row][col]; } average = total/grades.length; console.log(\u0026#34;exam \u0026#34;+parseInt(col +1)+\u0026#34; average: \u0026#34;+average.toFixed(2)); total = 0; average = 0.0; }  输出结果为：\n exam 1 average: 85.50 exam 2 average: 80.00 exam 3 average: 81.50\n 其实只要调整 for 循环的顺序就可以控制是按行还是按列来输出，此外，JavaScript 还可以处理一些参差不齐的数组，比如一个二维数组中的数组，有的是两个元素，有的是四个元素，并不是都相同，在这种情况下，JavaScript 依然可以处理运行而不报错，这是因为不管多或少，都可以通过 length 属性来计算。\n对象数组 如果你有阅读到这里，你应该可以发现上面的所有例子里数据类型都是基本数据类型，不是数字就是字符串。对象数组，顾名思义，就是数组里面的元素可以是对象，这个与 java 的语法很相似，基本上所有的编程语言都是相通的。看看下面这个例子：\nfunction point(x,y){ this.x = x; this.y = y; } function show(arr){ for(var i=0;i\u0026lt;arr.length;i++){ console.log(arr[i].x + \u0026#34;, \u0026#34;+arr[i].y); } } var p1 = new Point(1,2); var p2 = new Point(2,4); var p3 = new Point(8,1); var p4 = new Point(2,9); var point = [p1,p2,p3,p4]; for(var i=0;i\u0026lt;point.lengh;i++){ console.log(\u0026#34;Point \u0026#34;+parseInt(i+1)+\u0026#34;: \u0026#34;+point[i].x+\u0026#34;, \u0026#34;+point[i].y); }  上述程序的输出结果为：\n Point 1: 1, 2 Point 2: 2, 4 Point 3: 8, 1 Point 4: 2, 9\n 也可以用之前的 push() 等操作方法来操作对象数组\nvar p5 = new Point(11,13); point.push(p5); console.log(\u0026#34;添加了 p5 后：\u0026#34;); show(point); point.shift(); console.log(\u0026#34;删除第一个元素后：\u0026#34;) show(point);  输出结果为：\n\u0026gt; 添加了 p5 后： 1,2 2,4 8,1 2,9 11,13 删除第一个元素后： 2,4 8,1 2,9 11,13  ","href":"/post/20190710110242/","title":"javascript数组"},{"content":"","href":"/tags/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"HTML 速查列表   HTML 速查列表. 你可以打印它，以备日常使用。\n HTML 基本文档 \u0026lt;!DOCTYPEhtml\u0026gt;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;文档标题\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;可见文本... \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;    基本标签（Basic Tags） \u0026lt;h1\u0026gt;最大的标题\u0026lt;/h1\u0026gt;\u0026lt;h2\u0026gt;. . . \u0026lt;/h2\u0026gt;\u0026lt;h3\u0026gt;. . . \u0026lt;/h3\u0026gt;\u0026lt;h4\u0026gt;. . . \u0026lt;/h4\u0026gt;\u0026lt;h5\u0026gt;. . . \u0026lt;/h5\u0026gt;\u0026lt;h6\u0026gt;最小的标题\u0026lt;/h6\u0026gt;\u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt;\u0026lt;br\u0026gt;（换行） \u0026lt;hr\u0026gt;（水平线） \u0026lt;!--这是注释 --\u0026gt;    文本格式化（Formatting） \u0026lt;b\u0026gt;粗体文本\u0026lt;/b\u0026gt;\u0026lt;code\u0026gt;计算机代码\u0026lt;/code\u0026gt;\u0026lt;em\u0026gt;强调文本\u0026lt;/em\u0026gt;\u0026lt;i\u0026gt;斜体文本\u0026lt;/i\u0026gt;\u0026lt;kbd\u0026gt;键盘输入\u0026lt;/kbd\u0026gt;\u0026lt;pre\u0026gt;预格式化文本\u0026lt;/pre\u0026gt;\u0026lt;small\u0026gt;更小的文本\u0026lt;/small\u0026gt;\u0026lt;strong\u0026gt;重要的文本\u0026lt;/strong\u0026gt;\u0026lt;abbr\u0026gt;（缩写） \u0026lt;address\u0026gt;（联系信息） \u0026lt;bdo\u0026gt;（文字方向） \u0026lt;blockquote\u0026gt;（从另一个源引用的部分） \u0026lt;cite\u0026gt;（工作的名称） \u0026lt;del\u0026gt;（删除的文本） \u0026lt;ins\u0026gt;（插入的文本） \u0026lt;sub\u0026gt;（下标文本） \u0026lt;sup\u0026gt;（上标文本）    链接（Links） 普通的链接：\u0026lt;ahref=\"http://www.example.com/\"\u0026gt;链接文本\u0026lt;/a\u0026gt;图像链接： \u0026lt;ahref=\"http://www.example.com/\"\u0026gt;\u0026lt;imgsrc=\"URL\"alt=\"替换文本\"\u0026gt;\u0026lt;/a\u0026gt;邮件链接： \u0026lt;ahref=\"mailto:webmaster@example.com\"\u0026gt;发送e-mail\u0026lt;/a\u0026gt;书签： \u0026lt;aid=\"tips\"\u0026gt;提示部分\u0026lt;/a\u0026gt;\u0026lt;ahref=\"#tips\"\u0026gt;跳到提示部分\u0026lt;/a\u0026gt;    图片（Images） \u0026lt;imgsrc=\"URL\"alt=\"替换文本\"height=\"42\"width=\"42\"\u0026gt;    样式/区块（Styles/Sections） \u0026lt;styletype=\"text/css\"\u0026gt; h1{color:red;}p{color:blue;} \u0026lt;/style\u0026gt;\u0026lt;div\u0026gt;文档中的块级元素\u0026lt;/div\u0026gt;\u0026lt;span\u0026gt;文档中的内联元素\u0026lt;/span\u0026gt;    无序列表 \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;项目\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;项目\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt;    有序列表 \u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt;    定义列表 \u0026lt;dl\u0026gt;\u0026lt;dt\u0026gt;项目 1\u0026lt;/dt\u0026gt;\u0026lt;dd\u0026gt;描述项目 1\u0026lt;/dd\u0026gt;\u0026lt;dt\u0026gt;项目 2\u0026lt;/dt\u0026gt;\u0026lt;dd\u0026gt;描述项目 2\u0026lt;/dd\u0026gt;\u0026lt;/dl\u0026gt;    表格（Tables） \u0026lt;tableborder=\"1\"\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;表格标题\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;表格标题\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;表格数据\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;表格数据\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;/table\u0026gt;    框架（Iframe） \u0026lt;iframesrc=\"demo_iframe.htm\"\u0026gt;\u0026lt;/iframe\u0026gt;    表单（Forms） \u0026lt;formaction=\"demo_form.php\"method=\"post/get\"\u0026gt;\u0026lt;inputtype=\"text\"name=\"email\"size=\"40\"maxlength=\"50\"\u0026gt;\u0026lt;inputtype=\"password\"\u0026gt;\u0026lt;inputtype=\"checkbox\"checked=\"checked\"\u0026gt;\u0026lt;inputtype=\"radio\"checked=\"checked\"\u0026gt;\u0026lt;inputtype=\"submit\"value=\"Send\"\u0026gt;\u0026lt;inputtype=\"reset\"\u0026gt;\u0026lt;inputtype=\"hidden\"\u0026gt;\u0026lt;select\u0026gt;\u0026lt;option\u0026gt;苹果\u0026lt;/option\u0026gt;\u0026lt;optionselected=\"selected\"\u0026gt;香蕉\u0026lt;/option\u0026gt;\u0026lt;option\u0026gt;樱桃\u0026lt;/option\u0026gt;\u0026lt;/select\u0026gt;\u0026lt;textareaname=\"comment\"rows=\"60\"cols=\"20\"\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/form\u0026gt;    实体（Entities） \u0026amp;lt;等同于 \u0026lt;\u0026amp;gt; 等同于 \u0026gt;\u0026amp;#169; 等同于 ©    ","href":"/post/20190710104402/","title":"HTML速查列表"},{"content":"","href":"/tags/html%E5%B8%B8%E7%94%A8/","title":"html常用"},{"content":" span.new { float: right; color: #fff; background-color: #90b575; font-weight: 700; padding-left: 1px; padding-right: 1px; border: 1px solid #fff; outline: 1px solid #90b575; line-height: 16px; }    属性 描述   accesskey 设置访问元素的键盘快捷键。   class 规定元素的类名（classname）   contenteditableNew 规定是否可编辑元素的内容。   contextmenuNew 指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单   data-*New 用于存储页面的自定义数据   dir 设置元素中内容的文本方向。   draggableNew 指定某个元素是否可以拖动   dropzoneNew 指定是否将数据复制，移动，或链接，或删除   hiddenNew hidden 属性规定对元素进行隐藏。   id 规定元素的唯一 id   lang 设置元素中内容的语言代码。   spellcheckNew 检测元素是否拼写错误   style 规定元素的行内样式（inline style）   tabindex 设置元素的 Tab 键控制次序。   title 规定元素的额外信息（可在工具提示中显示）   translateNew 指定是否一个元素的值在页面载入时是否需要翻译    ","href":"/post/20190710101926/","title":"HTML标签的全局属性"},{"content":"","href":"/tags/html%E6%A0%87%E7%AD%BE/","title":"html标签"},{"content":" bib文件点击跳转 在.tex文件开头加上\\usepackage[backref]{hyperref}。\n","href":"/post/20190709170202/","title":"Latex常用设置"},{"content":"","href":"/tags/latex/","title":"latex"},{"content":"","href":"/categories/%E5%86%99%E4%BD%9C/","title":"写作"},{"content":"","href":"/tags/tcp/","title":"TCP"},{"content":"","href":"/tags/udp/","title":"UDP"},{"content":" 1、UDP 1.1、数据包格式   源端口号(16位) 目的端口号(16位)    UDP长度(16位) UDP校验和(16位)   数据    1.2、特点  沟通简单。不需要一肚子花花肠子(大量的数据结构、处理逻辑、包头字段)。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。 轻信他人。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。 愣头青。做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。  1.3、使用场景  需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。 不需要一对一沟通，建立连接，而是可以广播的应用。咱们小时候人都很简单，大家在班级里面，谁成绩好，谁写作好，应该表扬谁惩罚谁，谁得几个小红花都是当着全班的面讲的，公平公正公开。长大了人心复杂了，薪水、奖金要背靠背，和员工一对一沟通。 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。记得曾国藩建立湘军的时候，专门招出生牛犊不怕虎的新兵，而不用那些“老油条”的八旗 兵，就是因为八旗兵经历的事情多，遇到敌军不敢舍死忘生。  TCP三次握手 握手过程   SYN(Synchronize sequence numbers): TCP首部中的同步序号标志 ACK(Acknowledgement): 确认字符      时间段 客户端 服务端   活动 状态 活动 状态       CLOSED  CLOSED     CLOSED  LISTEN    \u0026rarr;   第一次握手 主动发起连接SYN SYN-SENT 收到发起的连接 SYN-RCVD   \u0026larr;  第二次握手 收到SYN和ACK SYN_SENT 返回SYN并ACK客户端的SYN SYN_RCVD    \u0026rarr;   第三次握手 发送ACK的ACK ESTABLISHED 收到客户端的ACK ESTABLISHED    为什么不是两次握手？  A为客户端，B为服务端\n 防止服务端建立单方面连接\n 在A建立连接，发生了第一个请求的时候，由于丢包或超时导致第一个请求包丢了。\nA不能确定结果，于是不停的发。终于，一个请求包到了B（A不知道这个请求包到了B）。\nB收到了请求包，知道了A的存在。\n然后，A发出的迟到的请求包到了B。B认为这个是一个正常的请求，因此建立了连接。\n 上述过程就是两次握手，我们可以看到如果B在第二次握手以后，继续确认客户端的ack（即第三次握手），就不会建立上面荒谬的连接。\n为什么不四次握手？ 三次握手可以双方的消息有去有去有回，四次握手完全没有必要。\n 即便更多次数的握手，也不能保证连接可靠\n 三次握手的作用？  建立连接; 确定TCP包的起始序号;(序号是一个32位的计数器，每4ms加1，防止出现冲突)  TCP四次挥手 过程    时间段 客户端 服务端   活动 状态 活动 状态       ESTABLISHED  ESTABLISHED    \u0026rarr;   第一次挥手 发送FIN FIN-WAIT-1 接收FIN CLOSED-WAIT    \u0026larr;   第二次挥手 收到ACK FIN-WAIT-2 发送ACK CLOSED-WAIT    \u0026larr;   第三次挥手 收到FIN,ACK FIN-WAIT-2 发送FIN,ACK LAST_ACK    \u0026rarr;   第四次挥手 发送ACK TIME-WAIT 收到ACK LAST_ACK    ","href":"/post/20190708141834/","title":"UDP和TCP协议"},{"content":"","href":"/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/","title":"网络协议"},{"content":"  标签部分先后顺序，按照收录的先后顺序\n ruby标签 用来注释中文注音或字符。\ntemplate标签 HTML内容模板（\u0026lt;template\u0026gt;）元素 是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以在运行时使用JavaScript实例化。\n将模板视为一个内容片段，存储在文档中供后续使用。虽然解析器在加载页面时确实会处理\u0026lt;template\u0026gt;元素的内容，但这样做只是为了确保这些内容有效；然而，元素的内容不会被呈现。\n一个例子\n","href":"/post/20190708085133/","title":"常用的HTML标签整理"},{"content":"","href":"/tags/%E6%A0%87%E7%AD%BE/","title":"标签"},{"content":"","href":"/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"后序遍历"},{"content":"","href":"/post/20190707215537/","title":"后序遍历非递归算法"},{"content":" JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。 JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。 JAX-RS(JSR 311 \u0026amp; JSR 339 \u0026amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。  ","href":"/post/20190707214914/","title":"Java规范中和与Web Service相关的规范有哪些？"},{"content":"","href":"/tags/web-service%E8%A7%84%E8%8C%83/","title":"web service规范"},{"content":"","href":"/tags/icmp/","title":"ICMP"},{"content":" 1、ICMP的定义 全称Internet Control Message Protocol，就是互联网控制报文协议。\n 这里的关键词是”控制“，下面我将介绍它是如何控制的\n 2、ICMP的由来 由于复杂的网络环境，数据包在网络中传输常常会发生各种问题。当遇到问题时，我们不想让数据包“死得不明不白”。为了知道产生问题的原因，我们需要构造一种新的数据包来传回消息。\n 其实，上面提到这种情况和我们在电视上看到的古代作战很像，在开始作战之前，主帅都要派出“侦察兵”来检查敌方的兵力状况，以调整作战策略。\n 3、ICMP的报文 ICMP它是一个3层网络协议，工作在网络层。由于数据包的传输是需要源地址和目的地址，所以被封装在IP中。它的数据包结构非常简单，因为一个“侦察兵”要“轻装上阵”，不能携带太多的包袱。\n3.1、报文结构  目前类型字段有8位，可以有256种类型，但是我们实际常用的只有3种，分别是0,3,8,具体会在下面提到\n 3.2、报文分类  分为两类：查询和差错报文\n 3.2.1、查询报文 分为两类：回显请求和回显应答报文。\n 在这里代码字段，我们只用到了0，还有255个代码没有用，具体会在下面讲到\n 3.2.1.1、 回显请求 类型字段为8，代码字段为0\n3.2.1.2、 回显应答 类型字段为0，代码字段为0\n3.2.1.3、 Ping应用 ping发的包就符合ICMP协议的格式，只不过它在自己的数据字段增加了自己的格式。比原生的ICMP多了两个字段，一个是标识符，用来标识ping发出去的“侦察兵”的具体的任务是什么，比如“查找水源”；另一个是序号，用来给每个侦察兵编号，比如，“1号查找水源的侦察兵”。在数据字段中，ping还会存放发生请求的时间，用来计算往返的时间。\n下图的ping的过程示意图 3.2.2、 差错报文 分为4种：终点不可达，源站抑制，时间超时和路由重定向\n3.2.2.1、 终点不可达 网络不可达(代码0)，主机不可达(代码1)，协议不可达(代码2)，端口不可达(代码3)，需要进行分片但设置了不分片位代码(代码4)\n3.2.2.2、 源站抑制 就是让源站放慢发送速度。小兵:报告主公，您粮草送的太多了吃不完。\n3.2.2.3、 时间超时 就是超过网络包的生存时间还是没到。小兵:报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。\n3.2.2.4、 路由重定向 就是让下次发给另一个路由器。小兵:报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。\n差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包 的IP 头和IP 正文的前 8 个字节。\n 而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。\n* 侦察兵:报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。\n* 主公:神马?张将军是怎么死的(可以查看 ICMP 的前 8 字节)?没错，这是张将军的剑，是他的剑 (IP 数据包的头及正文前 8 字节)。\n 3.2.2.5、 Traceroute应用 Traceroute是一个“大骗子”，它使用ICMP的差错报文的规则，去制造一些错误场景，已获得想到的答案。接下来我将一一说明：\n3.2.2.5.1、 第一个作用：获得到达目的地的路径 第一场景：故意设置特殊的TTL(Time to Live)，来追踪去往目的地时沿途经过的路由器。比如，他会发生一个TTL为1的UDP数据包，一旦到达下一个路由器，就会由于数据包“死亡”返回一个时间超时的ICMP数据包。这样它就知道了下一条路由器的IP地址了。接着，又把TTL设置为2，有获得了下一条路由器的地址了。以此类推，就获得了到达目的地的整条路的IP地址了。\n但是，第一个场景里面存在一个缺陷，比如，最后一个UDP数据包已经可以到目的地了，他就不会返回ICMP差错报文，那么我怎么知道最后一个UDP数据包到底到目的地了吗？这样就有了第二个场景。\n第二个场景：故意选择一个不可能的值作为 UDP 端口号(大于 30000)。当该数据报到达时，将使目的主机的 UDP 模块 产生一份“端口不可达”错误 ICMP 报文。\n 这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。 被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢?因为 UDP 是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。\n 3.2.2.5.2、 第二个作用：确定路径的MTU Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡 住，会发送 ICMP 网络差错包，类型为“需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。\n4、 总结  ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文。 Ping 使用查询报文，Traceroute 使用差错报文。  ","href":"/post/20190707153102/","title":"ICMP协议是什么？ICMP协议的作用是什么？"},{"content":"","href":"/tags/ip/","title":"ip"},{"content":"","href":"/tags/ping/","title":"ping"},{"content":"","href":"/tags/traceroute/","title":"traceroute"},{"content":"","href":"/tags/cache-control/","title":"cache-control"},{"content":"","href":"/tags/etag/","title":"etag"},{"content":"","href":"/tags/expires/","title":"expires"},{"content":"","href":"/tags/http%E7%BC%93%E5%AD%98/","title":"http缓存"},{"content":" 前言 http缓存主要针对如css,js,图片等更新频率不大的静态文件。\nhttp缓存字段的描述 根据请求和响应分为：\nRequest Headers（浏览器端） if-modified-since\n请求头，缓存最新修改的时间，浏览器询问服务器，服务器会将它与last-modified进行比对\nif-none-match\n请求头，缓存标识，浏览器询问服务器询，服务器会将它与etag进行比对\nResponse Headers（服务器端） cache-control\n控制http缓存的最高指令\n常用值有:\n1. no-store: 所有内容都不缓存\n2. noc-cache: 缓存，但是浏览器使用缓存前，都会请求服务器判断缓存是否是最新，过期的缓存就不使用\n3. max-age=x(单位秒)在缓存后的x秒内不发请求，是http1.1的属性，类似于expires，但优先级高于expires\n4. s-maxage=x(单位秒)代理服务器请求源站在缓存后的x秒内不发请求，只对CDN有效\n5. public 客户端和代理服务器（CDN）都可缓存\n6. private 只有客户端可以缓存\nlast-modified\n响应头，缓存最新修改的时间，服务器返回给浏览器，优先级小于etag\netag\n响应头，缓存标识，服务器返回给浏览器，优先级高于last-modified\nexpires\n响应头，代表缓存过期时间，服务器返回，是http1.0的属性，优先级小于max-age\n使用http缓存的原因  客户端每次都要请求服务器，浪费流量;\n 服务器每次都得提供查找，下载，请求用户基础如果较大，服务器存在较大压力;\n 客户端每次请求完都要进行页面渲染，用户体验较差。\n  http缓存字段的关系 服务器和浏览器的对话  我将从服务器和浏览器的日常对话来阐述各个字段的起因和来由。\n为了简化，服务器称为S，浏览器称为C\n第一次对话(expires的由来)\n C: S，S，我要一个a.css文件，快发给我!!! S: 烦死了，给你，在expires时间前别来烦我!!!  第二次对话(last-modified和if-modified-since的由来)\nC: S, S, 我的a.css文件到期了，你快给我发一个新的!!! S: 新的a.css? 它有修改过吗？ 你之前用的就是最新的吧? ... 呃😓我也不知道了，要不我们都记录一下时间吧？ 我用last-modified记录a.css的最后修改时间， 至于你就用if-modified-since吧？ 如果没有修改过，我就返回给你304状态码 C: 好吧...  \u0026hellip;\u0026hellip; 中间过了，若干年，发生了很多事，比如http1.0升级到了http1.1\n\u0026hellip;\u0026hellip; 第n次对话(max-age的由来)\nC: S, S, 我要一个文件a.css，我的expires已经过期了， 你看一下这个文件修改了吗？修改了就发给我，好吗？ S: C啊, 你好low啊, 👎怎么还在用expires啊？毕竟你们那个客户端也是有钱的， 你们不是已经支持http1.1协议了吗？你该与时俱进，使用max-age啊， 你看这个比expires可靠多了啊？ C: 哦😯... 我知道了, 我以后优先使用max-age  第n+1对话(etag和if-none-match的由来)\nC: S, S, 你知道吗？出了新的判断文件是否修改的方法叫做if-none-match。 S: 当然了，我这边叫做etag, 我们以后优先使用这个这个交流吧？ C: 恩恩，好的  问题总结 虽然浏览器和服务器可以精确的比较缓存文件的差异，但在max-age或expires时间内，浏览器无法感知服务器文件的变化。\nhttp缓存解决方案 md5/hash缓存  为了解决上面在max-age和expires期间无法感知服务器文件变化的问题，下面提出的解决方案：\n 上面那个问题的前提就是服务器和浏览器两者文件的标识完全相同，比如路径相同。\n因此我们只需要每次在服务器上发布项目的时候给修改的文件添加不同的md5和hash标识就可以了。\n目前现成的解决方案就有webpack提供的webpack-md5-hash插件。\nCDN缓存  CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n简而言之，CDN理解成浏览器与服务器之间的临时站点，它会替服务器处理一部分的浏览器请求，从而整理减轻总服务器的压力。\n 参考链接\n","href":"/post/20190706141207/","title":"http缓存详解"},{"content":"","href":"/tags/if-modified-since/","title":"if-modified-since"},{"content":"","href":"/tags/if-none-match/","title":"if-none-match"},{"content":"","href":"/tags/last-modified/","title":"last-modified"},{"content":"","href":"/tags/beryllium/","title":"beryllium"},{"content":"","href":"/categories/python/","title":"python"},{"content":"","href":"/tags/selenium/","title":"selenium"},{"content":" 前言 之前在做智慧旅游的爬虫项目的时候，遇到了js动态加载网页内容的问题。导致必须适应selenium来解决问题，但是使用selenium太麻烦了。因此，开发了一个爬虫库，来快速编写爬虫脚本。\nberyllium demo # -*- coding: utf-8 -*- from beryllium import Beryllium import time from beryllium import FieldList, Field, FieldName, Page, ListCssSelector, Mongodb, NextPageCssSelectorSetup, PageFunc bery = Beryllium() bery.driver = bery.get_driver() bery.fast_get_page(\u0026#34;https://www.baidu.com\u0026#34;) time.sleep(1) bery.until_send_text_by_css_selector(css_selector=\u0026#34;#kw\u0026#34;, text=\u0026#34;杭州\u0026#34;) bery.until_send_enter_by_css_selector(css_selector=\u0026#34;#kw\u0026#34;) time.sleep(2) fieldlist_shop = FieldList( Field(field_name=FieldName.SHOP_NAME, css_selector=\u0026#34;h3\u0026#34;), ) page_shop = Page(name=\u0026#34;shop_page\u0026#34;, field_list=fieldlist_shop, list_css_selector=ListCssSelector(list_css_selector=\u0026#34;#content_left \u0026gt; div.result.c-container\u0026#34;)) bery.until_click_no_next_page_by_css_selector( next_page_setup=NextPageCssSelectorSetup( page=page_shop, css_selector=\u0026#34;#page \u0026gt; a.n\u0026#34;, main_page_func=PageFunc(func=bery.from_page_get_data_list, page=page_shop) ) ) 演示 ","href":"/post/20190705212259/","title":"一个基于selenium的快速编写爬虫脚本的爬虫框架-beryllium"},{"content":"","href":"/categories/%E7%88%AC%E8%99%AB/","title":"爬虫"},{"content":"","href":"/tags/pip/","title":"pip"},{"content":"","href":"/tags/setuptools/","title":"setuptools"},{"content":"","href":"/tags/twine/","title":"twine"},{"content":" 前言 为了把项目分享给别人，我觉得还是放在pip上比较方便\n编写README.md文件 介绍自己的项目，以及如何使用\n编写setup.py文件 下面以我的配置文件为例：\n# -*- coding: utf-8 -*- import setuptools with open(\u0026#34;README.md\u0026#34;, \u0026#34;r\u0026#34;) as fh: long_description = fh.read() setuptools.setup( name=\u0026#34;beryllium\u0026#34;, version=\u0026#34;1.0.0\u0026#34;, author=\u0026#34;mannuan\u0026#34;, author_email=\u0026#34;1271990125@qq.com\u0026#34;, description=\u0026#34;A framework for spider over selenium\u0026#34;, long_description=long_description, long_description_content_type=\u0026#34;text/markdown\u0026#34;, url=\u0026#34;https://github.com/mannuan/beryllium\u0026#34;, packages=setuptools.find_packages(), classifiers=[ \u0026#34;Programming Language :: Python :: 3\u0026#34;, \u0026#34;License :: OSI Approved :: MIT License\u0026#34;, \u0026#34;Operating System :: OS Independent\u0026#34;, ], install_requires=[ \u0026#34;selenium\u0026gt;=3.14.0\u0026#34;, \u0026#34;PyVirtualDisplay\u0026gt;=0.2.1\u0026#34;, \u0026#34;pymongo\u0026gt;=3.7.1\u0026#34;, \u0026#34;PyMySQL\u0026gt;=0.9.2\u0026#34;, ], ) 安装setuptools pip install setuptools 安装twine pip install twine 打包项目 python setup.py bdist_egg # 生成类似 edssdk-0.0.1-py2.7.egg，支持 easy_install python setup.py sdist # 生成类似 edssdk-0.0.1.tar.gz，支持 pip 上传python库 我使用第二种打包方式\ntwine upload dist/打包好的python库","href":"/post/20190705200528/","title":"上传自己的python库到pip源"},{"content":"","href":"/tags/import-error/","title":"import error"},{"content":"pip install setuptools","href":"/post/20190705171744/","title":"import error No Module named Setuptools"},{"content":"","href":"/tags/regex/","title":"regex"},{"content":"if(!String.prototype.trim){ String.prototype.trim = function(){ return this.replace(/^[\\s]+/g, \u0026#39;\u0026#39;).replace(/[\\s]+$/g, \u0026#39;\u0026#39;); } } ","href":"/post/20190705105222/","title":"兼容所有浏览器的清除前后空格的方法"},{"content":"","href":"/tags/async/","title":"async"},{"content":"","href":"/tags/defer/","title":"defer"},{"content":"","href":"/tags/domcontentloaded/","title":"domContentLoaded"},{"content":"","href":"/tags/sync/","title":"sync"},{"content":"","href":"/tags/%E5%90%8C%E6%AD%A5/","title":"同步"},{"content":"","href":"/tags/%E5%BC%82%E6%AD%A5/","title":"异步"},{"content":" sync 如上图所示， HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。HTML文档解析完毕后触发DOMContentLoaded。\nasync 分为两种情况：异步脚本先执行完，dom先解析完或dom和异步脚本同时完成\n异步脚本先执行完 HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件。\ndom先解析完或dom和异步脚本同时完成 HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。\n总结 DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 和sync脚本。\ndefer defer与上面的同步和异步脚本不同，defer执行脚本的阶段必须在dom解析完毕之后。它也分为两种情况：defer先加载完和dom先解析完\ndefer先加载完 HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。\ndom先解析完 HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发domContentLoaded事件。\n总结 如果在dom解析完成以后，defer脚本没有执行，在dom解析完成后，defer会率先被执行，会延迟domContentLoaded事件的触发。\n","href":"/post/20190705101104/","title":"异步脚本、延迟脚本与DOMContentLoaded的关系"},{"content":"","href":"/tags/%E9%A6%96%E5%B1%8F%E6%97%B6%E9%97%B4/","title":"首屏时间"},{"content":" 按照有无js和css，domContentLoaded的触发时机可以分为3类 没有js和css 只有css 有js和css 首屏时间 定义：计算这个网页从空白到出现内容所花费的时间\n这段时间其实就是HTML 文档加载和解析的时间。也就是DOMContentLoaded 事件触发之前所经历的时间。\n对于首屏时间而言，js放在HTML文档的开头和结尾处效果是一样的，而js放在结尾的目的并不是为了减少首屏时间，而是由于js经常需要操纵DOM，放在后面才更能保证找到DOM节点。\n","href":"/post/20190705095553/","title":"首屏时间与domContentLoaded触发时机的关系"},{"content":"","href":"/tags/domcontent/","title":"domContent"},{"content":"","href":"/tags/jquery/","title":"jquery"},{"content":"","href":"/tags/onload/","title":"onload"},{"content":"  为了更加直观的比较它们的加载顺序，我写了下面的网页\nonload、domContentLoaded和$(document).ready(function)加载顺序对比\n 加载顺序 domContentLoaded \u0026gt; $(document).ready(function) \u0026gt; onload\ndomContentLoaded mdn的解释： 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded的写法是：\nfunction DOMContentLoaded() { console.log(\u0026#39;我是onContentLoaded\u0026#39;); } document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, DOMContentLoaded, false); // false表示在事件捕获阶段响应  $(document).ready(function) w3school的解释：当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。\n $(document).ready(function)实质上是使用了domContentLoaded方法，所以他的加载时间要早于onload\n $(document).ready(function)等价于$(function)和$().ready(function)\n 其中$().ready(function)不推荐使用\n $(document).ready(function)可以编写多个，且输出多个结果\nonload mdn解释：The load event is fired when the whole page has loaded, including all dependent resources such as stylesheets images.\nonload有两种写法：\nwindow.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { console.log(\u0026#39;page is fully loaded\u0026#39;); }); window.onload = (event) =\u0026gt; { console.log(\u0026#39;page is fully loaded\u0026#39;); };  onload与$(document).ready(function)不同，多次编写，后面的会覆盖前面的\n","href":"/post/20190705084243/","title":"onload、domContentLoaded和$(document).ready(function)的区别"},{"content":"","href":"/tags/tolocalestring/","title":"toLocaleString"},{"content":"","href":"/tags/tostring/","title":"toString"},{"content":" 注意没有toLocalString()这种方法\n 这几个方法主要在两种数据类型中使用\n* 引用类型：Object, Array, Date\n* 基本数据类型：Number, Boolean\n其中只在：Date 和Number这两种类型中有区别\n Date类型 var a = new Date(); console.log(a.toString()); // Thu Jul 04 2019 22:42:17 GMT+0800 (China Standard Time) console.log(a.toLocaleString()); // 7/4/2019, 10:42:17 PM console.log(a.valueOf()); // 1562251337216  Number类型 var a = new Number(1000); console.log(a.toString()); //1000 console.log(a.toLocaleString()); //1,000 console.log(a.valueOf()); //1000  总结  toString()方法获取的是String(传统字符串),而toLocaleString()方法获取的是LocaleString(本地环境字符串)。 如果你开发的脚本在世界范围都有人使用，那么将对象转换成字符串时请使用toString()方法来完成。 如果是为了返回时间类型的数据，推荐使用LocaleString()。 若是在后台处理字符串，请务必使用toString()。  ","href":"/post/20190704215403/","title":"toString()、toLocaleString()和valueOf()的区别"},{"content":"","href":"/tags/valueof/","title":"valueOf"},{"content":"","href":"/tags/concat/","title":"concat"},{"content":"","href":"/tags/indexof/","title":"indexOf"},{"content":"","href":"/tags/join/","title":"join"},{"content":" concat() 合并数组，返回合并后的数组 var a = [1, 2, 3]; var b = [2, 3, 4]; var c = a.concat(b); console.log(a); //[1,2,3] console.log(b); //[2,3,4] console.log(c); //[1, 2, 3, 2, 3, 4]  join() 把数组连接成为字符串，并用指定分隔符隔开 var a = [1, 2, 3]; console.log(a.join(\u0026#34;/\u0026#34;)); // 1/2/3   和python的语法不同，方向刚好是相反的，而且python要求合并的必须是字符串类型\n # -*- coding: utf-8 -*- a = [1, 2, 3] a = [str(i) for i in a] print(\u0026#34;/\u0026#34;.join(a)) pop() 取出并返回栈顶元素 var a = [1, 2, 3]; console.log(a.pop()); //3  push() 将元素压入栈，并返回栈的长度 var a = [1, 2, 3]; a.push(\u0026#34;4\u0026#34;); //4  reverse() 翻转数组，返回当前数组 var a = [1,2,3]; console.log(a.reverse()); // [3,2,1]  shift() 删除并返回数组的第一个元素 var a = [1,2,3]; console.log(a.shift()); //1  unshift() 向数组添加一个或多个元素，返回数组长度 var a = [1,2,3]; console.log(a.unshift(4,5,6)); // 6  slice 裁剪数组，返回一个新的数组对象  接收两个参数\n* start\n* end\n var a = [1,2,3]; console.log(a.slice(1, 2));  通常被用来将伪数组转化为标准数组\nfunction convert(){ console.log(a); var a = Array.prototype.slice.call(arguments); console.log(a instanceof Array); console.log(\u0026#34;a.length:\u0026#34;+a.length); } convert(1, 2, 3);  splice() 删除元素，并向数组添加元素，返回删除的元素  接收3个参数：\n1. 起始位置\n2. 选中的元素的数量\n3. 替换的元素\n var a = [1,2,3]; console.log(a.splice(0, 1, \u0026#34;4\u0026#34;)); // [\u0026#34;4\u0026#34;, 2, 3]  sort() 对数组排序, 返回当前数组 var a = [2, 3, 1]; console.log(a.sort()); // [1, 2, 3]  valueOf() 返回数组的原始值 var b = {name: \u0026#39;b\u0026#39;, order: 2} var a = [1,2,3, b]; console.log(a.valueOf());  toSource() 返回对象的源代码  只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。\n var a = [1, 2, 3]; console.log(a.toSource());  toString() 将数组转化为字符串，返回字符串 var a = [1, 2, 3]; console.log(a.toString()); // 1,2,3  toLocaleString() 将数组转化为本地字符串，返回字符串 var a = [1,2,3]; console.log(a.toLocaleString());  indexOf() 输入元素，有则返回元素下标，没有则返回-1 var a = [1,2,3]; console.log(a.indexOf(3)); // 2 console.log(a.indexOf(4)); // -1 ","href":"/post/20190704205305/","title":"js数组类型的常用方法"},{"content":"","href":"/tags/pop/","title":"pop"},{"content":"","href":"/tags/push/","title":"push"},{"content":"","href":"/tags/reverse/","title":"reverse"},{"content":"","href":"/tags/shift/","title":"shift"},{"content":"","href":"/tags/slice/","title":"slice"},{"content":"","href":"/tags/sort/","title":"sort"},{"content":"","href":"/tags/splice/","title":"splice"},{"content":"","href":"/tags/unshift/","title":"unshift"},{"content":"","href":"/tags/datetime/","title":"datetime"},{"content":"import datetime now_time_str = datetime.datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) # 类似输出20190704213307","href":"/post/20190704202704/","title":"python中的如何把当前时间转换为字符串"},{"content":"","href":"/tags/%E6%97%B6%E9%97%B4%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"时间转字符串"},{"content":" Representing Social Media Users for Sarcasm Detection  用于讽刺检测的社交媒体用户的特征表示\n 摘要 在上下文讽刺检测的背景下，两种表示作者特征的方式：\n 使用贝叶斯的方式直接表示作者的讽刺倾向；\n 密集向量嵌入可以学习到作者和文本之间的交互；\n 使用reddit评论的SARC数据集，双向的rnn可以提高性能；\n  贝叶斯的方法在同质的上下文中是足够的，密集的向量嵌入是有价值的 the Bayesian approach suffices in homogeneous contexts, whereas the added power of the dense embeddings proves valuable in more diverse ones. \n  介绍  Irony and sarcasm1 are extreme examples of context-dependence in language. Given only the text Great idea! or What a hardship!, we cannot resolve the speaker’s intentions unless we have in- sight into the circumstances of utterance – who is speaking, and to whom, and how the content relates to the preceding discourse (Clark, 1996).  反讽和讽刺是语言中依赖语境的极端例子。 鉴于只有文字好主意！ 或者说有什么困难！我们无法解决说话者的意图，除非我们对话语的情况有所了解 - 谁说话，谁说话，以及内容如何与前面的话语相关（Clark，1996）。 \n While certain texts are biased in favor of sarcastic uses (Kreuz and Caucci, 2007; Wallace et al., 2014), the non-literal nature of this phenomenon ensures that there is an important role for pragmatic inference (Clark and Gerrig, 1984).  虽然某些文本偏向于讽刺用法（Kreuz和Caucci，2007; Wallace等，2014），但这种现象的非字面性质确保了语用推理的重要作用（Clark和Gerrig，1984）。 \n The current paper is an in-depth study of one important aspect of the context dependence of sarcasm: the author. Our guiding hypotheses are that authors vary in their propensity for using sarcasm, that this propensity is influenced by more general facts about the context, and that authors have their own particular ways of indicating sarcasm.  本文是对讽刺语境依赖的一个重要方面的深入研究：作者。 我们的指导假设是作者使用讽刺的倾向各不相同，这种倾向受到关于背景的更一般事实的影响，并且作者有他们自己特定的表达讽刺的方式。 \n These hypotheses are well supported by psycholinguis- tic research (Colston and Lee, 2004; Gibbs, 2000; Dress et al., 2008), but our ability to test them cated by arrows, dense connections by diamonds. The author embedding can be null (a text-only baseline), a prior reflecting the author’s propensity for sarcasm, or a learned embedding. There are potentially multiple layers between the initial example embedding and the output sigmoid layer.  这些假设得到了心理语言学研究的很好支持（Colston和Lee，2004; Gibbs，2000; Dress等，2008），但我们大规模测试它们的能力直到最近才受到可用注释语料库的限制。 随着Self-Annotated Reddit Corpus（SARC）的发布，Khodak等人。 （2017）帮助解决了这个限制。 SARC规模庞大且多样化，其在评论和论坛中的用户分布使其特别适合于对作者及其与讽刺的关系进行建模。 \n  我们的评论文本的核心模型是具有GRU单元的双向RNN。 为了模拟作者，我们提出了两种增强这些RNN表示的策略：一种简单的贝叶斯方法，只捕获作者的原始讽刺倾向，以及一种密集的嵌入方法，允许作者和文本之间的复杂交互（图1）。 我们发现，在SARC上，简单的贝叶斯方法确实非常好，特别是在更小，更集中的论坛中。 \n On the full SARC dataset, author embeddings are able to encode more kinds of variation and interaction with the text, and thus they achieve the highest predictive accuracy. These findings extend and reinforce the prior work on user-level modeling for sarcasm (Section 2), and they indicate that simple represen- tation methods are effective here.  在完整的SARC数据集中，作者嵌入能够编码更多种类的变异和与文本的交互，因此它们实现了最高的预测准确性。 这些发现扩展并强化了先前关于讽刺的用户级建模的工作（第2节），并且它们表明简单的表示方法在这里是有效的。 \n先前的工作  A substantial literature exists around sarcasm detection. Many of the prior studies focus on the analysis of Twitter posts, which lend themselves well to sarcasm detection with NLP methods because they are available in large quantities, they tend to correspond roughly to a single utterance, and users’ hashtags in tweets (e.g., #sarcasm, #not) can provide imperfect but useful labels. A central theme of this literature is that bringing in contextual features helps performance.  关于讽刺检测存在大量文献。 许多以前的研究都集中在Twitter帖子的分析上，这些分析非常适合用NLP方法进行讽刺检测，因为它们可以大量使用，它们往往大致相当于一个单一的话语，而用户的话题标签也是如此（例如， #sarcasm，＃not）可以提供不完美但有用的标签。 该文献的中心主题是引入上下文特征有助于提高性能。 \n Gonza ́lez-Iba ́nez et al. (2011) trained classifiers using a combination of lexical and pragmatic features, including emoticons and whether the user was responding to another tweet (see also Felbo et al. 2017). Bamman and Smith (2015) extend this kind of analysis with additional information about the context. Of special interest here are their contextual features: the author’s historical sentiment, topics, and terms; the addressee; and features drawn from historical interactions between the author and addressee. The study finds most features to be useful, but a model trained on the tweet and author features alone achieved essentially the same performance (84.9% accuracy) as a model trained on all features (85.1%).  Gonza lez-Iba nez等。 （2011）使用词汇和实用特征（包括表情符号以及用户是否对另一条推文做出回应）的组合训练分类器，（另见Felbo等人2017）。 Bamman和Smith（2015）利用有关背景的其他信息扩展了这种分析。 这里特别感兴趣的是他们的语境特征：作者的历史情感，主题和术语; 收件人; 以及作者和收件人之间历史互动的特征。 该研究发现大多数特征是有用的，但仅在推文和作者特征上训练的模型实现了与在所有特征上训练的模型（85.1％）基本相同的性能（84.9％准确度）。 \n In a similar vein, Rajadesingan et al. (2015) used a complex combination of features from users’ Twitter histories, including sentiment, grammar, and word choice, as inputs into their model, and report a ≈7% gain in classification accuracy upon adding these features to a baseline n-gram classifier.  类似地，Rajadesingan等人。 （2015）使用来自用户的Twitter历史的复杂功能组合，包括情感，语法和单词选择，作为其模型的输入，并在将这些功能添加到基线n-gram时报告增加约7％的分类准确度。 \n Recent papers have also applied deep learning methods to detecting sarcastic tweets. Poria et al. (2016) use a combination convolutional–SVM architecture with auxiliary sentiment input features. The architecture of Zhang et al. (2016) includes an RNN, and uses contextual features as well as tweet text for inputs.  最近的论文还采用深度学习方法来检测讽刺性推文。 Poria等。 （2016）使用具有辅助情感输入特征的组合卷积SVM架构。 张等人的建筑。 （2016）包括RNN，并使用上下文特征以及用于输入的推文文本。 \n Amir et al. (2016) extend the work of Bamman and Smith by generating author embeddings to reflect users’ word-usage patterns (but not sarcasm history) in a manner similar to the paragraph vectors introduced by Le and Mikolov (2014). With the inclusion of these embeddings, their convolu- tional neural network (CNN) achieves a 2% gain in accuracy over that of Bamman and Smith.  Amir等。 （2016）通过生成作者嵌入来扩展Bamman和Smith的工作，以类似于Le和Mikolov（2014）引入段落向量的方式反映用户的单词使用模式（但不是讽刺历史）。 通过包含这些嵌入，他们的卷积神经网络（CNN）比Bamman和Smith的准确度提高了2％。 \n Ghosh and Veale (2017) present a combination CNN/LSTM (long short-term memory RNN) architecture that takes as inputs user affect inferred from recent tweets as well as the text of the tweet and that of the parent tweet. When a tweet was addressed to someone by name, the name of the addressee was included in the text representation of the tweet, providing a loose link between interlocutors (West et al., 2014) and a ≈1% gain in performance for some data sets.  Ghosh和Veale（2017）提出了一种组合CNN / LSTM（长期短期记忆RNN）架构，该架构将用户影响作为输入从最近的推文以及推文的文本和父推文的推文中推断出来。 当推文通过名字发给某人时，收件人的姓名包含在推文的文本表示中，提供了对话者之间的松散联系（West et al。，2014）和某些数据的性能提升约1％集。 \n There has also been a small amount of previous work on Reddit data for sarcasm (Tay et al., 2018; Ghosh and Muresan, 2018). Wallace et al. (2014) explore a hand-labeled dataset of ≈3K Reddit comments from six subreddits. They report that, when human graders attempted to mark comments as sarcastic or not sarcastic, they needed additional context like subreddit norms and author history roughly 30% of the time, and that the comments which graders found ambiguous were largely the same as those on which a baseline bag-of-words classifier tended to make mistakes. In a follow-up study, Wallace et al. (2015) find that semantic cues for sarcasm differ by subreddit, and they show classifier accuracy gains when modeling subreddit-specific variation.  还有一些关于讽刺的Reddit数据的先前工作（Tay等，2018; Ghosh和Muresan，2018）。 华莱士等人。 （2014）探索了来自六个subreddits的≈3KReddit评论的手工标记数据集。 他们报告说，当人类评分者试图将评论标记为讽刺或不讽刺时，他们需要额外的背景，如subreddit规范和作者历史大约30％的时间，并且评分者发现含糊不清的评论与那些评论大致相同。 基线词袋分类器往往会出错。 在一项后续研究中，Wallace等人。 （2015）发现讽刺的语义线索因subreddit而不同，并且在建模subreddit特定变体时显示分类器准确度增益。 \n The work that is closest to our own is that of Hazarika et al. (2018), who also experiment on the SARC dataset. Their model learns author, forum, and text embeddings, and they show that all three kinds of representation contribute positively to the overall performance. We take a much simpler approach to author embeddings and do not include forum embeddings, and we report comparable performance (Section 6). We take this as further indication of the value of author features for modeling sarcasm.  与我们最接近的工作是Hazarika等人的工作。 （2018），他也在SARC数据集上进行实验。 他们的模型学习作者，论坛和文本嵌入，他们表明这三种表示对整体表现有积极贡献。 我们采用更简单的方法来创作嵌入并且不包括论坛嵌入，并且我们报告可比性能（第6节）。 我们将此作为进一步表明作者对讽刺建模的特征的价值。 \nSARC数据集 自我注释的Reddit语料库（SARC）由Khodak等人创建。 （2017）.2它包括前所未有的533M评论。 语料库是自我注释的，因为如果评论作者用“/s”标签标记它，则评论被认为是讽刺性的。因此，积极的例子基本上是那些作者认为含糊不清以明确标记为讽刺的例子，这意味着预测问题实际上是为了确定哪些评论不仅是讽刺性的，而且既讽刺又不明显。\n数据集以多种方式过滤，并且具有良好的精确度（仅约1％假阳性率）但回忆率较低（相对于0.25％误报，2％假阴性，或约11％回忆）。 为了缓解由低召回率引起的问题，数据集还包括一个平衡样本，其中评论是成对提供的，两者都响应同一个父评论，并且两个中只有一个被标记为讽刺。 所有评论都附有原始对话的祖先评论，作者信息以及Reddit用户投票的分数。\n该数据集为讽刺检测提供了许多优势。 首先，它比过去的讽刺数据集大得多，这使得能够训练更复杂的模型。 此外，大多数讽刺检测工作都集中在推文上，这些推文非常简短，往往使用缩写和非典型语言。 Reddit评论不受长度限制，因此更能代表人们通常的写作方式。 最后，Reddit被组织成被称subreddits的局部定义社区，每个社区都有自己的社区规范和语言模式。 通过从一些次级数据中提供大量数据，SARC促进了对次级域的比较分析，并且更一般地提供了对社区之间差异的看法。\n表1提供了整个语料库的基本统计数据以及我们在实验中关注的子目标。\n模型  Our baseline model is a bidirectional RNN with GRU cells (BiGRU; Cho et al. 2014). We tried variants with LSTM cells and did not observe a significant difference in performance. We therefore chose to use GRU cells as the model with fewer parameters.  我们的基线模型是具有GRU单元的双向RNN（BiGRU; Cho等人，2014）。 我们尝试了使用LSTM单元的变体，并没有观察到性能的显着差异。因此，我们选择使用参数较少的GRU单元作为模型。 \n The inputs to the BiGRU model are users’ comments, which are split into words (and in the case of conjunctions, subwords) and punctuation marks and are converted to word vectors. The final states of the two directions of the BiGRU are concatenated with each other and run through either a single fully-connected linear layer or two fully-connected linear layers with a rectified linear unit in between. The output of the final linear layer is fed through a sigmoid function which outputs the estimated probability of sarcasm. This baseline does not take author information into account: for each comment, only the words of the comment are considered as inputs.  BiGRU模型的输入是用户的注释，它们被分成单词（在连词，子词的情况下）和标点符号，并被转换为单词向量。 BiGRU的两个方向的最终状态彼此连接并且通过单个完全连接的线性层或两个完全连接的线性层，其间具有整流的线性单元。 最终线性层的输出通过S形函数馈送，该函数输出估计的讽刺概率。 此基线不考虑作者信息：对于每个评论，只有评论的单词被视为输入。 \n The Bayesian prior model extends the Bi-GRU with the sarcastic and non-sarcastic comment counts for authors seen in the training data, which serves as a prior for sarcasm frequency. This version of the model takes as inputs both a representation of the comment and the author representation xauthor ∈ Z2≥0 to estimate the probability of sarcasm. The model can be interpreted as computing a posterior probability of sarcasm given both the comment and the prior of previous sarcastic and non-sarcastic comment counts author modeling reduced to a Bernoulli prior. For previously unseen authors, xauthor is set to (0, 0).  贝叶斯先验模型扩展了Bi-GRU，其中对于在训练数据中看到的作者的讽刺和非讽刺评论计数，其作为讽刺频率的先验。 该版本的模型将注释的表示和作者表示xauthor∈Z2≥0作为输入，以估计讽刺的概率。 考虑到先前的讽刺和非讽刺评论计数作者建模减少到伯努利先前的评论和先验，该模型可以被解释为计算讽刺的后验概率。 对于以前看不见的作者，xauthor设置为（0,0）。 \n The author embedding approach extends the baseline BiGRU in a more sophisticated way. Here, each author seen in the training data is associated with a randomly initialized embedding vector xauthor ∈ R15, which is then provided as an input to the model along with a representation of the words of the comment. A special randomly initialized vector xUNK is used for previously unseen authors. The author embeddings are updated during training, with the goal of learning more sophisticated individualized patterns of sarcasm than the Bayesian prior allows. We experimented with training the xUNK vector on infrequently-seen authors (fewer than 5 comments in the training set) instead of using a random vector, and found some suggestions of improved performance. However, as the differences in performance were not substantial enough to change the relative performance of the different models, we report the results for the simpler random-xUNK model.  作者嵌入方法以更复杂的方式扩展了基线BiGRU。 这里，在训练数据中看到的每个作者与随机初始化的嵌入向量xauthor∈R15相关联，然后将其作为输入提供给模型以及评论的单词的表示。 一个特殊的随机初始化向量xUNK用于以前看不见的作者。 作者嵌入在训练期间更新，目的是学习比贝叶斯先验允许的更复杂的个性化讽刺模式。 我们尝试在不经常看到的作者上训练xUNK矢量（训练集中少于5条评论）而不是使用随机向量，并找到了一些改进性能的建议。 但是，由于性能差异不足以改变不同模型的相对性能，我们报告了更简单的random-xUNK模型的结果。 \n实验  We conducted three sets of experiments, one for each model, to evaluate the effectiveness of the different approaches to author modeling. Each set of experiments was conducted on five datasets: the balanced version of the entire corpus as well as the balanced and unbalanced versions of the r/politics and r/AskReddit subcorpora (Table 1).  我们进行了三组实验，每个模型一组，以评估不同方法对作者建模的有效性。 每组实验都在五个数据集上进行：整个语料库的平衡版本以及r / politics和r / AskReddit子目录的平衡和非平衡版本（表1）。 \n In all cases, the raw comment data was tokenized into words and punctuation marks, with components of contractions treated as individual words. We mapped tokens to FastText embedding vectors which had been trained, using subword infomation, on Wikipedia 2017, the UMBC webbase corpus, and the statmt.org news dataset (Mikolov et al., 2018). While vectors existed for nearly 100% of tokens generated, exceptions were mapped to a randomly initialized UNK vector.  在所有情况下，原始评论数据被标记为单词和标点符号，其中收缩的组成部分被视为单个单词。 我们使用子词信息，在Wikipedia 2017，UMBC webbase语料库和statmt.org新闻数据集（Mikolov等，2018）上将令牌映射到已经训练过的FastText嵌入向量。 虽然生成的标记几乎占100％，但异常被映射到随机初始化的UNK向量。 \n All models were trained with early stopping on a randomly partitioned holdout set of either 5% of the data for balanced subreddit corpora or 1% for the others. The performance of the model, as used for hyperparameter tuning, was evaluated against a second holdout set, generated in the same manner as the first holdout set but disjoint from both it and the portion of the data used for training.  对于平衡的subreddit语料库中的5％数据的随机分区保持集，或者对于其他模型，1％的所有模型都进行了早期停止训练。 用于超参数调整的模型的性能是针对第二保持集来评估的，该第二保持集以与第一保持集相同的方式生成，但是与它和用于训练的数据部分不相交。 \n Hyperparameters were tuned to maximize model performance as evaluated in this manner, starting with a randomized search process and fine-tuned manually. The final evaluation was conducted against the test set, with a single randomly partitioned holdout set from the training data again used for early stopping. We applied dropout (Srivastava et al., 2014) during training before and between all linear layers. For additional regularization, we also applied an l2-norm penalty to the linear weights but not to the GRU weights.  调整超参数以最大化模型性能，以这种方式评估，从随机搜索过程开始并手动微调。 最终评估是针对测试集进行的，其中来自训练数据的单个随机分区的保持集再次用于早期停止。 我们在所有线性层之前和之间的训练期间应用了辍学（Srivastava等，2014）。 对于额外的正则化，我们还对线性权重应用了l2范数惩罚，但没有对GRU权重应用。 \n We attempted other model variations, including multiple GRU layers and an attention mechanism for GRU outputs, but did not observe any gains in performance from the larger models.  我们尝试了其他模型变体，包括多个GRU层和GRU输出的注意机制，但没有观察到较大模型的性能增益。 \n结果和讨论 定量评估  Table 2 reports the means of 10 runs to control for variation deriving from randomness in the optimization process (Reimers and Gurevych, 2017).  表2报告了10次运行的方法，以控制优化过程中随机性的变化（Reimers和Gurevych，2017）。 \n  \n Where there is overlap between our experiments and those of Hazarika et al. (2018) (CASCADE), our model is highly competitive. We slightly under-perform on the full balanced dataset but come out ahead on r/politics. This is striking because our model makes use of much less information. First, unlike CASCADE, we do not have forum embeddings. Second, CASCADE author embeddings involve extensive feature engineering including “stylometric” and “personality” features. Our author embeddings, on the other hand, are either simple empirical estimates (Bayesian priors) or learned embeddings with random initializations, in both cases allowing simpler model specification and training, and more flexibility on the task for which they are used.  我们的实验和Hazarika等人的实验之间存在重叠。 （2018）（CASCADE），我们的模型竞争激烈。 我们在完全平衡的数据集上略显不足，但在政治上领先一步。 这很引人注目，因为我们的模型使用的信息要少得多。 首先，与CASCADE不同，我们没有论坛嵌入。 其次，CASCADE作者嵌入涉及广泛的特征工程，包括“样式”和“个性”特征。 另一方面，我们的作者嵌入要么是简单的经验估计（贝叶斯先验），要么是随机初始化的学习嵌入，在这两种情况下都允许更简单的模型规范和训练，并且在使用它们的任务上具有更大的灵活性。 \n There is also evidence that the BiGRU yields better representations of texts than does Hazarika et al.’s CNN-based model. Our ‘No embed’ model is akin to their CASCADE with no contextual features, which achieves only 0.66 on the full balanced corpus and 0.70 on the r/politics balanced dataset. Both numbers are well behind our ‘No embed’. Unfortunately, we do not have space for a fuller study of the similarities and differences between our model and CASCADE.  还有证据表明，与Hazarika等人的基于CNN的模型相比，BiGRU可以产生更好的文本表示。 我们的“无嵌入”模型类似于没有上下文特征的CASCADE，在完全平衡语料库上只有0.66，在r / politics平衡数据集上只有0.70。 这两个数字都远远落后于我们的\u0026rsquo;No embed\u0026rsquo;。 不幸的是，我们没有足够的空间来更全面地研究我们的模型和CASCADE之间的相似点和不同点。 \n Both of our methods for representing authors perform well. This is perhaps especially striking for the unbalanced experiments, where the percentage of sarcastic comments is tiny (Table 1). The two methods perform differently on individual forums than on the full dataset. For the r/politics and r/AskReddit communities, the Bayesian priors give the best results. The situation is reversed for the full dataset, where the high-dimensional embeddings outperform the Bayesian priors. This likely reflects two interacting factors. First, with smaller, more focused forums, it is harder to learn good author embeddings, so the simple prior is more reliable. Second, on the full dataset, there are more examples, and also more complex interactions between authors and their texts, so the added representational power of the embeddings proves justified.  我们用于表示作者的两种方法都表现良好。 对于不平衡的实验而言，这可能尤其引人注目，其中讽刺评论的百分比很小（表1）。 这两种方法在各个论坛上的表现与在完整数据集上的表现不同。 对于r / politics和r / AskReddit社区，贝叶斯先验给出了最好的结果。 对于完整数据集，情况相反，其中高维嵌入优于贝叶斯先验。 这可能反映了两个相互作用的因素。 首先，对于更小，更集中的论坛，学习好作者嵌入更难，所以简单的先验更可靠。 其次，在完整的数据集上，有更多的例子，以及作者和他们的文本之间更复杂的交互，因此嵌入的附加表征能力证明是合理的。 \n定性比较  Table 3 provides example predictions from the different models. Each example is taken from the holdout set of a run in which all three models were trained on the same training set and evaluation was conducted on the same holdout set.  表3提供了来自不同模型的示例预测。 每个示例取自跑步的保持集，其中所有三个模型都在相同的训练集上训练，并且在相同的保持集上进行评估。 \n  对于讽刺和非讽刺的评论，作者建模可能有助于消除歧义。 例如，在示例1和示例2中，省略作者建模导致不正确的预测，但仅包括作者单独使用讽刺的频率足以将预测从不正确变为正确。 \n  在例如示例3和4的情况下，贝叶斯先验不足，包括作者个性化讽刺模式的模型更强大。 也就是说，更复杂的嵌入模型可能会失败，如示例5所示，其中较简单的模型进行正确的预测，但事实并非如此。 这似乎发生在非讽刺的例子中，其中嵌入模型偶尔会强烈影响预测的讽刺概率。 显然，作者有更多个性化的讽刺模式而不是非讽刺模式。 \n  根据贝叶斯和多维嵌入模型的相对表现来判断（表2），当有更多的训练数据可用时，多维模型比贝叶斯模型失去更多的分歧。 但是，如果没有，它就会过度拟合，以至于它对作者讽刺模式的预测不如贝叶斯方法有用。 这表明了未来的探索方向：最有用的模型可能是那些具有更多可用示例的作者的复杂性扩展，以及对于那些拥有更少示例的人来说缩小的模型。 \n  本文评估了两种数据驱动的方法，用于模拟作者在讽刺检测中的作用。 两者都证明有效。 如Hazarika等人所示。 （2018），类似的技术可以扩展到上下文的其他方面。 虽然我们的实验不支持添加这些表示，但我们认为听众也依赖于它们，因此这里额外的计算建模工作可能会证明是富有成效的。 \n","href":"/post/20190704162010/","title":"Representing Social Media Users for Sarcasm Detection论文翻译和解读"},{"content":"","href":"/tags/mac/","title":"MAC"},{"content":" 选区域截图默认快捷键 Shift+command+4  默认保存目录 ~/Desktop  修改目录 defaults write com.apple.screencapture location \u0026#34;~/Pictures/ScreenShot\u0026#34; 截图默认后缀 png  修改后缀 defaults write com.apple.screencapture type jpg 删除默认时间后缀 defaults write com.apple.screencapture \u0026#34;include-date\u0026#34; 0 修改默认的文件名称 defaults write com.apple.screencapture name \u0026#34;screenshot\u0026#34; 参看配置 defaults read com.apple.screencapture 输出如下： { \u0026quot;last-messagetrace-stamp\u0026quot; = \u0026quot;583174121.285828\u0026quot;; \u0026quot;last-selection\u0026quot; = { Height = 529; Width = 1041; X = 507; Y = 262; }; \u0026quot;last-selection-display\u0026quot; = 0; location = \u0026quot;~/Pictures/ScreenShot\u0026quot;; name = screenshot; type = jpg; }  缺点分析 mac自带的截图工具，不能修改时间的格式，而且这种格式有空格，不利于作为文件名。虽然可以去除时间后缀，但是时间信息很重要。同时，即使没有时间后缀，生成的图片名中还是存在空格。鉴于上面复杂的问题，我权衡利弊之后果断放弃这个mac自带的截图工具。\n更好的截图工具 腾讯开发的一款名为\u0026rdquo;截图\u0026rdquo;的截图工具，它可以自定义目录，自动生成的文件名包含时间信息且没有空格。 ","href":"/post/20190701204246/","title":"Mac截图的相关设置"},{"content":"","href":"/tags/%E6%88%AA%E5%9B%BE/","title":"截图"},{"content":"","href":"/tags/acl/","title":"ACL"},{"content":"","href":"/tags/cisco/","title":"Cisco"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 掌握路由器上编号的标准 IP 访问列表规则及配置。\n需求分析 只允许网段172.16.2.0与172.16.4.0的主机进行通信，不允许172.16.1.0去访问172.16.4.0网段的主机。\n实验原理 IP ACL(IP 访问控制列表或IP访问列表)是实现对流经路由器或交换机的数据包根据一定的规则进行过滤，从而提高网络可管理性和安全性。 IP ACL分为两种:标准IP访问列表和扩展IP访问列表。 标准IP访问列表可以根据数据包的源IP地址定义规则，进行数据包的过滤。 扩展IP访问列表可以根据数据包的源IP、目的IP、源端口、目的端口、协议来定义规则，进行数据包的过滤。 IP ACL基于接口进行规则的应用，分为:入栈应用和出栈应用。 入栈应用是指由外部经该接口进行路由器的数据包进行过滤。 出栈应用是指路由器从该接口向外转发数据时进行数据包的过滤。 IP ACL 的配置有两种方式:按照编号的访问列表，按照命名的访问列表。 标准IP访问列表编号范围是1~99、1300~1999，扩展IP访问列表编号范围是100~199、2000~2699。\n实验拓扑 选择设备  路由器：2台Generic（从左边数第一个） 主机：3台Generic（从左边数第一个）  实验demo 实验十三-利用ip标准访问控制列表acl进行网络流量的控制.pkt\n实验步骤 设置左边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter loop0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter loop1 Router(config-if)#ip address 172.16.2.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter se2/0 Router(config-if)#clock rate 64000 Router(config-if)#ip address 172.16.3.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#exit Router(config)#ip route 0.0.0.0 0.0.0.0 172.16.3.2 Router(config)#end Router#sh run  设置右边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#clock rate 64000 Router(config-if)#ip address 172.16.3.2 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter fa0/0 Router(config-if)#ip address 172.16.4.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#exit Router(config)#ip route 0.0.0.0 0.0.0.0 172.16.3.1 Router(config)#access-list 10 deny 172.16.1.0 0.0.0.255 Router(config)#access-list 10 permit 172.16.2.0 0.0.0.255 Router(config)#inter fa0/0 Router(config-if)#ip access-group 10 out Router(config-if)#end Router#sh run  设置主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.4.2 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.4.1  测试搭建好的拓扑 1、打开下面主机的命令行：\nPC\u0026gt;ping 172.16.1.1 ...ping不通 PC\u0026gt;ping 172.16.2.1 ...可以ping通  ","href":"/post/20190701194642/","title":"实验十三 利用ip标准访问控制列表acl进行网络流量的控制"},{"content":"","href":"/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/","title":"流量控制"},{"content":"","href":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/","title":"网络实验"},{"content":"","href":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络"},{"content":"","href":"/tags/vlan/","title":"VLAN"},{"content":"","href":"/tags/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/","title":"单臂路由"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 掌握如何路由器端口上划分子接口、封装 Dot1Q(IEEE 802.1Q)协议，实现VLAN间的路由。\n需求分析 需要在交换机上配置 VLAN，然后在路由器连接交换机的端口上划分子接口，给相应的VLAN设置IP地址，以实现 VLAN间的路由。\n实验原理 在交换网络中，通过 VLAN 对一个物理网络进行了逻辑划分，不同的 VLAN 之间是无法直接访问的，必须通过三层的路由设备进行连接。一般利用路由器或三层交换机来实现不 同 VLAN 之间的互相访问。 将路由器和交换机相连，使用 IEEE 802.1Q 来启动一个路由器上的子接口成为干道模式，就可以利用路由器来实现 VLAN 之间的通信。 路由器可以从某一个VLAN接收数据包并且将这个数据包转发到另外的一个VLAN，要实施VLAN间的路由，必须在一个路由器的物理接口上启用子接口，也就是将以太网物理 接口划分为多个逻辑的、可编址的接口，并配置成干道模式，每个VLAN对应一个这种接口，这样路由器就能够知道如何到达这些互联的VLAN。\n实验拓扑 选择设备  交换机：1台2960 路由器：1台Generic（从左边数第一个） 主机：2台Generic（从左边数第一个）  实验demo 实验十二-利用单臂路由实现vlan间路由.pkt\n实验步骤 设置交换机 Switch\u0026gt;en Switch#conf t Switch(config)#vlan 10 Switch(config-vlan)#vlan 20 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/2 Switch(config-if)#switchport access vlan 20 Switch(config-if)#inter fa0/3 Switch(config-if)#switchport mode trunk Switch(config-if)#end Switch#sh run  设置路由器 no Router\u0026gt;en Router#conf t Router(config)#inter fa0/0 Router(config-if)#no ip address Router(config-if)#no shut Router(config-if)#inter fa0/0.10 Router(config-subif)#encapsulation dot1Q 10 Router(config-subif)#ip address 192.168.10.1 255.255.255.0 Router(config-subif)#inter fa0/0.20 Router(config-subif)#encapsulation dot1Q 20 Router(config-subif)#ip address 192.168.20.1 255.255.255.0 Router(config-subif)#end Router#sh run  设置左边的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 192.168.10.2 Subnet Mask: 255.255.255.0 Default Gateway: 192.168.10.1  设置右边的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 192.168.20.2 Subnet Mask: 255.255.255.0 Default Gateway: 192.168.20.1  测试搭建好的拓扑 1、打开左边主机的命令行：\nPC\u0026gt;ping 192.168.20.2 ...  2、打开右边主机的命令行：\nPC\u0026gt;ping 192.168.10.2 ...  ","href":"/post/20190701192111/","title":"实验十二 利用单臂路由实现vlan间的路由"},{"content":"","href":"/tags/ospf/","title":"OSPF"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 掌握在路由器上配置OSPF单区域。\n需求分析 需要在路由器和交换机上配置OSPF路由协议，使全网互通，从而实现信息的共享和传递。\n实验原理 OSPF(Open Shortest Path First，开放式最短路径优先)协议，是目前网络中应用最广泛 的路由协议之一。属于内部网关路由协议，能够适应各种规模的网络环境，是典型的链路状 态(link-state)协议。 OSPF 路由协议通过向全网扩散本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库(LSDB)，然后路由器采用SPF算法，以自己为根，计算到达 其他网络的最短路径，最终形成全网路由信息。 OSPF属于无类路由协议，支持VLSM(变长子网掩码)。OSPF是以组播的形式进行链 路状态的通告的。 在大规模的网络环境中，OSPF支持区域的划分，将网络进行合理规划。划分区域时必须存在area0(骨干区域)。其他区域和骨干区域直接相连，或通过虚链路的方式连接。\n实验拓扑 选择设备  交换机：1台3650-24PS 路由器：2台Generic（从左边数第一个）  实验demo 实验十一ospf基本配置.pkt\n实验步骤 设置三层交换机 Switch\u0026gt;en Switch(config)#vlan 10 Switch(config-vlan)#vlan 50 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/2 Switch(config-if)#switchport access vlan 10 Switch(config-if)#inter fa0/3 Switch(config-if)#switchport access vlan 50 Switch(config-if)#inter vlan 10 Switch(config-if)#ip address 172.16.1.2 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#inter vlan 50 Switch(config-if)#ip address 172.16.5.1 255.255.255.0 Switch(config-if)#no shut %ospf取别名为123，只能设置为数字 Switch(config-if)#router ospf 123 Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0 Switch(config-router)#network 172.16.5.0 0.0.0.255 area 0 Switch(config-if)#end Switch#sh run  设置左边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter fa0/0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#inter se2/0 Router(config-if)#ip address 172.16.2.1 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#router ospf 123 Router(config-router)#network 172.16.1.0 0.0.0.255 area 0 Router(config-router)#network 172.16.2.0 0.0.0.255 area 0 Router(config-router)#end Router#sh run  设置右边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 172.16.2.2 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shut Router(config-if)#inter fa0/0 Router(config-if)#ip address 172.16.3.1 255.255.255.0 Router(config-if)#no shut Router(config-if)#router ospf 123 Router(config-router)#network 172.16.2.0 0.0.0.255 area 0 Router(config-router)#network 172.16.3.0 0.0.0.255 area 0 Router(config-router)#end Router#sh run  设置上面左边的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.1.3 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.1.2  设置上面右边的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.5.2 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.5.1  设置下面的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.3.2 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.3.1  测试搭建好的拓扑 1、打开上面左边主机的命令行：\nPC\u0026gt;ping 172.16.5.2 ... PC\u0026gt;ping 172.16.3.2 ...  2、打开上面右边主机的命令行：\nPC\u0026gt;ping 172.16.1.3 ... PC\u0026gt;ping 172.16.3.2  3、打开下面主机的命令行：\nPC\u0026gt;ping 172.16.1.3 ... PC\u0026gt;ping 172.16.5.2 ...  4、打开左边的路由器的命令行：\nRouter\u0026gt;en Router#sh ip route 得到下面类似的输出： 172.16.0.0/24 is subnetted, 4 subnets C 172.16.1.0 is directly connected, FastEthernet0/0 C 172.16.2.0 is directly connected, Serial2/0 O 172.16.3.0 [110/782] via 172.16.2.2, 00:18:39, Serial2/0 O 172.16.5.0 [110/2] via 172.16.1.2, 00:04:23, FastEthernet0/0  5、打开右边的路由器的命令行：\nRouter\u0026gt;en Router#sh ip route 得到下面类似的输出： 172.16.0.0/24 is subnetted, 4 subnets O 172.16.1.0 [110/782] via 172.16.2.1, 00:20:28, Serial2/0 C 172.16.2.0 is directly connected, Serial2/0 C 172.16.3.0 is directly connected, FastEthernet0/0 O 172.16.5.0 [110/783] via 172.16.2.1, 00:05:59, Serial2/0  ","href":"/post/20190701182805/","title":"实验十一 ospf基本配置"},{"content":"","href":"/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/","title":"路由协议"},{"content":"","href":"/tags/rip/","title":"RIP"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 掌握在路由器上如何配置 RIP 路由协议。\n需求分析 两台路由器通过快速以太网端口连接在一起，每个路由器上设置2个Loopback端口模拟子网，在所有端口运行RIP路由协议，实现所有子网间的互通。\n实验原理 RIP(Routing Information Protocols，路由信息协议)是应用较早、使用较普遍的 IGP(Interior Gateway Protocol，内部网关协议)，适用于小型同类网络，是典型的距离矢量 (distance-vector)协议。 RIP 协议以跳数做为衡量路径开销的，RIP 协议里规定最大跳数为 15。 RIP 在构造路由表时会使用到 3 种计时器:更新计时器、无效计时器、刷新计时器。 它让每台路由器周期性地向每个相邻的邻居发送完整的路由表。路由表包括每个网络或子网 的信息，以及与之相关的度量值。\n实验拓扑 选择设备  路由器：2台Generic（从左边数第一个）  实验demo 实验十-RIP路由协议基本配置.pkt\n实验步骤 设置左边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 192.168.1.1 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shut Router(config-if)#inter loop0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#inter loop1 Router(config-if)#ip address 172.16.2.1 255.255.255.0 Router(config-if)#router rip Router(config-router)#network 172.16.0.0 Router(config-router)#network 192.168.1.0 Router(config-router)#end Router#sh run  设置右边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 192.168.1.2 255.255.255.0 Router(config-if)#no shut Router(config-if)#clock rate 64000 Router(config-if)#inter loop0 Router(config-if)#ip address 10.1.1.1 255.255.255.0 Router(config-if)#inter loop1 Router(config-if)#ip address 10.2.2.1 255.255.255.0 Router(config-if)#router rip Router(config-router)#network 192.168.1.0 Router(config-router)#network 10.0.0.0 Router(config-router)#end Router#sh run  测试搭建好的拓扑 1、打开左边路由器的命令行：\nRouter#ping 10.1.1.1 ... Router#ping 10.2.2.1 ... Router#sh ip route 获得如下输出： R 10.0.0.0/8 [120/1] via 192.168.1.2, 00:00:13, Serial2/0 172.16.0.0/24 is subnetted, 2  2、打开右边路由器的命令行：\nRouter#ping 172.16.1.1 ... Router#ping 172.16.2.1 ... Router#sh ip route 获得如下输出： R 172.16.0.0/16 [120/1] via 192.168.1.1, 00:00:01, Serial2/0  ","href":"/post/20190701172233/","title":"实验十 RIP路由协议基本配置"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n 当前的实验无法在6.0.0.0045以上版本测试成功\n 实验目的 利用三层交换机跨交换机实现VLAN间路由。\n需求分析 在二层交换机上划分VLAN配置Trunk实现不同VLAN的主机接入，在三层交换机上划分VLAN配置Trunk并配置SVI接口实现不同VLAN间路由。\n实验原理 在二层交换机上划分VLAN可实现不同VLAN的主机接入，而VLAN间的主机通信为不同网段间的通信，需要通过三层设备对数据进行路由转发才可以实现，通过在三层交换机上为各VLAN配置SVI接口，利用三层交换机的路由功能可以实现VLAN间的路由。\n实验拓扑 选择设备  交换机：1台3560-24PS，2台2960 移动终端：2台Generic（从左边数第一个）  实验demo 实验六-跨交换机实现vlan间路由.pkt\n实验步骤 设置最上面的交换机 Switch\u0026gt;en Switch#conf t Switch(config)#vlan 10 Switch(config-vlan)#vlan 20 Switch(config)#inter vlan 10 Switch(config-if)#ip address 192.168.10.1 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#inter vlan 20 Switch(config-if)#ip address 192.168.20.1 255.255.255.0 Switch(config-if)#no shut Switch(config-if)#end Switch#sh run  设置左边的2960交换机 Switch\u0026gt;en Switch#conf t Switch(config)#inter fa0/2 Switch(config-if)#switch mode trunk Switch(config-if)#vlan 10 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 10 Switch(config-if)#end Switch#sh run  设置右边的2960交换机 Switch\u0026gt;en Switch#conf t Switch(config)#inter fa0/2 Switch(config-if)#switch mode trunk Switch(config-if)#vlan 20 Switch(config-vlan)#inter fa0/1 Switch(config-if)#switchport access vlan 20 Switch(config-if)#end Switch#sh run  设置左边的主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 192.168.10.2 Subnet Mask: 255.255.255.0 Default Gateway: 192.168.10.1  设置右边主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 192.168.20.2 Subnet Mask: 255.255.255.0 Default Gateway: 192.168.20.1  测试搭建好的拓扑 1、打开左边主机的命令行：\nPC\u0026gt;ping 192.168.20.2 ...  2、打开右边主机的命令行：\nPC\u0026gt;ping 192.168.10.2 ...  ","href":"/post/20190701105039/","title":"实验六 跨交换机实现vlan间的路由"},{"content":"","href":"/tags/nat/","title":"NAT"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 配置网络地址变换，为私有地址的用户提供到外部网络的资源的访问。\n需求分析 ISP 提供商给 IT 企业的一段公共 IP 地址的地址段为 200.1.1.200~100.1.1.210，需要内网使用这段址去访问 Internet，考虑到包括安全在内的诸多因素，公司希望对外部隐藏内部 网络。\n实验原理 在路由器上定义内网与外网接口，利用 NAT 地址池实现内网对外网的访问，并把内网 隐藏起来。\n实验拓扑 选择设备  交换机：1台2960 移动终端：2台Generic（从左边数第一个） 路由器：2台Generic（从左边数第一个）  实验demo 实验九-配置动态nat.pkt\n实验步骤 设置左边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.2 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shutdown Router(config-if)#end Router#sh run  设置右边的路由器 no Router\u0026gt;en Router#conf t Router(config)#ip route 0.0.0.0 0.0.0.0 se2/0 Router(config)#access-list 10 permit 172.16.1.0 0.0.0.255 Router(config)#ip nat pool test 200.1.1.200 200.1.1.210 netmask 255.255.255.0 Router(config)#ip nat inside source list 10 pool test Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.1 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#ip nat outside Router(config-if)#no shut Router(config-if)#inter fa0/0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#ip nat inside Router(config-if)#no shut Router(config)#end Router#sh run  设置上面主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.1.5 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.1.1  设置下面主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.1.6 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.1.1  测试搭建好的拓扑 1、打开上面主机的命令行：\nRouter\u0026gt;ping 200.1.1.2 ...  2、打开下面主机的命令行：\nRouter\u0026gt;ping 200.1.1.2 ...  2、打开右边的路由器的命令行：\nRouter\u0026gt;en Router#sh ip nat tran 得到下面类似的输出： Pro Inside global Inside local Outside local Outside global icmp 200.1.1.200:1 172.16.1.5:1 200.1.1.2:1 200.1.1.2:1 icmp 200.1.1.200:2 172.16.1.5:2 200.1.1.2:2 200.1.1.2:2 icmp 200.1.1.200:3 172.16.1.5:3 200.1.1.2:3 200.1.1.2:3 icmp 200.1.1.200:4 172.16.1.5:4 200.1.1.2:4 200.1.1.2:4 icmp 200.1.1.201:1 172.16.1.6:1 200.1.1.2:1 200.1.1.2:1 icmp 200.1.1.201:2 172.16.1.6:2 200.1.1.2:2 200.1.1.2:2 icmp 200.1.1.201:3 172.16.1.6:3 200.1.1.2:3 200.1.1.2:3 icmp 200.1.1.201:4 172.16.1.6:4 200.1.1.2:4 200.1.1.2:4  ","href":"/post/20190701101121/","title":"实验九 配置动态nat"},{"content":"","href":"/tags/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/","title":"网络地址映射"},{"content":" 实验平台 Cisco模拟器，Version：5.3.0.0088\n实验目的 配置网络地址变换，提供到公司共享服务器的可靠外部访问，即把内网的ip映射到公网ip。\n需求分析 公司需要将 172.16.1.5 和 172.16.1.6 两台主机作为共享服务器，需要外网能够访问，考虑到包括安全在内的诸多因素，公司希望对外部隐藏内部网络。\n实验原理 在路由器上把 172.16.1.5、172.16.1.6 两台主机静态映射到外部，把内网隐藏起来。\n实验拓扑 选择设备  交换机：1台2960 移动终端：2台Generic（从左边数第一个） 路由器：2台Generic（从左边数第一个）  实验demo 实验八-配置静态nat.pkt\n实验步骤 设置左边的路由器 no Router\u0026gt;en Router#conf t Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.2 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shutdown Router(config-if)#end Router#sh run  设置右边的路由器 no Router\u0026gt;en Router#conf t Router(config)#ip route 0.0.0.0 0.0.0.0 se2/0 Router(config)#ip nat inside source static 172.16.1.5 200.1.1.80 Router(config)#ip nat inside source static 172.16.1.6 200.1.1.81 Router(config)#inter se2/0 Router(config-if)#ip address 200.1.1.1 255.255.255.0 Router(config-if)#clock rate 64000 Router(config-if)#no shut Router(config-if)#ip nat outside Router(config-if)#inter fa0/0 Router(config-if)#ip address 172.16.1.1 255.255.255.0 Router(config-if)#ip nat inside Router(config-if)#no shut Router(config)#end Router#sh run  设置上面主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.1.5 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.1.1  设置下面主机 1、打开\u0026rdquo;IP Configure\u0026rdquo;\n2、输入：\nIP Address: 172.16.1.6 Subnet Mask: 255.255.255.0 Default Gateway: 172.16.1.1  测试搭建好的拓扑 1、打开左边的路由器的命令行：\nRouter\u0026gt;ping 200.1.1.80 ... Router\u0026gt;ping 200.1.1.81 ...  2、打开右边的路由器的命令行：\nRouter\u0026gt;en Router#sh ip nat tran 得到下面类似的输出： Pro Inside global Inside local Outside local Outside global --- 200.1.1.80 172.16.1.5 --- --- --- 200.1.1.81 172.16.1.6 --- ---  ","href":"/post/20190701090625/","title":"实验八 配置静态nat"},{"content":" 发现问题 以Ubuntu系统为例，我们通过genpac生成autoproxy.pac文件，然后点击系统设置-\u0026gt;网络-\u0026gt;代理设置-\u0026gt;自动，在输入框中输入file://绝对路径/autoproxy.pac。设置好以后，Chrome应当可以自动切换网络，但是Chrome无法访问google的搜索引擎，而火狐浏览器可以正常访问。\n分析问题 出现上面问题的唯一可能就是Chrome设置有误，因此点击设置-\u0026gt;高级设置-\u0026gt;打开代理设置，打开的就是Ubuntu系统的网络设置。因此，我们可以判断自动代理模式设置失效，这里我们就要仔细分析为什么会失效？\n解决方案 出现上面问题的主要原因是：Chrome移除对file://和data:协议的支持，目前只能使用http://协议。因此，我们打算使用nginx实现对本地文件的http映射。\n安装nginx sudo apt-get install nginx 修改nginx.cnf配置文件 vim /etc/nginx/nginx.conf 在nginx.conf的http{...}代码块中输入:\nserver{ listen 80; #注意这里不用\u0026#34;:\u0026#34;隔开，listen后面没有冒号  server_name 127.0.0.1; #注意这里不用\u0026#34;:\u0026#34;隔开，server_name后面没有冒号  location /autoproxy.pac { alias 绝对路径/autoproxy.pac; } } 重启nginx\nsudo nginx -s reload 把http://127.0.0.1/autoproxy.pac填写到系统设置-\u0026gt;网络-\u0026gt;代理设置-\u0026gt;自动代理中\n","href":"/post/20190630230818/","title":"Chrome设置PAC模式无效的解决方案"},{"content":"","href":"/tags/genpac/","title":"genpac"},{"content":"","href":"/tags/hugo/","title":"Hugo"},{"content":" Hugo介绍 一种基于 Go 语言的博客框架。\nHugo安装(Mac) brew install hugo 创建博客  下面以我的github用户名manuan为例\n hugo new site mannuan.github.io 安装主题 themes.gohuo.io上面有很多主题可供选择，比如选择m10c\n下载m10c $ cd myblog $ git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 修改配置文件 config.toml 添加一行：\ntheme = \u0026#34;m10c\u0026#34; 本地预览 hugo server -D 创建第一篇博客 hugo new post/第一篇博客.md 创建的博客在 contents/post/下面\n使用vscode编辑markdown文件 快捷键 Ctrl+Shift+P，输入 Markwon: Open Preview to the Side，打开预览模式\n发布博客到github  在github创建一个名为 mannuan.github.io 的仓库。\n 把当前的博客打包到 public 目录下面\n  hugo --baseUrl=\u0026#34;https://mannuan.github.io/\u0026#34; -D  把 public 里面的内容同步到github  cd public git init git add . git commit -m \u0026#39;hugo博客第一次提交\u0026#39; git remote add origin https://github.com/mannuan/mannuan.github.io.git git push -u origin master  打开浏览器输入 https://mannuan.github.io，查看博客。  博客后期维护  创建文章：  hugo new post/文章.md  进行打包：  hugo --baseUrl=\u0026#34;https://mannuan.github.io/\u0026#34; -D  发布博客：  cd public git add . git commit -m \u0026#39;第二次提交\u0026#39; git push -u origin master","href":"/post/20190630211927/","title":"Hugo博客搭建教程"},{"content":"","href":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"},{"content":"","href":"/tags/jsonp/","title":"jsonp"},{"content":"","href":"/tags/%E5%8E%9F%E7%94%9Fjs/","title":"原生js"},{"content":" 介绍 JSONP是JSON with Padding(填充式JSON或参数式JSON)的简写，是一种非常常用的跨域请求方式。主要原理是利用了script 标签可以跨域请求的特性，由其 src属性发送请求到服务器，服务器返回JavaScript 代码，浏览器接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。\nJSONP由两部分组成：回调函数和数据，回调函数是当响应到来时应该在页面中调用的函数，回调函数的名字一般在请求中指定。当服务器响应时，服务器端就会把该函数和数据拼成字符串返回。\nJSONP 的请求过程  请求阶段：浏览器创建一个 script 标签，并给其src 赋值(类似 http://example.com/api/?callback=jsonpCallback）。 发送请求：当给script的src赋值时，浏览器就会发起一个请求。 数据响应：服务端将要返回的数据作为参数和函数名称拼接在一起(格式类似”jsonpCallback({name: 'abc'})”)返回。当浏览器接收到了响应数据，由于发起请求的是 script，所以相当于直接调用 jsonpCallback 方法，并且传入了一个参数。  服务端交互示意图 server1代码(Nodejs实现) var Koa = require(\u0026#39;koa\u0026#39;); var Router = require(\u0026#39;koa-router\u0026#39;); var querystring = require(\u0026#39;querystring\u0026#39;); var app = new Koa(); var router = new Router(); //处理get请求 router.get(\u0026#39;/get\u0026#39;, async function(ctx){ var params = querystring.parse(ctx.request.url.split(\u0026#39;?\u0026#39;)[1]); var data = { message: \u0026#34;我是\u0026#34; + ctx.request.header.host + \u0026#34;，我收到了你的get请求！！！\u0026#34; } ctx.status=200; ctx.body=params[\u0026#39;callback\u0026#39;]+\u0026#39;(\u0026#39;+JSON.stringify(data)+\u0026#39;);\u0026#39;; }); app .use(router.routes()) .use(router.allowedMethods()) app.listen(3000);  server2代码 var Koa = require(\u0026#39;koa\u0026#39;); var Router = require(\u0026#39;koa-router\u0026#39;); var render = require(\u0026#39;koa-art-template\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var app = new Koa(); var router = new Router(); //配置模板引擎 render(app, { root: path.join(__dirname, \u0026#39;views\u0026#39;), extname: \u0026#39;.html\u0026#39;, debug: process.env.NODE_ENV !== \u0026#39;production\u0026#39;, }); router.get(\u0026#39;/index.html\u0026#39;, async function (ctx) { await ctx.render(\u0026#39;server2\u0026#39;); }); app.use(router.routes()).use(router.allowedMethods()); app.listen(4000);  前端代码 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生js实现\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送get请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt; function jsonpcallback(response){ alert(response.message); } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://127.0.0.1:3000/get?callback=jsonpcallback\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.getElementsByTagName(\u0026#39;button\u0026#39;)[0].addEventListener(\u0026#39;click\u0026#39;, function () { ajax(\u0026#39;http://127.0.0.1:3000/get\u0026#39;, function(response){ alert(response.message); }); }); function ajax(url, callback){ var jsonp=document.createElement(\u0026#39;script\u0026#39;); jsonp.type = \u0026#39;text/javascript\u0026#39;; jsonp.src=url+\u0026#39;?callback=jsonpcallback\u0026#39;; jsonpcallback = function(response){ callback(response); }; document.getElementsByTagName(\u0026#39;head\u0026#39;)[0].appendChild(jsonp); } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 分析 其实上述过程可以总结为：\nfunction jsonpcallback(response){ alert(response.message); } jsonpcallback({\u0026#34;message\u0026#34;:\u0026#34;我是127.0.0.1:3000，我收到了你的get请求！！！\u0026#34;}); ","href":"/post/20190629214157/","title":"原生js实现JSONP"},{"content":"","href":"/tags/promise/","title":"promise"},{"content":" 前言 Promise是ES6提出的解决异步编程导致陷入回调的地狱问题。\n例子1 console.log(1); var a=new Promise(function(resolve, reject){ console.log(2); resolve(); }); console.log(2); var b = new Promise(function(resolve, reject){ console.log(4); resolve(); }); console.log(5); a.then(function(){ console.log(6); }); b.then(function(){ console.log(7); });   顺序输出：1~7\n 例子2 console.log(1); var a = new Promise(function(resolve, reject){ resolve(); console.log(2); }); a.then(function(){ console.log(6); }); console.log(3); var b = new Promise(function(resolve, reject){ resolve(); console.log(4); }); b.then(function(){ console.log(7); }); console.log(5);   顺序输出：1~7\n 结论 Promise本身是同步的，但.then和.catch方法是异步的\n","href":"/post/20190628220548/","title":"验证Promise是同步的"},{"content":"","href":"/tags/ajax/","title":"ajax"},{"content":" 原生js ajax(\u0026#39;get\u0026#39;, \u0026#39;http://127.0.0.1:3000/get\u0026#39;, function(response){ alert(JSON.parse(response)[\u0026#39;message\u0026#39;]); }); ajax(\u0026#39;post\u0026#39;, \u0026#39;http://127.0.0.1:3000/post\u0026#39;, function (response) { alert(JSON.parse(response)[\u0026#39;message\u0026#39;]); }, JSON.stringify({name: \u0026#34;post测试\u0026#34;})); function ajax(method, url, callback, data, async){ var data=data || null; var async=async || true; var xhr = new window.XMLHttpRequest || ActiveXObject(\u0026#39;Microsoft.XMLHTTP\u0026#39;); xhr.open(method, url, async); xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(data); console.log(\u0026#34;发送的数据是：\u0026#34;+data); xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status \u0026gt;=200\u0026amp;\u0026amp;xhr.status\u0026lt;300||xhr.status==304){ console.log(\u0026#34;完成请求，响应就绪\u0026#34;); callback(this.responseText); } } } }  原生js-Promise ajax(\u0026#39;get\u0026#39;, \u0026#39;http://127.0.0.1:3000/get\u0026#39;).then(function (data) { alert(JSON.parse(data).message); }).catch(function (error) { alert(error); }); ajax(\u0026#39;post\u0026#39;, \u0026#39;http://127.0.0.1:3000/post\u0026#39;, JSON.stringify({ name: \u0026#34;post测试\u0026#34; })).then(function (data) { alert(JSON.parse(data).message); }).catch(function (error) { alert(error); }); function ajax(method, url, data, async) { var data = data || null; var async = async || true; var xhr = new window.XMLHttpRequest || ActiveXObject(\u0026#39;Microsoft.XMLHTTP\u0026#39;); xhr.open(method, url, async); xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(data); console.log(\u0026#34;发送的数据是：\u0026#34; + data); return new Promise(function (resolve, reject) { xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300 || xhr.status == 304) { console.log(\u0026#34;完成请求，响应就绪\u0026#34;); resolve(this.responseText); } else { reject(new Error(this.statusText)); } } } }); }  jQuery $.get(\u0026#39;http://127.0.0.1:3000/get\u0026#39;, function(data, status){ alert(data.message); }); $.post(\u0026#39;http://127.0.0.1:3000/post\u0026#39;, { name: \u0026#39;post测试\u0026#39;, }, function(data, status){ alert(data.message); });  Vue.js new Vue().$http.get(\u0026#39;http://127.0.0.1:3000/get\u0026#39;).then(function (res) { alert(res.body.message); }, function () { console.log(\u0026#39;请求失败处理\u0026#39;); }); new Vue().$http.post(\u0026#39;http://127.0.0.1:3000/post\u0026#39;, { name: \u0026#34;post测试\u0026#34;}, { emulateJSON: true }).then(function (res) { alert(res.body.message); }, function (res) { console.log(res.status); });  关于这几个版本的Ajax的实验测试和我的总结，可以查看我的关于Ajax的jQuery、Vue.js、原生js的各个版本的实现对比\n","href":"/post/20190628213546/","title":"原生js、jQuery和Vue.js的Ajax的详细对比"},{"content":" 目录\n前言\n1、原生js实现\n2、原生js实现——Promise版本\n3、jQuery实现\n4、Vue.js实现\n总结\n前言  下面对于各个版本的Ajax代码，想要实际测试它们，可以把它命名为server2.html，然后放在当前目录views目录下面。具体的教程可以看测试Ajax的Nodejs服务端代码\n 1、原生js实现 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生js版本\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送get请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送post请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.getElementsByTagName(\u0026#39;button\u0026#39;)[0].addEventListener(\u0026#39;click\u0026#39;, function () { ajax(\u0026#39;get\u0026#39;, \u0026#39;http://127.0.0.1:3000/get\u0026#39;, function (response) { alert(JSON.parse(response)[\u0026#39;message\u0026#39;]); }); }); document.getElementsByTagName(\u0026#39;button\u0026#39;)[1].addEventListener(\u0026#39;click\u0026#39;, function () { ajax(\u0026#39;post\u0026#39;, \u0026#39;http://127.0.0.1:3000/post\u0026#39;, function (response) { alert(JSON.parse(response)[\u0026#39;message\u0026#39;]); }, JSON.stringify({ name: \u0026#34;post测试\u0026#34; })); }); function ajax(method, url, callback, data, async) { data = data || null; async = async || true; var xhr = new window.XMLHttpRequest || ActiveXObject(\u0026#39;Microsoft.XMLHTTP\u0026#39;); xhr.open(method, url, async); xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(data); console.log(\u0026#34;发送的数据是：\u0026#34; + data); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300 || xhr.status == 304) { console.log(\u0026#34;完成请求，响应就绪\u0026#34;); callback(this.responseText); } } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 2、原生js实现——Promise版本 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生js版本——Promise版本\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送get请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送post请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.getElementsByTagName(\u0026#39;button\u0026#39;)[0].addEventListener(\u0026#39;click\u0026#39;, function () { ajax(\u0026#39;get\u0026#39;, \u0026#39;http://127.0.0.1:3000/get\u0026#39;).then(function (data) { alert(JSON.parse(data).message); }).catch(function (error) { alert(error); }); }); document.getElementsByTagName(\u0026#39;button\u0026#39;)[1].addEventListener(\u0026#39;click\u0026#39;, function () { ajax(\u0026#39;post\u0026#39;, \u0026#39;http://127.0.0.1:3000/post\u0026#39;, JSON.stringify({ name: \u0026#34;post测试\u0026#34; })).then(function (data) { alert(JSON.parse(data).message); }).catch(function (error) { alert(error); }); }); function ajax(method, url, data, async) { return new Promise(function (resolve, reject) { data = data || null; async = async || true; var xhr = new window.XMLHttpRequest || ActiveXObject(\u0026#39;Microsoft.XMLHTTP\u0026#39;); xhr.open(method, url, async); xhr.setRequestHeader(\u0026#39;content-type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(data); console.log(\u0026#34;发送的数据是：\u0026#34; + data); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300 || xhr.status == 304) { console.log(\u0026#34;完成请求，响应就绪\u0026#34;); resolve(this.responseText); } else { reject(new Error(this.statusText)); } } } }); } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 3、jQuery实现 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;jQuery版本\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#39;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送get请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送post请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.getElementsByTagName(\u0026#39;button\u0026#39;)[0].addEventListener(\u0026#39;click\u0026#39;, function(){ $.get(\u0026#39;http://127.0.0.1:3000/get\u0026#39;, function(data, status){ alert(data.message); }); }); document.getElementsByTagName(\u0026#39;button\u0026#39;)[1].addEventListener(\u0026#39;click\u0026#39;, function () { $.post(\u0026#39;http://127.0.0.1:3000/post\u0026#39;, { name: \u0026#39;post测试\u0026#39;, }, function(data, status){ alert(data.message); }); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 4、Vue.js实现 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue.js版本\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/vue/2.4.2/vue.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送get请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button\u0026gt;点击我发送post请求\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.getElementsByTagName(\u0026#39;button\u0026#39;)[0].addEventListener(\u0026#39;click\u0026#39;, function(){ new Vue().$http.get(\u0026#39;http://127.0.0.1:3000/get\u0026#39;).then(function (res) { alert(res.body.message); }, function () { console.log(\u0026#39;请求失败处理\u0026#39;); }); }); document.getElementsByTagName(\u0026#39;button\u0026#39;)[1].addEventListener(\u0026#39;click\u0026#39;, function () { new Vue().$http.post(\u0026#39;http://127.0.0.1:3000/post\u0026#39;, { name: \u0026#34;post测试\u0026#34;}, { emulateJSON: true }).then(function (res) { alert(res.body.message); }, function (res) { console.log(res.status); }); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 总结  使用原生js写ajax步骤比较麻烦，考虑的东西比较多，但是最接近底层，对于理解ajax很有帮助； Promise是同步的，但是.then.catch是异步的，具体可以查看验证Promise是同步的； jQuery实现的写法比较简洁； Vue.js的写法和Promise写法很像，其实内部就是通过Promise来实现的； 其实根据Promise可以将上面4种方法分为两类：  使用Promise：方法2、4 不使用Promise：方法1、3  关于这四个方法Ajax，我专门截取了一些主要的代码片断，进行了更加精确的对比，请查看原生js、jQuery和Vue.js的Ajax的详细对比  ","href":"/post/20190628203826/","title":"关于Ajax的jQuery、Vue.js、原生js的各个版本的实现对比"},{"content":"","href":"/tags/cors/","title":"cors"},{"content":"","href":"/tags/koa/","title":"koa"},{"content":"","href":"/tags/nodejs/","title":"nodejs"},{"content":" 前言  由于使用Ajax必须要有一个服务端来接收消息，为了方便我使用Nodejs来搭建服务端。同时，为了兼顾实践跨域的方法，我在这里搭建了两个服务端。其中，一个服务端用来响应Ajax请求，另外一个服务端用作加载页面。这样就产生了跨域的问题，我采用的是cors的解决方案，具体的实现，请看sever1的代码。\n 前期准备工作  安装nodejs，可以参看我的这篇教程 选择koa2作为服务端 安装模块：koa，koa-router，koa2-cors，koa-bodyparser，koa-art-template，path  服务端交互示意图 文件路径示意图 server1.js var Koa = require(\u0026#39;koa\u0026#39;); var Router = require(\u0026#39;koa-router\u0026#39;); var cors = require(\u0026#39;koa2-cors\u0026#39;); var bodyParser = require(\u0026#39;koa-bodyparser\u0026#39;); var app = new Koa(); var router = new Router(); //下面的代码必须写在设置路由的前面 app.use(cors({ origin: function (ctx) { return \u0026#39;http://127.0.0.1:4000\u0026#39;; }, exposeHeaders: [\u0026#39;WWW-Authenticate\u0026#39;, \u0026#39;Server-Authorization\u0026#39;], maxAge: 5, credentials: true, allowMethods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;DELETE\u0026#39;], allowHeaders: [\u0026#39;Content-Type\u0026#39;, \u0026#39;Authorization\u0026#39;, \u0026#39;Accept\u0026#39;], })); //配置post提交数据的中间件 app.use(bodyParser()); //处理get请求 router.get(\u0026#39;/get\u0026#39;, async function(ctx){ ctx.status=200; ctx.body={message: \u0026#34;我是\u0026#34;+ctx.request.header.host+\u0026#34;，我收到了你的get请求！！！\u0026#34;}; }); //处理post请求 router.post(\u0026#39;/post\u0026#39;, async function(ctx){ ctx.status=200; ctx.body = { message: \u0026#34;我是\u0026#34; + ctx.request.header.host + \u0026#34;，你告诉我这是一个\u0026#34; + ctx.request.body[\u0026#39;name\u0026#39;]+\u0026#34;!!!\u0026#34;} }); app .use(router.routes()) .use(router.allowedMethods()) app.listen(3000);  server2.js var Koa = require(\u0026#39;koa\u0026#39;); var Router = require(\u0026#39;koa-router\u0026#39;); var render = require(\u0026#39;koa-art-template\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var app = new Koa(); var router = new Router(); router.get(\u0026#39;/index.html\u0026#39;, async function (ctx) { await ctx.render(\u0026#39;server2.html\u0026#39;); }); //配置模板引擎 render(app, { root: path.join(__dirname, \u0026#39;views\u0026#39;), extname: \u0026#39;.html\u0026#39;, debug: process.env.NODE_ENV !== \u0026#39;production\u0026#39;, }); app.use(router.routes()).use(router.allowedMethods()); app.listen(4000);   我在把html文件存放的路径设置为./views\n ","href":"/post/20190628174910/","title":"测试Ajax的Nodejs服务端代码"},{"content":"","href":"/tags/%E8%B7%A8%E5%9F%9F/","title":"跨域"},{"content":"","href":"/tags/node/","title":"node"},{"content":" 安装nodejs mac端 brew install node 如果安装速度慢，可以到nodejs官网下载pkg安装包；\nlinux端 apt安装方式(不推荐，nodejs的版本太旧) sudo apt-get install nodejs 官网下载安装 nodejs官网下载node-vxx.xx.x-linux-x64.tar.xz安装包\n安装步骤  解压  unar node-vxx.xx.x-linux-x64.tar.xz   移动node-vxx.xx.x-linux-x64到/usr/local/下面   为了防止nodejs被篡改，保险起见放在根目录下面\n sudo mv node-vxx.xx.x-linux-x64 /usr/local/  配置nodejs的环境变量  修改.zshrc或者.bashrc这两个配置文件，具体取决于你自己使用的是什么终端主题\n 由于nodejs是普通用户级别的命令，不建议修改/etc/profile\n export PATH=/usr/local/node-vxx.xx.x-linux-x64/bin:$PATH 检查安装 node -v npm -v 修改node_modules目录权限 教程\n添加node_modules路径 教程\n","href":"/post/20190628152512/","title":"nodejs安装教程（完美避坑，适用于mac和linux）"},{"content":"","href":"/tags/npm/","title":"npm"},{"content":" 前言  我已经正确的安装了node，并且我使用npm install -g 安装包没有出错，但是就是在代码中导入包的时候使用require('安装包')报错，我的全局模块路径是在/usr/local/lib/node_modules下面\n 原因分析 可能是node命令早不到npm的安装包的安装目录，于是我打印了node默认的模块目录：\nnode module.paths [ \u0026#39;/Users/用户名/repl/node_modules\u0026#39;, \u0026#39;/Users/用户名/node_modules\u0026#39;, \u0026#39;/Users/node_modules\u0026#39;, \u0026#39;/node_modules\u0026#39;, \u0026#39;/Users/用户名/.node_modules\u0026#39;, \u0026#39;/Users/用户名/.node_libraries\u0026#39;, \u0026#39;/usr/local/lib/node\u0026#39; ] 我发现，/usr/local/lib/node_modules目录并没有包含在里面，于是我使用下面的命令：\nmodule.paths.push(\u0026#39;/usr/local/lib/node_modules\u0026#39;) 虽然这个命令生效了，但它是暂时性的。但我并不知道如何永久的把我的模块目录添加进去。 为了解决这个问题，我使用软链接的来解决这个问题。\n解决方案 ln -sfn /usr/local/lib/node_modules /Users/$USER/node_modules  由于根据npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules，node_module目录的拥有者是当前用户，所以没有必要使用sudo命令.\n ","href":"/post/20190628114044/","title":"node require can't find module(适用于mac或linux，不支持window)"},{"content":" 前言  我是在重装node之后遇到这个问题的\n 原因分析 当你已经安装node之后，它给你以下提示说明你已经安装好了：\nThis package has installed: Node.js v10.16.0 to /usr/local/bin/node npm v6.9.0 to /usr/local/bin/npm Make sure that /usr/local/bin is in your $PATH.  但是，当你使用下面命令，报错了\nnpm list -g 推测 我认为可能是没有卸载干净\n解决方案 我使用ls -a命令打印出了home目录下面的隐藏文件，发现了几个可以目录, \u0026quot;.npm\u0026quot;, \u0026quot;.npminstall_tarball\u0026quot;, \u0026quot;.node-gyp\u0026quot;。我把他们删除以后就不报错了\n结论 这些隐藏目录下面的配置文件的优先级比较高，导致出错\n","href":"/post/20190628110638/","title":"npm list -g出错"},{"content":"","href":"/tags/npm%E5%87%BA%E9%94%99/","title":"npm出错"},{"content":"","href":"/tags/checkpermissions/","title":"checkPermissions"},{"content":" 原因分析  详看错误提示：npm ERR! Error: EACCES: permission denied, access /usr/local/lib/node_modules 推测当前用户没有对node_modules目录的写入权限\n 验证推测 \u0026gt;\u0026gt; ls -lth /usr/local/lib/node_modules total 0 drwxr-xr-x 24 root wheel 768B May 29 05:21 npm 观看上面的结果推测成立\n解决方案 方案一（不推荐） 修改node_modules目录的权限，增加”写入“权限；\nsudo chmod 775 /usr/local/lib/node_modules  并不推荐这种方案，因为这个目录完全不会有root用户进行访问\n 方案二 （推荐） 改变node_nodules目录的拥有者\nsudo chown -R $USER /usr/local/lib/node_modules","href":"/post/20190628104030/","title":"npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules"},{"content":"","href":"/tags/write-access/","title":"write access"},{"content":"Mac下的安装和删除都比windows更加简单清晰，这点在dmg方式下非常明显，但很多时候我们会使用pkg来进行安装，这样的安装想删除就有点麻烦了。\n比如，我安装了Golang这个pkg用于go语言的编译，安装后确实可以使用，但安装的是一个工具链，并不是一个应用软件。所以在Application目录下是没有内容的，你可以查到安装在/usr/local/go这个目录下，但是否所有的内容都安装在这个目录下呢？我删除这个pkg的目的是为了用源码直接编译出工具链来应用，如果还有其他一些配置文件遗漏，可能会导致后续配置的问题。\n经过一些搜索和学习，觉得有两个方法：\n 使用pkgutil命令  首先运行pkgutil --pkgs | grep -i go，这样会列出含有go字样的pkg\n这里我们可以看到，运行命令后列出了所有名字中含有\u0026rdquo;go\u0026rdquo;的pkg，其中com.googlecode.go就是我们golang的pkg，也就是我们要删除的pkg。\n然后运行pkgutil \u0026ndash;files com.googlecode.go这个命令，这个命令会列出pkg的所有安装的文件，根据这个列表就可以保证删除干净了，再也没有后患。\n比如对于golang的pkg，虽然有长长的一个列表，我们还是可以总结出来，除/usr/local/go之外，还有etc/paths.d/go这个文件需要删除。\n 直接使用工具，这样可以傻瓜化的一键搞定，下载地址：http://www.corecode.at/uninstallpkg/   除了这两个方法之外，还有其他的方法，不过我觉得这两个方法比较清晰简单。第一个方法主要是手动删除，适用于熟练的资深工程师；第二个方法一键完成，适用于一切玩家。\n","href":"/post/20190628101517/","title":"mac下pkg安装包卸载"},{"content":"","href":"/tags/pkg/","title":"pkg"},{"content":"","href":"/tags/trackpad/","title":"Trackpad"},{"content":" 右键菜单 使用”双指点击“代替”右键“\n上下左右滚动页面 使用”双指拖动“代替”鼠标“\n切换窗口 使用”四指拖动“代替”传统的组合快捷键“\n快捷返回桌面 使用”五指释放“代替”传统的组合快捷键“\n打开Launchpad 使用”五指收回“\n左键点击 使用”单指轻触“代替左键点击\n","href":"/post/20190627165448/","title":"优化mac触摸板（Trackpad）使用体验的推荐设置"},{"content":"   快捷键 功能     command+D 新建Tab   command+数字 切换Tab    ","href":"/post/20190627162924/","title":"iTerm2的常用快捷键"},{"content":"","href":"/tags/iterm2/","title":"iterm2"},{"content":"","href":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"快捷键"},{"content":" 前言  使用快捷键打开item窗口的一个前提是iTerm必须已经打开了\n 选择iTerm2，点击prefences 点击Profiles 新建窗口实例 常用的窗口属性 设置窗口名称 设置窗口字体 设置窗口透明度 设置窗口的快捷键 设置窗口的位置 有多种设置窗口位置的方法，比如”置顶“，”正常模式“等\n","href":"/post/20190627154651/","title":"mac使用快捷键打开iTerm2"},{"content":"","href":"/tags/content-type/","title":"content-type"},{"content":"1、Content-Type 的值类型：\n1.1 application/json：消息主体是序列化后的 JSON 字符串\n1.2 application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式\n1.3 multipart/form-data： 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件之时使用的\n1.4 text/plain：数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。\n2、application/json 和 application/x-www-form-urlencoded的区别\n2.1 application/json：作用： 告诉服务器请求的主题内容是json格式的字符串，服务器端会对json字符串进行解析，好处： 前端人员不需要关心数据结构的复杂度，只要是标准的json格式就能提交成功。\n2.2 application/x-www-form-urlencoded：是Jquery的Ajax请求默认方式作用：在请求发送过程中会对数据进行序列化处理，以键值对形式？key1=value1\u0026amp;key2=value2的方式发送到服务器，好处：所有浏览器都支持\n3、 application/x-www-form-urlencoded：信息数据被编码为名称/值对，这是标准且默认的编码格式\n3.1 当action为get时候，客户端把form数据转换成一个字串append到url后面，用\u0026rsquo;?\u0026lsquo;分割。\n3.2 当action为post时候，浏览器把form数据封装到http body中，然后发送到server。（可以取消post请求的预检请求）\nVue中 content-type 设置\n","href":"/post/20190626224453/","title":"关于Content-Type几种值的区别及用法"},{"content":"","href":"/tags/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/","title":"web前端性能"},{"content":"相信互联网已经越来越成为人们生活中不可或缺的一部分。Ajax，flex等等富客户端的应用使得人们越加“幸福”地体验着许多原先只能在C/S实 现的功 能。比如Google机会已经把最基本的office应用都搬到了互联网上。当然便利的同时毫无疑问的也使页面的速度越来越慢。自己是做前端开发的，在性能方面，根据Yahoo的调查，后台只占5%，而前端高达95%之多，其中有88%的东西是可以优化的。\n[外链图片转存失败(img- edenZ0UF-1562139364811)(http://www.phpv.net/uploadfile/month_200901/local_xahdWW7qeV.jpg)]\n以上是一张web2.0页面的生命周期图。工程师很形象地讲它分成了“怀孕，出生，毕业，结婚”四个阶段。如果在我们点击网页链接的时候能够意识到 这个过程而不是简单的请求-响应的话，我们便可以挖掘出很多细节上可以提升性能的东西。今天听了淘宝小马哥的一个对yahoo开发团队对web性能研究的 一个讲座，感觉收获很大，想在blog上做个分享。\n相信很多人都听过优化网站性能的14条规则。更多的信息可见developer.yahoo.com\n   1. 尽可能的减少 HTTP 的请求数 content     2. 使用 CDN（Content Delivery Network） server   3. 添加 Expires 头(或者 Cache-control ) server   4. Gzip 组件 server   5. 将 CSS 样式放在页面的上方 css   6. 将脚本移动到底部（包括内联的） javascript   7. 避免使用 CSS 中的 Expressions css   8. 将 JavaScript 和 CSS 独立成外部文件 javascript css   9. 减少 DNS 查询 content   10. 压缩 JavaScript 和 CSS (包括内联的) javascript css   11. 避免重定向 server   12. 移除重复的脚本 javascript   13. 配置实体标签（ETags） css    14. 使 AJAX 缓存\n[外链图片转存失败(img-7Mt5gvww-1562139364812)(http://www.phpv.net/uploadfile/month_200901/local_1684mswAGI.jpg)]\n在firefox下有一个插件yslow，集成在firebug中，你可以用它很方便地来看看自己的网站在这几个方面的表现。\n这是对用yslow对我的网站西风坊测评的结果，很遗憾，只有51分。呵呵。中国各大网站的分值都不高，刚测了一下，新浪和网易都是31分。然后yahoo（美国）的分值确实97分！可见yahoo在这方面作出的努力。从他们总结的这14条规则，已经现在又新增加的20个点来看，有很多细节我们真得是怎么都不会去想，有些做法甚至是有些“变态”了。\n第一条、尽可能的减少 HTTP 的请求数 （Make Fewer HTTP Requests ）\nhttp请求是要开销的，想办法减少请求数自然可以提高网页速度。常用的方法，合并css，js（将一个页面中的css和js文件分别合并）以及 Image maps和css sprites等。当然或许将css，js文件拆分多个是因为css结构，共用等方面的考虑。阿里巴巴中文站当时的做法是开发时依然分开开发，然后在后台 对js，css进行合并，这样对于浏览器来说依然是一个请求，但是开发时仍然能还原成多个，方便管理和重复引用。yahoo甚至建议将首页的css和js 直接写在页面文件里面，而不是外部引用。因为首页的访问量太大了，这么做也可以减少两个请求数。而事实上国内的很多门户都是这么做的。\n而css sprites是指只用将页面上的背景图合并成一张，然后通过css的background- position属性定义不过的值来取他的背景。淘宝和阿里巴巴中文站目前都是这样做的。有兴趣的可以看下淘宝和阿里巴巴的背景图。\nhttp://www.csssprites.com/ 这是个工具网站，它可以自动将你上传的图片合并并给出对应的background- position坐标。并将结果以png和gif的格式输出。\n第二条、使用CDN（内容分发网络）: Use a Content Delivery Network\n说实话，对于CDN这一块自己并不是很了解，简单地讲，通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的 cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，杭州的用户访问近杭州服务器上的内容，北京的访问 近北京服务器上的内容。这样可以有效减少数据在网络上传输的时间，提高速度。更详细地内容大家可以参考百度百科上对于CDN的解释。Yahoo!把静态内容分布到CDN减少了用户影响时间20%或更多。\nCDN技术示意图：\n[外链图片转存失败(img- zofREOg2-1562139364813)(http://www.phpv.net/uploadfile/month_200901/local_ni04F4t5Gy.jpg)]\nCDN组网示意图：\n[外链图片转存失败(img- FtO3lXJC-1562139364813)(http://www.phpv.net/uploadfile/month_200901/local_sP9adNJw02.jpg)]\n第三条、 添加Expire/Cache-Control 头 ：Add an Expires Header\n现在越来越多的图片，脚本，css，flash被嵌入到页面中，当我们访问他们的时候势必会做许多次的http请求。其实我们可以通过设置Expires header 来缓存这些文件。Expire其实就是通过header报文来指定特定类型的文件在览器中的缓存时间。大多数的图片，flash在发布后都是不需要经常修 改的，做了缓存以后这样浏览器以后就不需要再从服务器下载这些文件而是而直接从缓存中读取，这样再次访问页面的速度会大大加快。一个典型的HTTP 1.1协议返回的头信息：\nHTTP/1.1 200 OK\nDate: Fri, 30 Oct 1998 13:19:41 GMT\nServer: Apache/1.3.3 (Unix)\nCache-Control: max-age=3600, must-revalidate\nExpires: Fri, 30 Oct 1998 14:19:41 GMT\nLast-Modified: Mon, 29 Jun 1998 02:28:12 GMT\nETag: “3e86-410-3596fbbc”\nContent-Length: 1040\nContent-Type: text/html\n其中通过服务器端脚本设置Cache-Control和Expires可以完成。\n如，在php中设置30天后过期：\n\u0026lt;!--pHeader(\u0026quot;Cache-Control: must-revalidate\u0026quot;); **$** offset = 60 * 60 * 24 * 30; **$** ExpStr = \u0026quot;Expires: \u0026quot; . gmdate(\u0026quot;D, d M Y H:i:s\u0026quot;, time() + **$** offset) . \u0026quot; GMT\u0026quot;; Header( **$** ExpStr);--\u0026gt;   1  也可以通过配置服务器本身完成，这些偶就不是很清楚了，呵呵。想了解跟多的朋友可以参考http://www.web-caching.com/\n据我了解，目前阿里巴巴中文站的Expires过期时间是30天。不过期间也有过问题，特别是对于脚本过期时间的设置还是应该仔细考虑下，不然相应的脚本功能更新后客户端可能要过很长一段时间才能“感知”到这样的变化。所以，哪些应该缓存，哪些不该缓存还是应该仔细斟酌一番。\n第四条、启用Gzip压缩： Gzip Components\nGzip的思想就是把文件先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。目前的浏览器都能“良好”地支持 gzip。不仅浏览器可以识别，而且各大“爬虫”也同样可以识别，各位seoer可以放下心了。而且gzip的压缩比例非常大，一般压缩率为85%，就是 说服务器端100K的页面可以压缩到25K左右再发送到客户端。具体的Gzip压缩原理大家可以参考csdn上的《gzip压缩算法》 这篇文章。雅虎特别强调， 所有的文本内容都应该被gzip压缩: html (php), js, css, xml, txt… 这一点我们网站做得不错，是一个A。以前我们的首页也并不是A，因为首页上还有很多广告代码投放的js，这些广告代码拥有者的网站的js没有经过gzip压缩，也会拖累我们网站。\n以上三点大多属于服务器端的内容，本人也是粗浅地了解而已。说得不对的地方有待各位指正。\n第五条、将css放在页面最上面 （ Put Stylesheets at the Top）\n将css放在页面最上面，这是为什么？因为 ie，firefox等浏览器在css全部传输完全之前不会去渲染任何的东西。理由诚如小马哥说得那样很简单。css，全称Cascading Style Sheets (层叠样式表单)。层叠即意味这后面的css可以覆盖前面的css，级别高的css可以覆盖级别低的css。在[css之！important] 这篇文章的最下面曾简单地提到过这层级关系，这里我们只需要知道css可以被覆盖的。既然前面的可以被覆盖，浏览器在他完全加载完毕之后再去渲染无疑也是合情合理的很多浏览器下，如IE，把样式表放在页面的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。所以我们应该尽快让css加载完毕\n顺着这层意思，如果我们再细究的话，其实还有可以优化的地方。比如本站上面包含的两个css文件，和。 从media就可以看出第一个css是针对浏览器的，第二个css文件是针对打印样式的。从用户的行为习惯上来将，要打印页面的动作一定是发生在页面页面 显示出来之后的。所以比较好的方法应该是在页面加载完毕之后再动态地为这张页面加上针对打印设备的css，这样又可以提高一点速度。（哈哈）\n第六条、将script放在页面最下面 （Put Scripts at the Bottom ）\n将脚本放在页面最下面的目的有那么两点： 1、 因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下 面的内容。不信你可以写一个js死循环看看页面下面的东西还会不会出来。（setTimeout 和 setInterval的执行有点类似于多线程，在相应的响应时间之前也会继续下面的内容渲染。）浏览器这么做的逻辑是因为js随时可能执 行 location.href或是其他可能完全中断此页面过程的函数，即如此，当然得等他执行完毕之后再加载咯。所以放在页面最后，可以有效减少页面可 视元素的加载时间。 2、脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个（IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个）。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载。\n当然对各个网站来说，把脚本都放到页面底部加载的可行性还是值得商榷的。就比如阿里巴巴中文站的页面。很多地方有内联的js，页面的显示严重依赖于此，我承认这和无侵入脚本的理念相差甚远，但是很多“历史遗留问题”却不是那么容易解决的。\n**第七条、 避免在CSS中使用Expressions** （Avoid CSS Expressions ）\n不过这样就多了两层无意义的嵌套，肯定不好。还需要一个更好的办法。\n**第八条、 把javascript和css都放到外部文件中** （Make JavaScript and CSS External ）\n这点我想还是很容易理解的。不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增 大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。当然，我在前面中也说过，有些特殊的页面开发人员还是会选择内联 的css和js文件。\n第九条、减少DNS查询 (Reduce DNS Lookups)\n在 Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络 上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的 时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域 名数尽量控制在2-4个。这就需要对页面整体有一个很好的规划。目前我们这点做的不好，很多打点的广告投放系统拖累了我们。\n第十条、压缩 JavaScript 和 CSS (Minify JavaScript )\n压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。这点我们做得不错。常用的压缩工具有JsMin、YUI compressor等。另外像http://dean.edwards.name/packer/还给我们提供了一个非常方便的在线压缩工具。你可以在jQuery的网页看到压缩过的js文件和没有压缩过的js文件的容量差别：\n[外链图片转存失败(img-7D9UjX06-1562139364813)(http://www.phpv.net/uploadfile/month_200901/local_8heSvTS1TB.jpg)]\n当然，压缩带来的一个弊端就是代码的可读性没了。相信很多做前端的朋友都遇到过这个问题：看Google的效果很酷，可是去看他的源代码却是一大堆 挤在一起的字符，连函数名都是替换过的，汗死！自己的代码也这样岂不是对维护非常不方便。所有阿里巴巴中文站目前采用的做法是在js和css发布的时候在 服务器端进行压缩。这样在我们很方便地维护自己的代码。\n第十一条、避免重定向 (Avoid Redirects )\n不久前在ieblog上看到过《Internet Explorer and Connection Limits》这篇文章，比如 当你输入http://www.kuqin.com/ 的时候服务器会自动产生一个301服务器转向 http://www.kuqin.com/ ，你看浏览器的地址栏就能看出来。这种重定向自然也是需要消耗时间的。当然这只是一个例子，发生重定向的原因还有很多，但是不变的是每增加一次重定向就会增加一次web请求，所以因该尽量减少。\n第十二条、移除重复的脚本 (Remove Duplicate Scripts )\n这点我想不说也知道，不仅是从性能上考虑，代码规范上看也是这样。但是不得不承认，很多时候我们会因为图一时之快而加上一些或许是重复的代码。或许一个统一的css框架和js框架可以比较好的解决我们的问题。小猪的观点很对，不仅是要做到不重复，更是要做到可重用。\n第十三条、配置实体标签（ETags） (Configure ETags )\n这点我也不懂，呵呵。在inforQ上找到一篇解释得比较详细的说明《使用ETags减少Web应用带宽和负载》，有兴趣的同学可以去看看。\n第十四条、使 AJAX 缓存 (Make Ajax Cacheable )\najax还要去缓存？做ajax请求的时候往往还要增加一个时间戳去避免他缓存。It’s important to remember that “asynchronous” does not imply “instantaneous”.（记住“异步”不是“瞬间”这一点很重要）。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓 存。\n","href":"/post/20190626102231/","title":"网站优化 14条--雅虎十四条优化原则"},{"content":" 1.内联CSS 内联CSS也可称为行内CSS或者行级CSS，它直接在标签内部引入，显著的优点是十分的便捷、高效；但是同时也造成了不能够重用样式的缺点，如果代码行数到达一定长度不建议采用。通常内联CSS作为测试使用，可以查找代码中bug。\n\u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 65px;height: 20px;border: 1px solid;\u0026#34;\u0026gt;测试元素div\u0026gt; \u0026lt;body\u0026gt; 2.页级CSS 页级CSS也可称为内部CSS，整体是放在head标签里边的，在style标签里边定义样式，作用范围和字面意思相同，仅限于本页面的元素；如果你写的代码超过了几百行，想想每次把代码页拉到最上边都很烦，所以它在可维护性方面较差。\n\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;测试title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; div { width: 65px; height: 20px; border: 1px solid; background: greenyellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 3. 外联CSS 外联CSS也可称为外部CSS，在实际的项目中通常使用此种方式，它只在页面中使用link或者@import引入即可，可维护性好；并且外联CSS是一个单独的文件，可以作用于多个页面，在修改的时候可以针对性地修改某一块区域，达到多个页面样式同时变更，相较于内联CSS和页级CSS，省去了到每个页面修改的步骤，提高了开发效率，同时一定程度提高了性能。\n接下来具体说说link和@import的区别：\n(1)link: link语法格式中，rel指的是关联(relation)，type指的是类型，href指的是链接文件路径。\nlink的作用主要用来引入CSS和网页图标，指示告知搜索引擎，网页之间的关系等。\n(2)@import: @import语法格式务必写在style标签中，后直接加文件路径即可。\n@import作用在CSS文件和页面中，可以在一个CSS文件中引入其他的CSS文件，例如在index.css文件中引入其他CSS文件的样式，整合在一起后，再在index.html中调用一次即可，在实际项目中经常使用，方便管理和维护。\n(3)二者加载顺序影响 HTML加载过程：\n1) 加载HTML-DOM结构 2)CSS和JS 3)图片和多媒体 4)加载事件触发 link和@import都没有放置顺序的要求，但是不同的放置位置可能会造成效果显示的差异。对于link，无论放到哪个位置，都是一边加载数据，一边进行优化，视觉感受很好；而对于@import，放置到哪里，才从哪里开始加载CSS样式，即先加载数据，然后加载样式，如果网速不佳，可能会造成只有数据出来，而样式一点点加载的效果。并且在同一个页面中，调用两种方式，link永远比@import优先级高。\n在项目中使用的时候，一般在页面中调用方式为link，并且放在head标签中；使用@import除了在CSS文件中，在页面调用时，一般加载第三方的样式会使用到，并且需要放置在页面的底部，不会影响自己的网站。\n","href":"/post/20190625205945/","title":"CSS三种引入方式：内联、页级、外联"},{"content":" 实例 开启 debugger ，代码在执行到第三行前终止。\nvar x = 15 * 5; debugger; document.getElementbyId(\u0026#34;demo\u0026#34;).innerHTML = x;  定义和用法 debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。\n使用 debugger 语句类似于在代码中设置断点。\n通常，你可以通过按下 F12 开启调试工具， 并在调试菜单中选择\u0026rdquo;Console\u0026rdquo; 。\n注意： 如果调试工具不可用，则调试语句将无法工作。\n更多 JavaScript 调试信息，及在浏览器不支持的情况下如何激活浏览器的调试工具，请查阅我们的JavaScript调试 教程。\n浏览器支持\n 语句\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;  debugger\n  Yes\n  Yes\n  Yes\n  Yes\n  Yes\n  语法  JavaScript 版本：\n  1.0\n  ","href":"/post/20190625164126/","title":"JavaScript debugger 语句"},{"content":"","href":"/tags/debug/","title":"debug"},{"content":"第1种：对象字面量\n//对象字面量（速度快，推荐使用） var animal = {property: \u0026#34;都要呼吸\u0026#34;, getProperty: function(){return this.property;}}; var person = {feature: \u0026#34;直立行走\u0026#34;, getFeature: function(){return this.feature;}};  第2种：Object构造函数\nvar animal = new Object(); animal.property=\u0026#34;都要呼吸\u0026#34;; animal.getProperty=function(){return this.property;} var person = new Object(); person.feature=\u0026#34;直立行走\u0026#34;; person.getFeature = function(){return this.feature;}  第3种：工厂模式\nfunction createAnimal(){var animal=new Object();animal.property=\u0026#34;都要呼吸\u0026#34;;animal.getProperty=function(){return this.property;} return animal;} function createPerson(){var person=new Object();person.feature=\u0026#34;直立行走\u0026#34;;person.getFeature=function(){return this.feature;} return person;} var animal = createAnimal(); var person = createPerson();  第4种：构造函数模式\nfunction Animal(){this.property=\u0026#34;都要呼吸\u0026#34;;this.getProperty=function(){return this.property;};} function Person(){this.feature=\u0026#34;直立行走\u0026#34;;this.getFeature=function(){return this.feature;};} var animal = new Animal(); var person = new Person();  第5种：原型模式\nfunction Animal(){} Animal.prototype.property=\u0026#34;都要呼吸\u0026#34;; Animal.prototype.getProperty=function(){return this.property;} function Person(){} Person.prototype.feature=\u0026#34;直立行走\u0026#34;; Person.prototype.getFeature=function(){return this.feature;} var animal=new Animal(); var person=new Person();  第6种：组合使用构造函数模式和原型模式\nfunction Animal(){this.property=\u0026#34;都要呼吸\u0026#34;;} Animal.prototype.getProperty=function(){return this.property;} function Person(){this.feature=\u0026#34;直立行走\u0026#34;;} Person.prototype.getFeature=function(){return this.feature;} var animal=new Animal(); var person=new Person();  第7种：动态原型模式\nfunction Animal(){ this.property=\u0026#34;都要呼吸\u0026#34;; if(typeof this.getProperty!=\u0026#34;function\u0026#34;){ Animal.prototype.getProperty=function(){return this.property;} }} function Person(){ this.feature=\u0026#34;直立行走\u0026#34;; if(typeof this.getFeature!=\u0026#34;function\u0026#34;){ Person.prototype.getFeature=function(){return this.feature;} }} var animal=new Animal(); var person=new Person();  第8种：寄生构造函数模式\nfunction Animal(){this.property=\u0026#34;都要呼吸\u0026#34;;this.getProperty=function(){return this.property;};} function Person(){var animal=new Animal();animal.property=\u0026#34;直立行走\u0026#34;;return animal;} var person=new Person();  第9种：稳妥构造函数模式\nfunction Animal(){var animal=new Object();var property=\u0026#34;都要呼吸\u0026#34;;animal.getProperty=function(){return property;} return animal;} function Person(){var person=new Object();var feature=\u0026#34;直立行走\u0026#34;;person.getFeature=function(){return feature;} return person;} var animal=Animal(); var person=Person();  第10种：Object.create()\nvar person={feature: \u0026#34;直立行走\u0026#34;, getFeature: function(){return this.feature;}} var p1=Object.create(person); ","href":"/post/20190624213600/","title":"javascript创建对象的10种模式"},{"content":" 第一种：原型链继承： function Animal(){ this.property=\u0026#34;都要呼吸\u0026#34;; } Animal.prototype.getProperty = new function(){ return this.property; } function Person(){ this.feature=\u0026#34;直立行走\u0026#34;; } Person.prototype = new Animal(); Person.prototype.getFeature = function(){ return this.feature; } var p1 = new Person(); console.log(p1.getProperty()); console.log(p1.getFeature());  第二种：借用构造函数继承: function Animal(){ this.property=\u0026#34;都要呼吸\u0026#34;; this.getProperty=function(){ return this.property; }; } function Person(){ Animal.call(this); this.feature=\u0026#34;直立行走\u0026#34;; } Person.prototype.getFeature = function(){ return this.feature; } var p1 = new Person(); console.log(p1.getProperty()); console.log(p1.getFeature());  第三种：组合继承:（最常用的继承模式） function Animal(){ this.property=\u0026#34;都要呼吸\u0026#34;; } Animal.prototype.getProperty = function(){ return this.property; }; function Person(){ Animal.call(this); this.feature=\u0026#34;直立行走\u0026#34;; } Person.prototype = new Animal(); Person.prototype.constructor = Person; Person.prototype.getFeature = function(){ return this.feature; }; console.log(Person.getProperty()); console.log(Person.getFeature());  第四种：原型式继承 var animal = { property: \u0026#34;都要呼吸\u0026#34;; getProperty: function(){ return this.property; } }; function person(animal){ function Person(){ this.feature=\u0026#34;直立行走\u0026#34;; } Person.prototype=animal; Person.prototype.getFeature(){ return this.feature; } return new Person(); }; var p1 = person(animal); console.log(p1.getProperty()); console.log(p1.getFeature());  ECMAScript 5通过新增Object.create()方法规范化了原型式继承。 var animal = { property: \u0026#34;都要呼吸\u0026#34;; getProperty: function(){ return this.property; } } var p1 = Object.create( animal, { feature: { value: \u0026#34;直立行走\u0026#34; }, getFeature: { value: function(){ return this.feature; } } } ); console.log(p1.getProperty()); console.log(p2.getFeature());  第五种：寄生式继承 var animal = { property: \u0026#34;都要呼吸\u0026#34;; getProperty: function(){ return this.property; } }; function person(animal){ var p1 = Object.create( animal, { feature: { value: \u0026#34;直立行走\u0026#34; } } ); p1.getFeature = function(){ return this.feature; }; return p1; } var p1 = person(animal); console.log(p1.getProperty()); console.log(p1.getFeature());  第六种：寄生组合式继承 function Animal(){ this.property=\u0026#34;都要呼吸\u0026#34;; } Animal.prototype.getProperty=function(){ return this.property; } function Person(){ Animal.call(this); this.feature=\u0026#34;直立行走\u0026#34;; } function inheritPrototype(Person, Animal){ var person=Object.create(Animal.prototype); person.constructor=Person; Person.prototype=person; } inheritPrototype(Person, Animal); Person.prototype.getFeature=function(){ return this.feature; } var p1 = new Person(); console.log(p1.getProperty()); console.log(p1.getFeature()); ","href":"/post/20190624200748/","title":"javascript继承的6种方式"},{"content":"","href":"/tags/%E7%BB%A7%E6%89%BF/","title":"继承"},{"content":"","href":"/tags/pdf%E5%8E%8B%E7%BC%A9/","title":"pdf压缩"},{"content":"","href":"/tags/smallpdf/","title":"smallpdf"},{"content":"","href":"/categories/%E5%B7%A5%E5%85%B7/","title":"工具"},{"content":"Smallpdf目前是全网免费的pdf压缩工具中压缩率最高的，没有之一。但是由于目前在线的版本开始收费了，所以我专门下载了离线版进行crack，供以后长期使用。目前这个离线版本的压缩效果还是相当不错，它比目前流行的pdf压缩工具PDFCompressor的压缩效果要好50%。yqiq, fnas\n","href":"/post/20190622235521/","title":"强大的pdf压缩工具"},{"content":"","href":"/tags/time-machine/","title":"time machine"},{"content":" 前言  最近这一个月，我发现我的mac空间不足了。我一直以为是我项目占据了很多空间。因此，不停的进行清理不用的东西。最后，还是发现空间不够。这个清理工作反反复复持续了几周，我电脑硬盘的可以存储空间还是很少。在不经意间，我用外部硬盘time machine备份了一下电脑，瞬间多了一大半的存储空间。我前面几个月也是经常备份电脑的，但是最近这个月由于论文和找工作的缘故没有时间备份。\n 总结 mac如果开启time machine功能，就会定期进行备份。如果不用外部硬盘进行备份，就会先被分在本机硬盘上。这样会消耗大量的存储空间。但是，如果不开time machine，资料就没有保障。因此，定期用外部硬盘进行备份尤为重要。\n","href":"/post/20190622192423/","title":"关于mac的time machine功能"},{"content":"","href":"/tags/css/","title":"css"},{"content":" 每个属性之间用分号\u0026rdquo;;\u0026ldquo;隔开;  ","href":"/post/20190622151359/","title":"css书写常见错误"},{"content":" new Vue(), V要大写 .vue文件中的\u0026lt;template\u0026gt;\u0026lt;/template\u0026gt;中不可以出现空行 vue模板中的el指向的是id，所以为了标识id，在前面要加上\u0026rdquo;#\u0026rdquo;  ","href":"/post/20190622103331/","title":"vue常见错误汇总"},{"content":"   方法 addClass() attr()     用途 追加样式 设置样式   对同一个网页元素操作 \u0026lt;p\u0026gt;test\u0026lt;/p\u0026gt;    第1次使用方法 $(\u0026quot;p\u0026quot;).addClass(\u0026quot;high\u0026quot;); $(\u0026quot;p\u0026quot;).attr(\u0026quot;class\u0026quot;, \u0026quot;high\u0026quot;);   第1次结果 \u0026lt;p class=\u0026quot;high\u0026quot;\u0026gt;test\u0026lt;/p\u0026gt;    再次使用方法 $(\u0026quot;p\u0026quot;).addClass(\u0026quot;another\u0026quot;); $(\u0026quot;p\u0026quot;).attr(\u0026quot;class\u0026quot;, \u0026quot;another\u0026quot;);   最终结果 \u0026lt;p class=\u0026quot;high another\u0026quot;\u0026gt;test\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026quot;another\u0026quot;\u0026gt;test\u0026lt;/p\u0026gt;    ","href":"/post/20190622092813/","title":"attr()和addClass()的区别"},{"content":"","href":"/tags/val/","title":"val"},{"content":"\u0026lt;select id=\u0026#34;single\u0026#34;\u0026gt; \u0026lt;option\u0026gt;选择1号\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选择2号\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选择3号\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;multiple\u0026#34; multiple=\u0026#34;multiple\u0026#34; style=\u0026#34;height:120px;\u0026#34;\u0026gt; \u0026lt;option selected=\u0026#34;selected\u0026#34;\u0026gt;选择1号\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选择2号\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选择3号\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选择4号\u0026lt;/option\u0026gt; \u0026lt;option selected=\u0026#34;selected\u0026#34;\u0026gt;选择5号\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;check1\u0026#34;/\u0026gt;多选1 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;check2\u0026#34;/\u0026gt;多选2 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;check3\u0026#34;/\u0026gt;多选3 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;check4\u0026#34;/\u0026gt;多选4 \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;radio1\u0026#34;/\u0026gt;单选1 \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;radio2\u0026#34;/\u0026gt;单选2 \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;radio3\u0026#34;/\u0026gt;单选3 该网页中的一些元素是默认选中的，可以通过val()方法来改变它们的选中项。如果要使第1个下拉框的第2项被选中，可以用以下jQuery代码实现：\n$(\u0026#34;#single\u0026#34;).val(\u0026#34;选择2号\u0026#34;);  如果使下拉框的第2项和第3项被选中，可以用以下jQuery代码实现:\n$(\u0026#34;#multiple\u0026#34;).val([\u0026#34;选择2号\u0026#34;, \u0026#34;选择3号\u0026#34;]);  按照上面类似的写法，下面的代码可以使多选框和单选框被选中，jQuery代码如下：\n$(\u0026#34;:checkbox\u0026#34;).val([\u0026#34;check2\u0026#34;, \u0026#34;check3\u0026#34;]); $(\u0026#34;:radio\u0026#34;).val([\u0026#34;radio2\u0026#34;]); ","href":"/post/20190622092753/","title":"val()方法的选中功能"},{"content":"   方法 描述 示例     parent() 获得集合中每个匹配元素的父级元素 $('.item-1').parent().css('background-color','red'); parent()方法从指定类型的直接父节点开始查找。parent()返回一个元素节点。   parents() 获得集合中每个匹配元素的祖先元素 $('.item-1').parents('ul').css('background-color', 'red');\nparents()方法查找同parent()方法类似，不同的一点在于，当它找到第一个父节点时并没有停止查找，而是继续查找，最后返回多个父节点。   closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 $(.item-1).closest(\u0026quot;ul\u0026quot;).css(\u0026quot;background-color\u0026quot;, 'red');\nclosest()方法查找是从包含自身的节点找起，它同parents()方法类似，不同点在于它的只返回匹配的第一个节点。    ","href":"/post/20190622092726/","title":"parent()，parents()与closest()的区别"},{"content":" 如何打开snippet配置 这里以vscode为例，其他编辑器大概也差不多。在vscode中快捷键Ctrl + Shift + P打开命令窗口，然后输入snippet,选择配置用户代码片段，点击后，就可以愉快的进行片段的编写了。\nSnippet怎么用 先上一个Demo\n{ \u0026#34;vue\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;vue-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html lang=\\\u0026#34;zh\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;head\u0026gt;\u0026#34;, \u0026#34; \u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;title\u0026gt;${1:$CURRENT_DATE}\u0026lt;/title\u0026gt;\u0026#34;, \u0026#34; \u0026lt;style type=\\\u0026#34;text/css\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;/style\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://cdn.staticfile.org/vue/2.2.2/vue.min.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34; \u0026lt;script src=\\\u0026#34;https://server.lab421.top/前端开发/我自己的js库/wlib.js\\\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;script\u0026gt;\u0026#34;, \u0026#34;var data = {};\u0026#34;, \u0026#34;var vm = new Vue({\u0026#34;, \u0026#34; el: \u0026#39;#app\u0026#39;,\u0026#34;, \u0026#34; data: data,\u0026#34;, \u0026#34; methods: {}\u0026#34;, \u0026#34;});\u0026#34;, \u0026#34;\u0026lt;/script\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/html\u0026gt;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, }, \u0026#34;basic\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;basic-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html lang=\\\u0026#34;zh\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;head\u0026gt;\u0026#34;, \u0026#34; \u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;title\u0026gt;${1:$CURRENT_DATE}\u0026lt;/title\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/html\u0026gt;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, } } 基础结构\n{ \u0026#34;basic\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;basic-tl\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html lang=\\\u0026#34;zh\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;head\u0026gt;\u0026#34;, \u0026#34; \u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34; \u0026lt;title\u0026gt;${1:$CURRENT_DATE}\u0026lt;/title\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/body\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/html\u0026gt;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;create a html frame\u0026#34;, } }  片段名字 prefix（前缀，输入的触发条件，比如上面例子中当我输入ht后，就能tab出来片段） body（主体部分，在里面根据语法定义自己需要的代码片段） description（说明，片段的具体描述）  关键的一步配置 点击shift + command + P(mac上的快捷键)，输入Open Settings (JSON)回车，然后在settings.json中填写配置：\n\u0026quot;[markdown]\u0026quot;: { \u0026quot;editor.quickSuggestions\u0026quot;: true }  []中可以填写markdown，html和python等类型。\n基础语法  每个逗号代表一整行的结束，双引号需要用转义字符 \\ $number表示光标跳转的顺序，比如$1表示光标首次需要跳转的位置，相同序号的会在一起，另外$0表示最终光标位置 变量，在未赋值的情况下提供默认值，这里提供一些变量   TM_SELECTED_TEXT：当前选定的文本或空字符串； TM_CURRENT_LINE：当前行的内容； TM_CURRENT_WORD：光标所处单词或空字符串 TM_LINE_INDEX：行号（从零开始）； TM_LINE_NUMBER：行号（从一开始）； TM_FILENAME：当前文档的文件名； TM_FILENAME_BASE：当前文档的文件名（不含后缀名）； TM_DIRECTORY：当前文档所在目录； TM_FILEPATH：当前文档的完整文件路径； CLIPBOARD：当前剪贴板中内容。 时间相关 CURRENT_YEAR: 当前年份； CURRENT_YEAR_SHORT: 当前年份的后两位； CURRENT_MONTH: 格式化为两位数字的当前月份，如 02； CURRENT_MONTH_NAME: 当前月份的全称，如 July； CURRENT_MONTH_NAME_SHORT: 当前月份的简称，如 Jul； CURRENT_DATE: 当天月份第几天； CURRENT_DAY_NAME: 当天周几，如 Monday； CURRENT_DAY_NAME_SHORT: 当天周几的简称，如 Mon； CURRENT_HOUR: 当前小时（24 小时制）； CURRENT_MINUTE: 当前分钟； CURRENT_SECOND: 当前秒数。  + 可选项，当光标到该处的时候弹出一些可选择项，使用| ，|后面是自己提供的可选项 我这里是提供了两个值，值之间使用逗号进行分隔。 + body的高级语法，可以参考这里，写的很详细 + 把自己的snippet放到market上的教程，使劲戳这里   ","href":"/post/20190622092650/","title":"snippet，让你编码效率翻倍"},{"content":"","href":"/tags/%E7%BC%96%E7%A8%8B%E6%95%88%E7%8E%87/","title":"编程效率"},{"content":"   方法 描述 示例     append() 向每个匹配的元素内部追加内容 HTML代码: \u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt; jQuery代码: $(\u0026quot;p\u0026quot;).append(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;); 结果: \u0026lt;p\u0026gt;我想说：\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;   appendTo() 将所有匹配的元素追加到指定元素中，实际上，使用该方法是颠倒了常规的$(A).append(B)的操作，即不是将B追加到A中，而是将A追加到B中 HTML代码：\n\u0026lt;p\u0026gt;我想说:\u0026lt;/p\u0026gt; jQuery代码:\n$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).appendTo(\u0026quot;p\u0026quot;); 结果:\n\u0026lt;p\u0026gt;我想说：\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;   prepend() 向每个匹配的元素内部前置内容 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt; jQuery代码：\n$(\u0026quot;p\u0026quot;).prepend(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;);\n结果：\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;我想说：\u0026lt;/p\u0026gt;   prependTo() 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).prepend(B)的操作，即不是将B前置到A中，而是将A前置到B中 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\njQuery代码:\n$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).prependTo(\u0026quot;p\u0026quot;);\n结果:\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;我想说：\u0026lt;/p\u0026gt;   after() 在每个匹配的元素之后插入内容 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\njQuery代码：\n$(\u0026quot;p\u0026quot;).after(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;);\n结果：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;   insertAfter() 将所有匹配的元素插入到指定元素的后面。实际上，使用该方法是颠倒了常规的$(A).after(B)的操作，即不是讲B插入到A后面，而是将A插入到B后面 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\njQuery代码:\n$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).insertAfter(\u0026quot;p\u0026quot;);\n结果：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;   before() 在每个匹配的元素之前插入内容 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\njQuery代码：\n$(\u0026quot;p\u0026quot;).before(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;);结果：\n\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;   insertBefore() 将所有匹配的元素插入到指定的元素的前面。实际上，使用该方法是颠倒了常规的$(A).before(B)的操作，即不是将B插入到A前面，而是将A插入到B前面 HTML代码：\n\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\njQuery代码：\n$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).insertBefore(\u0026quot;p\u0026quot;);\n结果：\n\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;    ","href":"/post/20190621195930/","title":"jQuery插入节点的方法"},{"content":"   选择器 描述 返回 示例     :input 选取所有的\u0026lt;input\u0026gt;、\u0026lt;textarea\u0026gt;、\u0026lt;select\u0026gt;和\u0026lt;button\u0026gt;元素 集合元素 $(\u0026quot;:input\u0026quot;)选取所有\u0026lt;input\u0026gt;、\u0026lt;textarea\u0026gt;、\u0026lt;select\u0026gt;和\u0026lt;button\u0026gt;元素   :text 选取所有的单行文本框 集合元素 $(\u0026quot;:text\u0026quot;)选取所有的单行文本框   :password 选取所有的密码框 集合元素 $(\u0026quot;:password\u0026quot;)选取所有的密码框   :radio 选取所有的单选框 集合元素 $(\u0026quot;:radio\u0026quot;)选取所有的单选框   :checkbox 选取所有的复选框 集合元素 $(\u0026quot;:checkbox\u0026quot;)选取所有的复选框   :submit 选取所有的提交按钮 集合元素 $(\u0026quot;:submit\u0026quot;)选取所有的提交按钮   :image 选取所有的图像按钮 集合元素 $(\u0026quot;:image\u0026quot;)选取所有的图像按钮   :reset 选取所有的重置按钮 集合元素 $(\u0026quot;:reset\u0026quot;)选取所有的重置按钮   :button 选取所有按钮 集合元素 $(\u0026quot;:button\u0026quot;)选取所有的按钮   :file 选取所有的上传域 集合元素 $(\u0026quot;:file\u0026quot;)选取所有的上传域   :hidden 选取所有不可见元素 集合元素 $(\u0026quot;:hidden\u0026quot;)选取所有不可见元素（已经在不可见过滤选择器中讲解过）    ","href":"/post/20190621134332/","title":"表单选择器"},{"content":"   选择器 描述 返回 示例     :enabled 选取所有可用的元素 集合元素 $('#form1:enabled');选取id为\u0026rdquo;form1\u0026rdquo;的表单内的所有可用元素   :disabled 选取所有不可用的元素 集合元素 $(\u0026quot;#form2:disabled\u0026quot;)选取id为\u0026rdquo;form2\u0026rdquo;的表单内的所有不可用的元素   :checked 选取所有被选中的元素（单选框，复选框） 集合元素 $(\u0026quot;input:checked\u0026quot;)；选取所有被选中的\u0026lt;input\u0026gt;元素   :selected 选取所有被选中的选项元素（下拉列表） 集合元素 $(\u0026quot;select option:checked\u0026quot;);选取所有被选中的选项元素    ","href":"/post/20190621112044/","title":"表单对象属性过滤选择器"},{"content":"","href":"/tags/%E9%80%89%E6%8B%A9%E5%99%A8/","title":"选择器"},{"content":"","href":"/tags/%E5%AD%90%E5%85%83%E7%B4%A0/","title":"子元素"},{"content":"   选择器 描述 返回 示例     :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而:eq(index)是从0算起的   :first-child 选取每个父元素的第一个子元素 集合元素 :first只返回单个元素，而:first-child选择符将为每个父元素匹配第一个子元素。\n例如$('ul li:first-child')；选取每个\u0026lt;ul\u0026gt;中第一个\u0026lt;li\u0026gt;元素   :last-child 选取每个父元素的最后子元素 集合元素 同样，:last只返回单个元素，而:last-child选择符将为每个父元素匹配最后一个子元素。\n例如$('ul li:last-child');选择每个\u0026lt;ul\u0026gt;中最后一个\u0026lt;li\u0026gt;元素   :only-child 如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $('ul li:only-child')\n在\u0026lt;ul\u0026gt;中选取是唯一子元素的\u0026lt;li\u0026gt;元素    ","href":"/post/20190621111026/","title":"子元素过滤选择器"},{"content":"   选择器 描述 返回 示例     [attribute] 选取拥有此属性的元素 集合元素 $(‘div[id]’)选取拥有属性id的元素   [attribute=value] 选取属性的值为value的元素 集合元素 $(‘div[title=test]’)选取属性title为“test”的\u0026lt;div\u0026gt;元素   [attribute!=value] 选取属性的值不等于value的元素 集合元素 $('div[title!=test]')选取属性title不等于\u0026rdquo;test\u0026rdquo;的\u0026lt;div\u0026gt;元素（注意：没有属性title的\u0026lt;div\u0026gt;元素也会被选取）   [attribute^=value] 选取属性的值以value开始的元素 集合元素 $('div[title^=test]')选取属性title以“test”开始的\u0026lt;div\u0026gt;元素   [attribute$=value] 选取属性的值以value结束的元素 集合元素 $('div[title$=test]')选取属性title以“test”结束的\u0026lt;div\u0026gt;元素   [attribute*=value] 选取属性的值含有value的元素 集合元素 $('div[title*=test]')选取属性title含有\u0026rdquo;test\u0026rdquo;的\u0026lt;div\u0026gt;元素   `[attribute =value]` 选取属性等于给定字符串或以该字符串为前缀（该字符串后跟一个连字符“-”）的元素 集合元素   [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $('div[title~=\u0026quot;uk\u0026quot;]')选取属性title用空格分隔的值中包含字符uk的元素   [attribute1][attribute2]...[attributeN] 用属性选择器合并成一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围。 集合元素 $('div[id][title$=\u0026quot;test\u0026quot;]')选取拥有属性id，并且属性title以“test”结束的\u0026lt;div\u0026gt;元素    ","href":"/post/20190621104825/","title":"属性过滤选择器"},{"content":"   选择器 描述 返回 示例     :hidden 选取所有不可见的元素 集合元素 $(\u0026quot;:hidden\u0026quot;)选取所有不可见的元素。包括\u0026lt;input type=\u0026quot;hidden\u0026quot;/\u0026gt;，\u0026lt;div style=\u0026quot;display:none\u0026quot;\u0026gt;和\u0026lt;div style=\u0026quot;visibility:hidden;\u0026quot;\u0026gt;等元素。如果只想选取\u0026lt;input\u0026gt;元素，可以使用$(\u0026quot;input:hiddden\u0026quot;)   :visible 选取所有可见的元素 集合元素 $(\u0026quot;div:visible\u0026quot;)选取所有可见的\u0026lt;div\u0026gt;元素    ","href":"/post/20190621102607/","title":"可见性过滤选择器"},{"content":"   选择器 描述 返回 示例     :contains(text) 选取含有文本内容为“text”的元素 集合元素 $('div:contains('我')')选取含有文本“我”的\u0026lt;div\u0026gt;元素   :empty 选取不包含子元素或者文本的空元素 集合元素 $('div:empty')选取不包含子元素（包括文本元素）的\u0026lt;div\u0026gt;空元素   :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $('div:has(p)')选取含有\u0026lt;p\u0026gt;元素的\u0026lt;div\u0026gt;元素   :parent 选取含有子元素或者文本的元素 集合元素 $('div:parent')选取拥有子元素（包括文本元素）的\u0026lt;div\u0026gt;元素    ","href":"/post/20190621101710/","title":"内容过滤选择器"},{"content":"   选择器 描述 返回 示例     :first 选取第一个元素 单个元素 $('div:first')选取所有\u0026lt;div\u0026gt;元素中第一个\u0026lt;div\u0026gt;元素   :last 选取最后一个元素 单个元素 $('div:last')选取所有元素最后一个`元素   :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $('input:not(.myClass)')选取class不是myClass的\u0026lt;input\u0026gt;元素   :even 选取索引是偶数的所有元素，索引从0开始 集合元素 $('input:even')选取索引是偶数的\u0026lt;input\u0026gt;元素   :odd 选取索引是奇数的所有元素，索引从0开始 集合元素 $('input:odd')选取索引是奇数的\u0026lt;input\u0026gt;元素   :eq(index) 选取索引等于index的元素（index从0开始） 单个元素 $('input:eq(1)')选取索引等于1的元素   :gt(index) 选取索引大于index的元素(index从0开始) 集合元素 $('input:gt(1)')选取索引大于1的\u0026lt;input\u0026gt;元素（注：大于1，不包括1）   :lt(index) 选取索引小于index的元素(index从0开始) 集合元素 $('input:lt(1)')选取索引小于1的\u0026lt;input\u0026gt;元素（注：小于1，不包括1）   :header 选取所有的标题元素，例如h1，h2，h3等等 集合元素 $(':header')选取网页中所有的\u0026lt;h1\u0026gt;，\u0026lt;h2\u0026gt;，\u0026lt;h3\u0026gt;\u0026hellip;\u0026hellip;   :animated 选取当前正在执行动画的所有元素 集合元素 $('div:animated')选取正在执行动画的\u0026lt;div\u0026gt;元素   :focus 选取当前获取焦点的元素 集合元素 $(':focus')选取当前获取焦点的元素    ","href":"/post/20190621100750/","title":"基本过滤选择器"},{"content":"   选择器 描述 返回 示例     $(\u0026quot;ancestor descendant\u0026quot;) 选取ancestor元素里的所有descendant（后代）元素 集合元素span $(\u0026quot;div span\u0026quot;)\n选取\u0026lt;div\u0026gt;里的所有的\u0026lt;span\u0026gt;元素   $(\u0026quot;parent \u0026gt; child\u0026quot;) 选取parent元素下的child（子）元素，与$(\u0026quot;ancestor descendant\u0026quot;)\n有区别，$(\u0026quot;ancestor descendant\u0026quot;)\n选择的是后代元素 集合元素 $(\u0026quot;div \u0026gt; span\u0026quot;)\n选取\u0026lt;div\u0026gt;元素下元素名是\u0026lt;span\u0026gt;的子元素   $(\u0026quot;prev + next\u0026quot;) 选取紧接在prev元素后的next元素 集合元素 $(\u0026quot;.one + div\u0026quot;)\n选取class为one的下一个\u0026lt;div\u0026gt;同辈元素   $(\u0026quot;prev ~ siblings\u0026quot;) 选取prev元素之后的所有siblings元素 集合元素 $(\u0026quot;#two ~ div\u0026quot;)\n选取id为two的元素后面的所有\u0026lt;div\u0026gt;同辈元素    ","href":"/post/20190621091652/","title":"层次选择器的4种选择器列表"},{"content":"   选择器 描述 返回 示例     #id 根据给定的id匹配一个元素 单个元素 $(\u0026quot;#test\u0026quot;)选取id为test的元素   .class 根据给定的类名匹配元素 集合元素 $(\u0026quot;.test\u0026quot;)选取所有class为test的元素   element 根据给定的元素名匹配元素 集合元素 $(\u0026quot;p\u0026quot;)选取所有的\u0026lt;p\u0026gt;元素   * 匹配所有元素 集合元素 $(\u0026quot;*\u0026quot;)选取所有的元素   selector1, selector2, \u0026hellip;., selectorN 将每一个选择器匹配到的元素合并后一起返回 集合元素 $(\u0026quot;div, span, p.myClass\u0026quot;)选取所有\u0026lt;div\u0026gt;,\u0026lt;span\u0026gt;和拥有class为myclass的\u0026lt;p\u0026gt;标签的一组元素    ","href":"/post/20190621090254/","title":"jQuery基本选择器"},{"content":"","href":"/tags/svd/","title":"SVD"},{"content":"","href":"/post/20190620213838/","title":"SVD分解"},{"content":"","href":"/categories/%E6%95%B0%E5%AD%A6/","title":"数学"},{"content":"","href":"/tags/python3/","title":"python3"},{"content":" 前言 在我们遇到需要把字符串中多个指定字符转换成其他字符时，我们通常使用多个.replace()方法实现替换的目的。然而，当需要替换的字符很多的时候，使用.replace()就太麻烦了。\n解决方案 str.maketrans(in_str1, out_str2), 这是一个类似于对字符串之间建立映射的一个方法，且两个输入字符串的长度必须相等。下面我将举一个简单例子来说明它的使用方法：\na = \u0026#34;hello-world!\u0026#34; trans = str.maketrans(\u0026#34;h-w\u0026#34;, \u0026#34;H W\u0026#34;) # 建立映射关系 a.translate(trans) // 输出\u0026#34;Hello World!\u0026#34;","href":"/post/20190620141309/","title":"python3 快速替换多个字符的高效方法"},{"content":"","href":"/tags/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6/","title":"替换字符"},{"content":"","href":"/tags/anki/","title":"anki"},{"content":"   保留字 备注     FrontSide 正面，   type 打字   cloze 填空    ","href":"/post/20190619223131/","title":"anki保留字"},{"content":"","href":"/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","title":"学习方法"},{"content":"  注意：开发文档里面不重要的内容，本篇博客不进行翻译，依然英文显示\n 基础 卡片（Cards） 卡片就是问题和答案对——即正反两面分别是问题和答案。Anki的卡片不是一张真正的卡片，它一直显示问题，回答完显示答案。举一个例子：\n 问题：氧气的化学符号是什么？\n 当你考虑问题完毕，点击卡片就会显示如下内容：\n 问题：氧气到的化学符号是什么？\n回答：O\n 然后在卡片的最下方，你可以选择一个选项告诉anki你的学习情况。\n牌组（Desks） 牌组是卡片的集合。你可以把卡片放在不同的牌组中学习，而没有必要一次性全部学完。每个牌组都可以有不同的设置，比如每天显示多少张卡片，或卡片下一次复习的时间。\n牌组之间可以多层嵌套，形成树形结构。Anki通过\u0026rdquo;::\u0026ldquo;来表明不同的层次。比如，一个名为“Chinese::Hanzi”的牌组，表示Hanzi牌组包含在Chinese牌组中。如果你选择“Hanzi”那么就只会显示“Hanzi”牌组中的卡片；如果你选择\u0026rdquo;Chinese\u0026rdquo;牌组就会显示全部包括在“Hanzi”牌组中的卡片。\n为了形成树形结构，我们不仅可以通过“::“符号，还可以使用拖拽的方式。嵌套在其他牌组下面的牌组称为子牌组（名称中至少出现一次\u0026rdquo;::\u0026ldquo;）,最外面的牌组可以被称为超级牌组或父牌组。\nAnki有一个默认牌组；任何其他牌组都是分离自这个默认牌组。Anki将会隐藏这个默认牌组当这个牌组中没有卡片，或已经存在其他的牌组。另外，你也可以重命名默认牌组并使用它。\n牌组可以放不同话题的卡片，而不是特定的卡片。具体可以参看合理的使用牌组部分。\n关于卡片在牌组中的显示顺序，可以查阅显示顺序部分。\n笔记和字段（Notes \u0026amp; Fields） 当制作卡片的时候，我们通常希望一些信息可以通过多张卡片显示出来。比如，如果你学习法语，你学习”bonjour“的意思是”hello“,你可能希望创建一张卡片显示\u0026rdquo;bonjour\u0026rdquo;回答\u0026rdquo;hello\u0026rdquo;，然后另一张卡片问你”hello“回答\u0026rdquo;bonjour\u0026rdquo;。前面一张卡片让你辨别单词含义，后面一张卡片则让你把单词翻译成本国语言。\n当使用纸质卡片的时候，你唯一的选择是两次写出信息，每张卡片一次。一些计算机卡片程序通过翻转正反面，使用更加轻松。这种程序对纸质情况有改进，但是存在两个缺点：\n Because such programs don’t track your performance of recognition and production separately, cards will tend not to be shown to you at the optimum time, meaning you forget more than you’d like, or you study more than is necessary. Reversing the question and answer only works when you want exactly the same content on each side. This means it’s not possible to display extra info on the back of each card for example.  Anki solves these problems by allowing you to split the content of your cards up into separate pieces of information. You can then tell Anki which pieces of information you want on each card, and Anki will take care of creating the cards for you and updating them if you make any edits in the future.\nImagine we want to study French vocabulary, and we want to include the page number on the back of each card. We want our cards to look like this:\n Q: Bonjour A: Hello Page #12   And:\n Q: Hello A: Bonjour Page #12   In this example, we have three pieces of related information: a French word, an English meaning, and a page number. If we put them together, they’d look like this:\n French: Bonjour English: Hello Page: 12   在Anki中，这个相关的信息叫做笔记，信息的每一个部分叫做字段。因此，我们可以这样认为：上面的这个笔记有三个字段，分别为French，English，和Page。\n为了添加和编辑这些字段，可以点击”Fields\u0026hellip;“按钮。关于更多字段的信息，请参考自定义字段部分。\n卡片类型（Card Types） 为了基于我们的笔记创建卡片，我们需要给出一个蓝图指明哪些字段出现在正面或反面。这个蓝图就叫做卡片类型；当你添加了一个笔记，Anki将会为每个卡片类型创建一个卡片。\n每个卡片类型都有两个模板，一个是问题模板，另一个是答案模板。在上面法语那个例子中，我们想要识别翻译的卡片是这个样子的：\n Q: Bonjour A: Hello Page #12   To do this, we can set the question and answer templates to:\n Q: {{French}} A: {{English}}\u0026lt;br\u0026gt; Page #{{Page}}   通过使用双括号括起的一个字段名称，我们告诉Anki用该字段中的实际信息替换该部分。任何未被大括号括起来的东西都保存不变。(比如，我们在添加字段的时候不必键入”Page #“——它会自动添加到每个卡片。) 是一个特殊的编码告诉Anki换行；更多的细节可以在模板部分看到。\nThe production card templates work in a similar way:\n Q: {{English}} A: {{French}}\u0026lt;br\u0026gt; Page #{{Page}}   Once a card type has been created, every time you add a new note, a card will be created based on that card type. Card types make it easy to keep the formatting of your cards consistent and can greatly reduce the amount of effort involved in adding information. They also mean Anki can ensure related cards don’t appear too close to each other, and they allow you to fix a typing mistake or factual error once and have all the related cards updated at once.\n为了添加或编辑卡片类型，点击”卡片\u0026hellip;“按钮。For more information on card types, please see the 卡片和模板 section.\n笔记类型 Anki allows you to create different types of notes for different material. Each type of note has its own set of fields and card types. It’s a good idea to create a separate note type for each broad topic you’re studying. In the above French example, we might create a note type called “French” for that. If we wanted to learn capital cities, we could create a separate note type for that as well, with fields such as “Country” and “Capital City”.\nWhen Anki checks for duplicates, it only compares other notes of the same type. Thus if you add a capital city called “Orange” using the capital city note type, you won’t see a duplicate message when it comes time to learn how to say “orange” in French.\nWhen you create a new collection, Anki automatically adds some standard note types to it. These note types are provided to make Anki easier for new users, but in the long run it’s recommended you define your own note types for the content you are learning. The standard note types are as follows:\nBasic Has Front and Back fields, and will create one card. Text you enter in Front will appear on the front of the card, and text you enter in Back will appear on the back of the card.\nBasic (and reversed card) Like Basic, but creates two cards for the text you enter: one from front→back and one from back→front.\nBasic (optional reversed card) This is a front→back card, and optionally a back→front card. To do this, it has a third field called “Add Reverse.” If you enter any text into that field, a reverse card will be created. More information about this is available in the 卡片和模板 section.\nCloze A note type which makes it easy to select text and turn it into a cloze deletion (e.g., “Man landed on the moon in […]” → “Man landed on the moon in 1969”). More information is available in the 完型填空删除 section.\nTo add your own note types and modify existing ones, you can use Tools → Manage Note Types from the main Anki window.\n   Note Notes and note types are common to your whole collection rather than limited to an individual deck. This means you can use many different types of notes in a particular deck, or have different cards generated from a particular note in different decks. When you add notes using the Add window, you can select what note type to use and what deck to use, and these choices are completely independent of each other. You can also change the note type of some notes after you’ve already created them.      ","href":"/post/20190619215021/","title":"anki最新开发文档（2.1）"},{"content":" jQuery中最有特色的莫过于它的链式操作方式——即对发生在同一个jQuery对象上的一组动作，可以直接连写而无需重复获取对象。这一特点是jQuery的代码无比优雅。 百度CDN: https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js     window.onload与$(document).ready()的对比(p6) window.onload $(document).ready()     执行时机 必须等待网页中所有元素加载完毕后（包括元素的所有关联文件）完全加载到浏览器后才能执行——即js此时可以访问页面中的任何元素 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完—即DOM完全就绪   多次使用 不能同时编写多个以下代码无法正确执行：\nwindow.onload = function(){\nalert(\u0026quot;test1\u0026quot;)\n};\nwindow.onload = function(){\nalert(\u0026quot;test2\u0026quot;);\n}\n结果只会输出“test2”\n$(window).load(function(){\n//编写代码\n});\n等价于JavaScript中的以下代码：\nwindow.onload = function(){\n//编写代码\n} 能同时编写多个一下代码正确执行：\n$(document).ready(function(){\nalert(\u0026quot;Hello World!\u0026quot;);\n});\n$(document).ready(function(){\nalert(\u0026quot;Hello again!\u0026quot;);\n});\n结果两次都输出   简化写法 无 $(document).ready(function(){\n//...\n})\n可以简化为：\n$function(){\n//...\n}\n第二种方式为：\n$().ready(function(){\n//...\n});    ","href":"/post/20190619170644/","title":"jquery要点"},{"content":"","href":"/tags/linux/","title":"linux"},{"content":"ffmpeg -i 名称.mkv -s hd720 -c:v libx264 -crf 23 -c:a aac -strict -2 名称.mp4","href":"/post/20190617145615/","title":"linux 和windows下使用ffmpeg将mkv转换为mp4"},{"content":"","href":"/tags/%E4%BF%A1%E6%81%AF%E5%8C%B9%E9%85%8D/","title":"信息匹配"},{"content":"","href":"/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/","title":"四六级"},{"content":" 标出每个问题的定位词； 然后对每一个选项分别进行定位词的查找，标出每个选项里面的定位词；  ","href":"/post/20190613104834/","title":"四六级信息匹配技巧"},{"content":"","href":"/categories/%E8%8B%B1%E8%AF%AD/","title":"英语"},{"content":" 引言 四六级阅读中，真正与解题有关的句子总共占了文章的1/3，因此真正用到的高级词汇不会很多。使用一些技巧可以快速的通过考试，如下：\n 浏览一遍问题的题干（不要翻译，只需要看句子的主谓宾），并标出定位词（最多由三个单词组成，找定位词主要靠个人感觉，需要多练） 读懂题干的意思 根据定位词定位1~2句话，优先选择定位词后面的句子，实在不行至多定位4句话，如果3句话定位不了，暂时先看后面的题目（定位的过程中，不要翻译，重要的事情说三遍，不要翻译，一般来说题目的序号和段落的序号是成正比的，举个例子，一般最后一题的答案会出现在最后一个段落） 精读定位句，遇到和答案长的一样的一定是正确答案，遇到绝对的词一定是错误选项 如果下一题的定位词也在这题的定位句中，那么可以把当前的定位句向后扩充到3句   表示绝对的词汇总（但出现在正确答案里面）：completely, 定位句前移的词（定位词后面的句子如果以这种词开头，就选择定位词前面的句子作为定位句）：if 表达否定的词：far from\n ","href":"/post/20190612101223/","title":"四六级仔细阅读技巧"},{"content":"","href":"/tags/%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7/","title":"阅读技巧"},{"content":"","href":"/tags/webpack/","title":"webpack"},{"content":" 当我们执行npm run dev命令的时候，我们想要自动开启浏览器，那么只需要在webpack-dev-server后面加上\u0026rdquo;\u0026ndash;open\u0026rdquo;参数，具体在package.json文件里面设置，配置文件内容如下：\n { \u0026#34;name\u0026#34;: \u0026#34;webpack-demo1\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack-dev-server --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack -p\u0026#34; }, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34; }","href":"/post/20190611225641/","title":"webpack如何设置是否自动开启浏览器"},{"content":"","href":"/tags/%E8%AE%BE%E7%BD%AE/","title":"设置"},{"content":"","href":"/tags/uefi/","title":"uefi"},{"content":"","href":"/tags/%E5%88%86%E5%8C%BA/","title":"分区"},{"content":" 遇到上面情况，我们通常使用boot-repair修复引导。但是这时会弹出一个错误： GPT detected. Please create a BIOS-Boot partition\n 遇到这个情况以后，我就疯狂百度资料，一直在找现成的解决方案，但是都不是没有解决问题的方案。这个期间我大概花了我半天的时间在检索资料，之后由于实在找不到资料。我只能冷静地分析这个错误，\u0026rdquo;Please create Bios-Boot partition\u0026rdquo;这个提示其实是提醒你创建一个用于引导的分区。由于是在UEFI模式下面，所以我们要创建一个格式为fat32 标识为boot, esp的分区（右键可以设置标签），如下图所示：\n创建好上面的分区以后，再使用boot-repair进行修复引导，就不会报错了😀😀😀😀😀\n","href":"/post/20190611191355/","title":"在UEFI模式下，linux误删EFI分区后，重新恢复引导"},{"content":"","href":"/tags/%E5%BC%95%E5%AF%BC/","title":"引导"},{"content":"from fontTools.ttLib import TTFont def get(): font = TTFont(\u0026#39;./tyc-num.woff\u0026#39;) font.saveXML(\u0026#39;./woff4.xml\u0026#39;)","href":"/post/20190611170124/","title":"python字体文件woff转xml"},{"content":"","href":"/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","title":"字符编码"},{"content":"","href":"/tags/%E7%88%AC%E8%99%AB/","title":"爬虫"},{"content":"","href":"/tags/webpack%E5%AE%89%E8%A3%85/","title":"webpack安装"},{"content":"cnpm install -g webpack cnpm install -g webpack-cli cnpm install -g webpack-dev-server","href":"/post/20190610215453/","title":"webpack安装教程"},{"content":"","href":"/tags/cnpm/","title":"cnpm"},{"content":"","href":"/tags/npm%E5%9B%BD%E5%86%85%E6%BA%90/","title":"npm国内源"},{"content":"淘宝镜像( cnpm ) - 淘宝NPM 镜像，用法和npm一模一样只是把npm改为cnpm\n","href":"/post/20190610215220/","title":"npm快速国内源"},{"content":" 介绍 Gparted是一个针对于linux分区调整的可视化工具。它是一个微型的linux操作系统封装了一些分区的命令，以一个iso格式的文件存在，选择gparted- live-*.iso这样的文件点击下载。\n刻录 下载完成之后，你需要准备一个刻录工具（比如软碟通）和一个8G以上的U盘。这个刻录的教程，百度一下就有很多。\n使用 刻录完成以后，你在开机\n","href":"/post/20190610204627/","title":"linux不需要重装系统就可以调整分区"},{"content":"","href":"/tags/%E5%85%AD%E7%BA%A7/","title":"六级"},{"content":"   词组 备注     this year 2017.12.第一套.长对话(1).第九句话   result in =resulting   One major 2017.12.第一套.长对话(1)    ","href":"/post/20190610155006/","title":"六级听力-连读词组"},{"content":"","href":"/tags/%E5%90%AC%E5%8A%9B/","title":"听力"},{"content":"   单词 备注     outreach         ","href":"/post/20190610125532/","title":"六级词汇—程度词"},{"content":"","href":"/tags/%E8%AF%8D%E6%B1%87/","title":"词汇"},{"content":"   单词 备注     poke     ","href":"/post/20190610125120/","title":"六级词汇—动作词"},{"content":"   单词 备注     indignant 愤慨的   impose 强加    ","href":"/post/20190610124839/","title":"六级词汇—消极词"},{"content":"","href":"/tags/%E6%B6%88%E6%9E%81/","title":"消极"},{"content":"柯林斯词典(collins)\n海词词典\n","href":"/post/20190609125337/","title":"可以查前后缀和形近词的词典"},{"content":"","href":"/tags/%E8%8B%B1%E8%AF%AD/","title":"英语"},{"content":"   单词a 单词b     indignity dignity        ","href":"/post/20190609112917/","title":"六级词汇—反义词"},{"content":"   公共部分 单词 备注     ability accountability, liability, availability Responsibility includes liability, blame, and accountability, that is a deep threat to the emotions. 责任包括赔偿责任，归咎、问责制，这是威胁到深有所感。   in incur, inflict,    de derail    re reclaim, retailer,    dis discrete(不), disclose,     ","href":"/post/20190608220718/","title":"六级词汇—前后缀"},{"content":"   单词 备注     offspring         ","href":"/post/20190608215625/","title":"六级词汇—集体名词"},{"content":"   单数 复数     criterion criteria    ","href":"/post/20190608161250/","title":"六级词汇—单复数"},{"content":"","href":"/tags/%E5%8D%95%E5%A4%8D%E6%95%B0/","title":"单复数"},{"content":" 词汇 quantity, quota,\n","href":"/post/20190608112053/","title":"六级词汇—衍生词"},{"content":"","href":"/tags/%E5%83%BB%E4%B9%89/","title":"僻义"},{"content":"   单词 僻义     treatment 待遇   presence 风度   clearance 结关    ","href":"/post/20190608105534/","title":"六级词汇—僻义词"},{"content":"   vt. vi. adj. adv. n. prep. 备注     ascertain         certain          certain,\ncertainty\n| |\naccustom | | custom | | custom | |\nexpend | | | | expenditure | |\n| | analytical | | analysis | |\nmagnify | magnify | | | magnitude | |\ndefine | | definitive | | | |\ndefy | | | |\ndefy,\ndefiance\n| |\nrestore | restore | | | restoration | |\nmature | mature | | | maturity | |\n| reside | residential | | | |\npopulate | | | | population | |\nexpect | | | | expectancy | |\nstimulate | | | |\nstimulus,\nstimulant\n| | stimulants表示兴奋剂;\npublicize | | public | | public | |\n| | timely | timely | time | |\nsucceed | succeed | successful | successfully |\nsuccess,\nsuccessor,\nsucceeder\n| |\noperate | operate |\noperative,\noperational\n| | operation | |\nreveal | | | | revelation | |\ndesign | design | designate | | design | |\ntransmit | | | |\ntransition,\ntransmit\n| | transition表示过渡、转变、变迁\naddict | | addictive | | | |\nclear | clear | clear | clear |\nclear,\nclearing,\nclearance\n| |\nmaster | | master | |\nmaster,\nmastery\n| |\n| | valid | validly | validity | |\n| | indignant | | indignity | |\n| | mid, middle | | midst | mid, midst |\nmid和middle的区别在于用法不同;\nmid一般用来与其它词组成合成词，如mid-term，midnight;\nmiddle作为中等的一般表示教育、学校，一般middle表示中间的，中央的;\nmidst书面语用词，指在一个群体的深处或在某活动的进程中。\nparalyze,\nparalyzing,\n| | | |\nparalyzer,\nparalysis,\nparalyzation\n| |\nparalyze=paralyzing,\n| | nominal | | | |\nnecessitate | | | | | |\n| | feasible | | feasibility | |\n| | | | legislation | |\n| expire | | | expiration | |\n","href":"/post/20190607211234/","title":"六级词汇—词性对比"},{"content":"","href":"/tags/%E8%AF%8D%E6%80%A7/","title":"词性"},{"content":"   词汇     populate, popular,   dread,dead,   loom,room，   foster,faster ,   skeptical,sceptical ,   rely,relay ,   revive,retrieve ,   shutter,shelter,    ","href":"/post/20190607205418/","title":"六级词汇—形近词"},{"content":"","href":"/tags/%E5%BD%A2%E8%BF%91/","title":"形近"},{"content":" 在区分近义词的时候，没有必要详细的记忆每个单词的具体含义，只要记住每个近义词之间的区别和共有的含义，就可以很轻松的使用。\n    近义词 备注     inhabit,populate, reside,dwell 居住于\nreside书面用词，指合法的永久性居住，也指在豪华的住宅里居住；\ninhabit强调人或动物居住在某个地区并已适应某种特殊环境；\npopulate强调有人居住，population的动词形式；\ndwell文学上的用词，口语中通常用live代替。   amplify,magnify 放大，\nmaglify可指用光学仪器使物体看上去显得变大；也指事实上把某物增大，有时用于夸张意味。\namplify: 在科技中常指声音的扩大或电磁波的增强。也指补充了细节、详述或扩大内容等。此词系正式用语   prevalent, popular popular指适应大众爱好、需要，为大家所公认或接受。   deteriorate,crumble    intricate,complex complex侧重内在关系的复杂，需通过仔细研究与了解才能掌握和运用。\nintricate着重指错综复杂，令人迷惑理解。   plea,appeal 请求   extinct,dead 无生命   additive,cumulative 附加的   female,feminine 女性的\nfemale侧重于性别雌性；\nfeminine侧重于阴性   skeptical,suspicious 怀疑的\nskeptical强调观点；\nsuspicious强调状态或外在的表现形式   timid,shy 害羞的\ntimid强调胆子小;   comply,obey comply指答应某人已经提出或可能要求做的某事，与with连用。   collide,conflict 冲突\ncollide多指带毁坏性的猛烈相撞，也可指严重的直接冲突。\nconflict这个词以前可表具体东西的撞击，现在常指冲突或对立。   surpass,transcend 超过\ntranscend强调超出经验、信念、描写能力等的范围;\nsurpass非…所能办到或理解   counterpart,    descendant,offspring 子孙、后代;\ndescendant一般为名词单数，前面加a;\noffspring是名词复数，是个群体;（集体名词）   verge,edge,fringe 边缘;\nedge普通用词，指较窄的边沿;\nverge指明显地标志一个表在或一广阔空间的边界，或终端线，也指极狭窄的空间。常用作比喻;\nfringe指地毯的须边、围巾的花边、烫发的卷边或人群的边缘;   mid,middle mid和middle的区别在于用法不同;\nmid一般用来与其它词组成合成词，如mid-term，midnight;\nmiddle作为中等的一般表示教育、学校，一般middle表示中间的，中央的;   certify,testify certify v.证明，声称是真的;\ntestify v. (在法庭上)宣誓作证；表明;   complex,intricate,involved,complicated, complex指组成某种机器的零件、构成某件事的因素或构成数学题的元素不仅很多,而且相互的关系或相互的作用也令人眼花缭乱,只有学识深的人或具有专门知识的人才能处理;\nintricate 通常指交织在一起的众多因素,而且很难理出头绪来;\ninvolved 通常指许多事物或事物的关系盘根错节;\ncomplicated 具有complex的一切意义,但更强调复杂得难以解释或理解.一道算式题可能非常\ncomplex,但未必确实complicated；而一道 complicated 算式一般总是 complex的;   denounce,condemn,blame,\naccuse,scold,reproach,rebuke demounce与condemn同义，但着重公开性;\ncondemn正式用词，表示谴责，有较强的司法意味，侧重从道义或原则上的谴责;\nblame普通用词，语气较弱，仅是一般的责难、归咎于，不含用语言责骂之意;\naccuse语气比blame强，本义为归罪，可用作指非难或谴责之义;\nscold普通用词，多指上级对下级、长辈对后辈或雇主对雇员的态度粗暴、言词激烈的数落;\nreproach侧重指因他人粗心、自私等引起不满而去指责、找岔;\nrebuke多指上级对下级进行的公开、强烈、严正而不宽容的责备。隐含一定权威的意味。    ","href":"/post/20190607204020/","title":"六级词汇—近义词"},{"content":"","href":"/tags/%E8%BF%91%E4%B9%89%E8%AF%8D/","title":"近义词"},{"content":"","href":"/tags/pdf/","title":"pdf"},{"content":" 用法： wkhtmltopdf http://google.com google.pdf 下载（deb）： wkhtmlpdf\n开源代码代码： wkhtmlpdf.git\n","href":"/post/20190607174103/","title":"wkhtmltopdf：一个 Linux 中将网页转成 PDF 的智能工具"},{"content":"","href":"/post/20190606141846/","title":"App can't be opened because it is from an unidentified developer"},{"content":"","href":"/tags/unidentified-developer/","title":"unidentified developer"},{"content":"字蛛是一个中文字体压缩器，让网页自由引入中文字体成为可能。\n","href":"/post/20190605214837/","title":"html中文字体压缩工具"},{"content":"  字体反爬，顾名思义就是利用自定义的字符编码与字体文件的映射呈现文字的一种反爬措施。下面我们通过例子来详细介绍字体反爬是怎么实现的以及解决方案。\n 目录\n字符编码\nCSS3 @font-face 规则\nhtml文件（example.html）:\nwoff字体文件（example.woff）:\nhtml显示效果：\n解决方案：\n字符编码 字体爬虫就是使用类似自定义的字符编码的形式来呈现文字，字符编码的详细信息见HTML字符编码；\nCSS3 @font-face 规则 在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。\n通过 CSS3，web 设计师可以使用他们喜欢的任意字体。\n当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。\n您“自己的”的字体是在 CSS3 @font-face 规则中定义的。\nhtml文件（example.html）: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;example\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; @font-face{ font-family: \u0026#34;example\u0026#34;; src:url(\u0026#34;./example.woff\u0026#34;) format(\u0026#39;woff\u0026#39;); } .review { font-family: \u0026#34;example\u0026#34;; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; 找了好久才 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe54b;\u0026lt;/svgmsti\u0026gt;到，问了 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe36d;\u0026lt;/svgmsti\u0026gt; \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xebb5;\u0026lt;/svgmsti\u0026gt;他 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xf3c6;\u0026lt;/svgmsti\u0026gt;己也不知 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xef46;\u0026lt;/svgmsti\u0026gt;看了点评 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xf75f;\u0026lt;/svgmsti\u0026gt; \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe8dd;\u0026lt;/svgmsti\u0026gt;电话才知 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xef46;\u0026lt;/svgmsti\u0026gt;，人挺多的上菜 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xee1a;\u0026lt;/svgmsti\u0026gt;慢 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe8dd;\u0026lt;/svgmsti\u0026gt;，凉菜都吃完 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe5bd;\u0026lt;/svgmsti\u0026gt;别的 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xeb5a;\u0026lt;/svgmsti\u0026gt;还没 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xf40e;\u0026lt;/svgmsti\u0026gt;来，凉 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xeb5a;\u0026lt;/svgmsti\u0026gt;很 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xe082;\u0026lt;/svgmsti\u0026gt;胃 \u0026lt;svgmsti class=\u0026#34;review\u0026#34;\u0026gt;\u0026amp;#xee1a;\u0026lt;/svgmsti\u0026gt;好吃的。 \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; woff字体文件（example.woff）: example.woff\nhtml显示效果： 解决方案： 把woff字体文件里的字符编码放在html里面，显示出来，然后把html转化为图片，使用ocr技术把图片转为文字。\n","href":"/post/20190605214530/","title":"反爬机制之字体反爬详解"},{"content":"","href":"/tags/%E5%AD%97%E4%BD%93%E5%8F%8D%E7%88%AC/","title":"字体反爬"},{"content":" \u0026amp;开头的表示命名实体；\u0026amp;#开头的表示十进制的字符编码；\u0026amp;#x开头的表示十六进制的字符编码；\n    特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码     Α \u0026amp;Alpha; \u0026amp;#913; Β \u0026amp;Beta; \u0026amp;#914; Γ \u0026amp;Gamma; \u0026amp;#915;   Δ \u0026amp;Delta; \u0026amp;#916; Ε \u0026amp;Epsilon; \u0026amp;#917; Ζ \u0026amp;Zeta; \u0026amp;#918;   Η \u0026amp;Eta; \u0026amp;#919; Θ \u0026amp;Theta; \u0026amp;#920; Ι \u0026amp;Iota; \u0026amp;#921;   Κ \u0026amp;Kappa; \u0026amp;#922; Λ \u0026amp;Lambda; \u0026amp;#923; Μ \u0026amp;Mu; \u0026amp;#924;   Ν \u0026amp;Nu; \u0026amp;#925; Ξ \u0026amp;Xi; \u0026amp;#926; Ο \u0026amp;Omicron; \u0026amp;#927;   Π \u0026amp;Pi; \u0026amp;#928; Ρ \u0026amp;Rho; \u0026amp;#929; Σ \u0026amp;Sigma; \u0026amp;#931;   Τ \u0026amp;Tau; \u0026amp;#932; Υ \u0026amp;Upsilon; \u0026amp;#933; Φ \u0026amp;Phi; \u0026amp;#934;   Χ \u0026amp;Chi; \u0026amp;#935; Ψ \u0026amp;Psi; \u0026amp;#936; Ω \u0026amp;Omega; \u0026amp;#937;   α \u0026amp;alpha; \u0026amp;#945; β \u0026amp;beta; \u0026amp;#946; γ \u0026amp;gamma; \u0026amp;#947;   δ \u0026amp;delta; \u0026amp;#948; ε \u0026amp;epsilon; \u0026amp;#949; ζ \u0026amp;zeta; \u0026amp;#950;   η \u0026amp;eta; \u0026amp;#951; θ \u0026amp;theta; \u0026amp;#952; ι \u0026amp;iota; \u0026amp;#953;   κ \u0026amp;kappa; \u0026amp;#954; λ \u0026amp;lambda; \u0026amp;#955; μ \u0026amp;mu; \u0026amp;#956;   ν \u0026amp;nu; \u0026amp;#957; ξ \u0026amp;xi; \u0026amp;#958; ο \u0026amp;omicron; \u0026amp;#959;   π \u0026amp;pi; \u0026amp;#960; ρ \u0026amp;rho; \u0026amp;#961; ς \u0026amp;sigmaf; \u0026amp;#962;   σ \u0026amp;sigma; \u0026amp;#963; τ \u0026amp;tau; \u0026amp;#964; υ \u0026amp;upsilon; \u0026amp;#965;   φ \u0026amp;phi; \u0026amp;#966; χ \u0026amp;chi; \u0026amp;#967; ψ \u0026amp;psi; \u0026amp;#968;   ω \u0026amp;omega; \u0026amp;#969; ϑ \u0026amp;thetasym; \u0026amp;#977; ϒ \u0026amp;upsih; \u0026amp;#978;   ϖ \u0026amp;piv; \u0026amp;#982; • \u0026amp;bull; \u0026amp;#8226; … \u0026amp;hellip; \u0026amp;#8230;   ′ \u0026amp;prime; \u0026amp;#8242; ″ \u0026amp;Prime; \u0026amp;#8243; ‾ \u0026amp;oline; \u0026amp;#8254;   ⁄ \u0026amp;frasl; \u0026amp;#8260; ℘ \u0026amp;weierp; \u0026amp;#8472; ℑ \u0026amp;image; \u0026amp;#8465;   ℜ \u0026amp;real; \u0026amp;#8476; ™ \u0026amp;trade; \u0026amp;#8482; ℵ \u0026amp;alefsym; \u0026amp;#8501;   ← \u0026amp;larr; \u0026amp;#8592; ↑ \u0026amp;uarr; \u0026amp;#8593; → \u0026amp;rarr; \u0026amp;#8594;   ↓ \u0026amp;darr; \u0026amp;#8595; ↔ \u0026amp;harr; \u0026amp;#8596; ↵ \u0026amp;crarr; \u0026amp;#8629;   ⇐ \u0026amp;lArr; \u0026amp;#8656; ⇑ \u0026amp;uArr; \u0026amp;#8657; ⇒ \u0026amp;rArr; \u0026amp;#8658;   ⇓ \u0026amp;dArr; \u0026amp;#8659; ⇔ \u0026amp;hArr; \u0026amp;#8660; ∀ \u0026amp;forall; \u0026amp;#8704;   ∂ \u0026amp;part; \u0026amp;#8706; ∃ \u0026amp;exist; \u0026amp;#8707; ∅ \u0026amp;empty; \u0026amp;#8709;   ∇ \u0026amp;nabla; \u0026amp;#8711; ∈ \u0026amp;isin; \u0026amp;#8712; ∉ \u0026amp;notin; \u0026amp;#8713;   ∋ \u0026amp;ni; \u0026amp;#8715; ∏ \u0026amp;prod; \u0026amp;#8719; ∑ \u0026amp;sum; \u0026amp;#8722;   − \u0026amp;minus; \u0026amp;#8722; ∗ \u0026amp;lowast; \u0026amp;#8727; √ \u0026amp;radic; \u0026amp;#8730;   ∝ \u0026amp;prop; \u0026amp;#8733; ∞ \u0026amp;infin; \u0026amp;#8734; ∠ \u0026amp;ang; \u0026amp;#8736;   ∧ \u0026amp;and; \u0026amp;#8869; ∨ \u0026amp;or; \u0026amp;#8870; ∩ \u0026amp;cap; \u0026amp;#8745;   ∪ \u0026amp;cup; \u0026amp;#8746; ∫ \u0026amp;int; \u0026amp;#8747; ∴ \u0026amp;there4; \u0026amp;#8756;   ∼ \u0026amp;sim; \u0026amp;#8764; ≅ \u0026amp;cong; \u0026amp;#8773; ≈ \u0026amp;asymp; \u0026amp;#8773;   ≠ \u0026amp;ne; \u0026amp;#8800; ≡ \u0026amp;equiv; \u0026amp;#8801; ≤ \u0026amp;le; \u0026amp;#8804;   ≥ \u0026amp;ge; \u0026amp;#8805; ⊂ \u0026amp;sub; \u0026amp;#8834; ⊃ \u0026amp;sup; \u0026amp;#8835;   ⊄ \u0026amp;nsub; \u0026amp;#8836; ⊆ \u0026amp;sube; \u0026amp;#8838; ⊇ \u0026amp;supe; \u0026amp;#8839;   ⊕ \u0026amp;oplus; \u0026amp;#8853; ⊗ \u0026amp;otimes; \u0026amp;#8855; ⊥ \u0026amp;perp; \u0026amp;#8869;   ⋅ \u0026amp;sdot; \u0026amp;#8901; ⌈ \u0026amp;lceil; \u0026amp;#8968; ⌉ \u0026amp;rceil; \u0026amp;#8969;   ⌊ \u0026amp;lfloor; \u0026amp;#8970; ⌋ \u0026amp;rfloor; \u0026amp;#8971; ◊ \u0026amp;loz; \u0026amp;#9674;   ♠ \u0026amp;spades; \u0026amp;#9824; ♣ \u0026amp;clubs; \u0026amp;#9827; ♥ \u0026amp;hearts; \u0026amp;#9829;   ♦ \u0026amp;diams; \u0026amp;#9830;  \u0026amp;nbsp; \u0026amp;#160; ¡ \u0026amp;iexcl; \u0026amp;#161;   ¢ \u0026amp;cent; \u0026amp;#162; £ \u0026amp;pound; \u0026amp;#163; ¤ \u0026amp;curren; \u0026amp;#164;   ¥ \u0026amp;yen; \u0026amp;#165; ¦ \u0026amp;brvbar; \u0026amp;#166; § \u0026amp;sect; \u0026amp;#167;   ¨ \u0026amp;uml; \u0026amp;#168; © \u0026amp;copy; \u0026amp;#169; ª \u0026amp;ordf; \u0026amp;#170;   « \u0026amp;laquo; \u0026amp;#171; ¬ \u0026amp;not; \u0026amp;#172; ­ \u0026amp;shy; \u0026amp;#173;   ® \u0026amp;reg; \u0026amp;#174; ¯ \u0026amp;macr; \u0026amp;#175; ° \u0026amp;deg; \u0026amp;#176;   ± \u0026amp;plusmn; \u0026amp;#177; ² \u0026amp;sup2; \u0026amp;#178; ³ \u0026amp;sup3; \u0026amp;#179;   ´ \u0026amp;acute; \u0026amp;#180; µ \u0026amp;micro; \u0026amp;#181; \u0026ldquo; \u0026amp;quot; \u0026amp;#34;   \u0026lt; \u0026amp;lt; \u0026amp;#60; \u0026gt; \u0026amp;gt; \u0026amp;#62; \u0026lsquo;  \u0026amp;#39;    ","href":"/post/20190605212304/","title":"HTML特殊字符编码对照表"},{"content":"","href":"/tags/%E5%8F%8D%E7%88%AC/","title":"反爬"},{"content":"","href":"/tags/%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/","title":"大众点评"},{"content":"  目前大众点评主要有两种反爬的机制：css反爬和字体反爬。\n css反爬的解决方案 具体详见反爬机制之css反爬详解\n字体反爬的解决方案 ","href":"/post/20190605165530/","title":"大众点评评论反爬解决方案"},{"content":"","href":"/tags/%E8%AF%84%E8%AE%BA/","title":"评论"},{"content":"","href":"/tags/css%E5%8F%8D%E7%88%AC/","title":"css反爬"},{"content":"  css反爬，顾名思义就是利用css样式移动背景图片达到呈现文字效果的一种反爬措施。下面我们通过例子来详细介绍css反爬是怎么实现的以及解决方法。\n 目录\nhtml代码（example.html）:\ncss文件（example.css）：\nsvg文件（example.svg）：\nhtml显示效果：\n规律总结：\n解决方案实现代码（python）：\n最终效果：\nhtml代码（example.html）: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;example\u0026lt;/title\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./example.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; 之前 \u0026lt;svgmsti class=\u0026#34;cmpubq\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;杭州，回 \u0026lt;svgmsti class=\u0026#34;cmpmdy\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;海前选择 \u0026lt;svgmsti class=\u0026#34;cmpcj2\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt; \u0026lt;svgmsti class=\u0026#34;cmpfaa\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;这里吃一顿，原 \u0026lt;svgmsti class=\u0026#34;cmpu0e\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt; \u0026lt;svgmsti class=\u0026#34;cmpug6\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;想吃 \u0026lt;svgmsti class=\u0026#34;cmpu6y\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt; \u0026lt;svgmsti class=\u0026#34;cmppiv\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;家 \u0026lt;svgmsti class=\u0026#34;cmp3wu\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;，无意间发现 \u0026lt;svgmsti class=\u0026#34;cmpcj2\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;这家 \u0026lt;svgmsti class=\u0026#34;cmpj8o\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;，所以决 \u0026lt;svgmsti class=\u0026#34;cmpq7h\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;要 \u0026lt;svgmsti class=\u0026#34;cmpfaa\u0026#34;\u0026gt;\u0026lt;/svgmsti\u0026gt;打卡！ \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; css文件（example.css）： svgmsti[class^=\u0026#34;cmp\u0026#34;]{ width: 14px; height: 30px; margin-top: -9px; background-image: url(./example.svg); background-repeat: no-repeat; display: inline-block; vertical-align: middle; } .cmpfaa{background:-574.0px -184.0px;} .cmppiv{background:-154.0px -560.0px;} .cmpug6{background:-350.0px -631.0px;} .cmpu0e{background:-140.0px -714.0px;} .cmpq7h{background:-154.0px -1197.0px;} .cmpu6y{background:-196.0px -1241.0px;} .cmp3wu{background:-238.0px -1582.0px;} .cmpj8o{background:-182.0px -1673.0px;} .cmpcj2{background:-70.0px -1872.0px;} .cmpmdy{background:-532.0px -1917.0px;} .cmpubq{background:-210.0px -2004.0px;} svg文件（example.svg）： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE svg PUBLIC \u0026#34;-//W3C//DTD SVG 1.1//EN\u0026#34; \u0026#34;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; width=\u0026#34;650px\u0026#34; height=\u0026#34;3030.0px\u0026#34;\u0026gt; \u0026lt;style\u0026gt;text {font-family:PingFangSC-Regular,Microsoft YaHei,\u0026#39;Hiragino Sans GB\u0026#39;,Helvetica;font-size:14px;fill:#282828;}\u0026lt;/style\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;207\u0026#34;\u0026gt;各发唐血幅列俭甘风裁渠犬奏另太分剪累淹介厅鼠义赔靠网有周抄梦姿脱忘销耗娱嗓财拍帆伶来\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;583\u0026#34;\u0026gt;谋浊军猾绳脸眼泪原芒点婆躺斜恭绍正可冤冈莲堵潜杂冒辅宋今制谷橘清渴姨狠缓圣挤姑昏捐爷\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;654\u0026#34;\u0026gt;锐寸成片较劫壤位此念哄蚂贝驾旦苗拣窃走吩吵扔颠量礼是僚丧蝶税滥达弓名以再尽羽拼伐婚经\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;737\u0026#34;\u0026gt;健袍汁禁柏脚妈记间诞本涨肢练横董府晒绩傅规绸岁链申饮肉箭预矛围震纲括沃富井般赞阁系得\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1220\u0026#34;\u0026gt;航携摊手午堂糠辈肯候漆定锄荷爪梳君拾枕犹山害答族你榜呼递雹剂搜蜻碍材行霞挑犯休亮渐广\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1264\u0026#34;\u0026gt;市摆滚农慢歇雁宽膨潮粒坑顶阳外建串删扛刊败妖例荣件牺饿赏邪崇救绪断到崖慰就收忆厌瞧假\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1605\u0026#34;\u0026gt;爸狸抗植嫌撕烘按尤橡趴遗尚馅蚁禽援的豆缴参垒索神嘉香浪维乐吸兽叨枯肾勒帮瓜止凭弃叹坦\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1696\u0026#34;\u0026gt;炕篮甚咱蛙争觉锅碧字虑弄驳店肠续梯抵颂买乱棕匙楼耐溜容脂返晴鸣赛足胀向迎恐狭截凤俊着\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1895\u0026#34;\u0026gt;淋欣近毕估了染闻御滤螺时尖填八狐西升劈只沸纹炸茫雪摘寄佳丢孟荒佩穿画霉火宾教键萄捡临\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;1940\u0026#34;\u0026gt;课奴快相刮煤淘少肥蛛互盆杀货眉边两认换阀供蓬嫂殖命状兔生投涉盘祥朽变搏悠黑兴上询栏则\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;2027\u0026#34;\u0026gt;那易刷旷差届敞扰皇撑冲家峰结老去旱扮娃且滩刑车客粮守灯江罪附艳乙芝跪常限员革趁又惯赖\u0026lt;/text\u0026gt; \u0026lt;/svg\u0026gt; html显示效果：  上面的这段文字，无法通过js脚本直接获取，因为部分文字是以图片的形式呈现的。为此， 我们需要知道这这些文字的映射规则。\n 规律总结： 我们发现“之前去杭州”中的“去”，根据html文件它对应的class为“cmpubq”，然后这个class对应的x=210, y=2004（取绝对值）, “去”这个字在svg的最后一行文字中。并且svg文件中对应的y=2027, 刚好是所有y值里面最接近2004且大于2004的y, 然后我们发现210整除14刚好是去所对应的下标。我么依次比对“回，了”等字的特点，我们可以得到如下规律。这里为了简化表达方式，我把svgmsti所对应的y值指定为y_svgmsti，然后把svg文件里面的y值称为y_svg。\n我们可以把规律总结为：y_svgmstiv与y_svg存在一种关系，即只要y_svg刚好大于y_svgmsti的值时，svgmsti标签对应的文字就在y_svg对应的一行文字中，并且向右平移[x_svgmsti/14]个单位就是标签所对应的文字。\n解决方案实现代码（python）： # -*- coding: utf-8 -*- from pyquery import PyQuery as pq import re from lxml.html import HtmlElement # 从文件读入html代码 with open(\u0026#34;./example.html\u0026#34;, \u0026#34;r\u0026#34;) as f1, open(\u0026#34;./example.css\u0026#34;, \u0026#34;r\u0026#34;) as f2, open(\u0026#34;./example.svg\u0026#34;, \u0026#34;r\u0026#34;) as f3: html, css, svg = f1.read(), f2.read(), f3.read().encode(\u0026#34;utf-8\u0026#34;) # 生成css字典 css_dict = {name: (float(x), float(y)) for name, x, y in re.findall(\u0026#34;\\.([\\da-z]{6}){background:-([\\.\\d]+)px -([\\.\\d]+)px;}\u0026#34;, css)} # 生成svg字典 y_text_dict = {int(i.attr(\u0026#34;y\u0026#34;)): i.text() for i in pq(svg, parser=\u0026#39;html\u0026#39;).items(\u0026#34;text\u0026#34;)} y_list_sort = list(y_text_dict.keys()) y_list_sort.sort() # 升序排列 # 生成文本 content = \u0026#34;\u0026#34; for node in pq(html)(\u0026#34;p\u0026#34;).contents(): if isinstance(node, HtmlElement): x, y = css_dict[pq(node).attr(\u0026#34;class\u0026#34;)] content += y_text_dict[[yi for yi in y_list_sort if y \u0026lt; yi][0]][int(x//14)] else: content += str(node).strip() print(content) 最终效果：  之前去杭州，回上海前选择了来这里吃一顿，原本是想吃外婆家的，无意间发现了这家店，所以决定要来打卡！   ","href":"/post/20190605165242/","title":"反爬机制之css反爬详解"},{"content":"","href":"/tags/python/","title":"python"},{"content":"with open(\u0026#34;./example.html\u0026#34;, \u0026#34;r\u0026#34;) as f1, open(\u0026#34;./example.css\u0026#34;, \u0026#34;r\u0026#34;) as f2, open(\u0026#34;./example.svg\u0026#34;, \u0026#34;r\u0026#34;) as f3: html = f1.read() css = f2.read() svg = f3.read()","href":"/post/20190605154442/","title":"python with 打开多个文件"},{"content":"","href":"/tags/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/","title":"打开文件"},{"content":"","href":"/tags/pyquery/","title":"pyquery"},{"content":"from pyquery import PyQuery as pq p = pq(字符串) for i in p.contents(): print(i)","href":"/post/20190605114530/","title":"pyquery获取文本节点（TextNode）"},{"content":"\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;","href":"/post/20190605101458/","title":"html解决中文乱码"},{"content":"# -*- coding: utf-8 -*- from pyquery import PyQuery as pq with open(\u0026#39;文件路径\u0026#39;, \u0026#34;r\u0026#34;) as f: str = f.read().encode(\u0026#34;utf-8\u0026#34;) #设置\u0026#34;utf-8\u0026#34;编码，这一步很重要 p = pq(str)","href":"/post/20190604142642/","title":"pyquery如何读取xml或html文件不乱码"},{"content":"","href":"/tags/xml/","title":"xml"},{"content":"之前遇到pyquery解析svg文件(xml格式)的时候发现无法获取节点，比如下面这个svg文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE svg PUBLIC \u0026#34;-//W3C//DTD SVG 1.1//EN\u0026#34; \u0026#34;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; width=\u0026#34;650px\u0026#34; height=\u0026#34;3030.0px\u0026#34;\u0026gt; \u0026lt;style\u0026gt;text {font-family:PingFangSC-Regular,Microsoft YaHei,\u0026#39;Hiragino Sans GB\u0026#39;,Helvetica;font-size:14px;fill:#282828;}\u0026lt;/style\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;35\u0026#34;\u0026gt;呜愉伸治译喊傲著逢循托从巨毒高翼阻聋巴垂级茧郎暑聚渣啦秘炊奋睁连撤宁畅搁刚轮蜂缺幕葵\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;0\u0026#34; y=\u0026#34;79\u0026#34;\u0026gt;搞陆林卵窝提格桑南隔选膛奸修担穴罐胖宅圆馒杏至鲁类痒宝拌让必油匀困双拢砖轧凑辜亦银牧\u0026lt;/text\u0026gt; \u0026lt;/svg\u0026gt; 我在用下面的python代码提取text节点的时候，发现无法提取，没有任何输出：\nfrom pyquery import PyQuery as pq with open(文件路径, \u0026#34;r\u0026#34;) as f: svg = f.read().encode(\u0026#34;utf-8\u0026#34;) p = pq(svg) for i in p(\u0026#34;text\u0026#34;).items(): print(i) 之后，我把pyquery的解析方式，强制设置为 paser=\u0026quot;html\u0026quot; 后，就行了：\nfrom pyquery import PyQuery as pq with open(文件路径, \u0026#34;r\u0026#34;) as f: svg = f.read().encode(\u0026#34;utf-8\u0026#34;) p = pq(svg, parser=\u0026#34;html\u0026#34;) for i in p(\u0026#34;text\u0026#34;).items(): print(i)","href":"/post/20190604140727/","title":"pyquery如何解析xml"},{"content":"","href":"/tags/%E5%86%92%E6%B3%A1/","title":"冒泡"},{"content":" 冒泡排序 算法流程 假设存在一个长度为N的数组，按照从左至右的顺序升序排列。首先，通过N-1次数\njavascript代码 function bubbleSort(){ var arr = arguments[0]; for(var end=arr.length-1; end\u0026gt;0; end--){ for(var i=0; i\u0026lt;end; i++){ if(arr[i] \u0026gt; arr[end]){ var tmp = arr[i]; arr[i] = arr[end]; arr[end] = tmp; } } } } function randomNum(max=100, start=33){ return Math.floor(Math.random() * max + start); } var arr = []; var length = randomNum(30, 1); for(var i=0; i\u0026lt;length; i++){ // 创建随机数组  arr.push(randomNum()); } console.log(arr); bubbleSort(arr); console.log(arr);  选择排序 ","href":"/post/20190603215721/","title":"冒泡排序、选择排序和插入排序的比较"},{"content":"","href":"/tags/%E6%8E%92%E5%BA%8F/","title":"排序"},{"content":"","href":"/tags/%E6%8F%92%E5%85%A5/","title":"插入"},{"content":"","href":"/categories/%E7%AE%97%E6%B3%95/","title":"算法"},{"content":"   标记 作用 备注     文字 字体加粗    连续两个空格 换行    连续两个回车 或 在空行处输出连续两个\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 空行    \u0026amp;nbsp; 它叫不换行空格，全称是 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了\u0026amp;nbsp;，它是按下space键产生的空格。 在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。   \u0026amp;ensp; 它叫“半角空格”，全称是 En Space ，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。 此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。   \u0026amp;emsp; 它叫“全角空格”，全称是 Em Space ，em是字体排印学的计量单位，相当于当前指定的点数。例如，1em在16px的字体中就是16px。 此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。   \u0026amp;thinsp; 它叫“窄空格”，全称是 Thin Space    。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。     \u0026amp;zwnj; 它叫零宽不连字，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。 Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为：“‌”   ![文字](图片地址) 插入图片    [文字](url) 超链接    + - 形成目录展开    \\Uparrow 向上的箭头 \\(\\Uparrow\\)    \\uparrow 向上的箭头 \\(\\uparrow\\)    \\geq 大于等于\\(\\geq\\)    \\leq 小于等于\\(\\leq\\)     持续更新\u0026hellip;\u0026hellip;\n","href":"/post/20190603143536/","title":"markdown常用语法大全"},{"content":"","href":"/tags/%E8%AF%AD%E6%B3%95/","title":"语法"},{"content":"","href":"/tags/numpy/","title":"numpy"},{"content":"# -*- coding: utf-8 -*- import numpy as np def softmax(x): x_row_max = x.max(axis=-1) x_row_max = x_row_max.reshape(list(x.shape)[:-1]+[1]) x = x - x_row_max x_exp = np.exp(x) x_exp_row_sum = x_exp.sum(axis=-1).reshape(list(x.shape)[:-1]+[1]) softmax = x_exp / x_exp_row_sum return softmax if __name__ == \u0026#34;__main__\u0026#34;: m = np.random.randn(2, 2, 2) + 2 m = softmax(m) m = m.sum(axis=-2)","href":"/post/20190602184249/","title":"numpy softmax实现"},{"content":"","href":"/tags/softmax/","title":"softmax"},{"content":"","href":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","title":"机器学习"},{"content":"","href":"/tags/f1/","title":"F1"},{"content":"","href":"/tags/%E5%87%86%E7%A1%AE%E7%8E%87/","title":"准确率"},{"content":"    专业术语的中英文对照表 英文名     准确率 Accuracy   精准率 Precise   召回率 Recall   F1值 F1 measure    Precise和Recall是广泛应用在信息检索和统计学分类领域的两个度量值，用来评价结果的质量；F1 measure是综合Precise和Recall两个指标的评估指标，用于综合反映整体的指标。Precise、Recall和F1 measure都是通过混淆矩阵计算出来的，下表是对混淆矩阵的介绍：\n混淆矩阵 \u0026nbsp; 预测的类别 \u0026nbsp; 实际的类别 \u0026nbsp; Positive Negative 合计 Positive TP FN 正样本 Negative FP TN 负样本 \u0026nbsp; 合计 样本被预测为Positive 样本被预测为Negative Positive+Negative   其中： TP表示正确地把正样本预测为正； FN表示错误地把正样本预测为负； FP表示错误地把负样本预测为正； TN表示正确地把负样本预测为负；\n Precise 表示正确预测正样本占实际预测为正样本的比例\n$$Precise = \\frac{TP}{TP+FP}$$\nRecall 表示正确预测正样本占正样本的比例\n$$Recall = \\frac{TP}{TP+FN}$$\nF1 measure $$F1 = \\frac{2}{\\frac{1}{Precise}+\\frac{1}{Recall}} = 2 \\cdot \\frac{Precise \\cdot Recall}{Precise + Recall}$$\nAccuracy 表示预测符合标签的样本与总样本的比例\n$$Accuracy = \\frac{TP + TN}{TP + TN + FP + FN}$$\n","href":"/post/20190602173707/","title":"准确率、精准率、召回率和F1值详解"},{"content":"","href":"/tags/%E5%8F%AC%E5%9B%9E%E7%8E%87/","title":"召回率"},{"content":"","href":"/tags/%E7%B2%BE%E5%87%86%E7%8E%87/","title":"精准率"},{"content":"","href":"/tags/frps/","title":"frps"},{"content":"穿透工具：frps\n进程管理工具：supervisor\n","href":"/post/20190602141130/","title":"linux实现内网穿透"},{"content":"","href":"/tags/supervisor/","title":"supervisor"},{"content":"","href":"/tags/find/","title":"find"},{"content":" nohup 结合后台运行命令\u0026amp;使用 nohup command \u0026gt;\u0026gt; log_path 2\u0026gt;\u0026amp;1 \u0026amp; lsof 查看端口运行的程序 lsof -i :port find 查找文件(以nginx为例) sudo find / -name nginx* tar 打包文件 tar -cvf 文件名.tar 要打包的目录","href":"/post/20190602135144/","title":"linux常用命令"},{"content":"","href":"/tags/lsof/","title":"lsof"},{"content":"","href":"/tags/nohup/","title":"nohup"},{"content":"","href":"/tags/tar/","title":"tar"},{"content":"","href":"/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"常用命令"},{"content":" 触发某个事件时会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。\n 事件的元素 事件的类型 其它与事件相关的信息  所有浏览器都支持event对象，但存在差异。\nevent对象在标准的现代浏览器中会作为参数传入到事件的事件处理函数。\nDOM中的事件对象 属性/方法 类型 读写 说明 bubbles Boolean 只读 表明事件是否支持冒泡 cancelable Boolean 只读 表明是否可以取消默认行为 currentTarget Element 只读 表明事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为true表示已经调用了下面的preventDefault() detail Int 只读 与事件相关的细节信息 eventPhase Int 只读 触发事件处理程序的阶段：1表示捕获，2表示处于目标，3表示冒泡 preventDefault() Function —— 取消事件的默认行为，前提条件是cancelable属性为true stopImmediatePropagation() Function —— 取消事件的进一步捕获或冒泡，同时阻止任何（其他的）事件处理程序被调用 stopPropagation() Function —— 立即停止事件在DOM中的传播，取消进一步的时间捕获或冒泡，前提条件是：bubbles属性为true target Element 只读 事件的目标元素 trusted Boolean 只读 为true表示是浏览器生成的，为false表示是开发人员自定义的事件 type String 只读 被触发的事件类型 view AbstractView 只读 与事件相关的抽象视图，等于发生事件的window对象   在HTML事件处理程序时：变量event（固定）中保存着event对象，无需主动声明，也无需以参数形式传入：\n 在DOM 0 级和DOM 2 级事件处理程序中，event对象会 以参数的形式传入事件处理函数 中；\n event对象的基本属性和方法见上面的表格，各个不同类型的事件扩展的属性和方法各不相同；\n 在事件处理程序内部，对象this的值始终等于currentTarget的值；\n  target属性是（同心圆）靶心，this和currentTarget是你击中的最大点数环（同心圆）；\n target是事件在DOM同心圆蔓延的终点；\n stopPropagation()用法实例：\n  var btn = document.getElementById(\u0026#39;myBtn\u0026#39;); btn.onclick = function(event){ alert(\u0026#39;clicked!\u0026#39;); event.stopPropagation(); } document.body.onclick = function(event){ alert(\u0026#39;body clicked\u0026#39;); }   只有在eventPhase为2（目标阶段时）this=currentTarget和target才相等；\n 只有在事件处理程序执行期间，event对象才存在，一旦事件处理程序执行完毕，event对象就会被销毁。\n  IE中的事件对象    属性/方法 类型 读/写 说明     cancelBubble Boolean 读/写 表示是否（默认否）取消事件冒泡（类似DOM中的stopPropagation()方法）   returnValue Boolean 读/写 设为false表示取消事件的默认行为（类似DOM中的preventDefault）   srcElement Element 只读 事件的目标元素（类似DOM中的target属性）   type String 只读 被触发的事件类型     IE中访问event对象的方式与现代浏览器DOM中访问event对象的方式不同； IE下的DOM 0 级事件：event对象作为window对象的一个属性存在，而不用将event作为处理函数的参数传入:  var btn = getElement(\u0026#39;#myBtn\u0026#39;); btn.onclick = function(){ var event = window.event; alert(event.type); // \u0026#39;click\u0026#39; }   HTML特性指定事件处理程序时，在处理函数中直接通过一个event变量访问event对象； attachEvent()指定事件处理程序时，访问event对象有两种方法：  event对象作为window对象的属性被访问；\nevent对象作为参数传入事件处理函数\n 低版本IE不支持事件捕获，只支持事件冒泡；使用cancelBubble = true可以阻止事件继续冒泡：  var btn = document.getElementById(\u0026#39;myBtn\u0026#39;); btn.onclick = function(event){ alert(\u0026#39;clicked\u0026#39;); window.event.cancelBubble = true; } document.body.onclick = function(event){ alert(\u0026#39;body clicked\u0026#39;); } // DOM 0 级事件是冒泡阶段触发，所以此例中body上的绑定事件无法有btn上的click冒泡触发  跨浏览器的事件对象 var eventUtil = { addEventHandler: function(element, type, handler) { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + type, handler); } else { element[\u0026#39;on\u0026#39; + type] = handler; } }, getEvent: function(event) { return event ? event : window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, preventDefault: function(event) { if (event.preventDefault) { event.preventDefault; } else { event.returnValue = false; } }, stopPropagation: function(event) { if (event.stopPropagation) { event.stopPropagation; } else { event.cancelBubble = true; } }, removeEventHandler: function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(\u0026#39;on\u0026#39; + type, handler); } else { element[\u0026#39;on\u0026#39; + type] = null; } } };   由于IE不支持事件捕获，因此以上浏览器的事件对象中的preventDefault()只能阻止事件冒泡！\n ","href":"/post/20190601142818/","title":"JavaScript-事件对象"},{"content":" 应对各个厂商、各个版本的浏览器对特性支持度的差异，常采取的策略\n ”最小公分母“策略 客户端检测技术，突破和规避种种局限  不到万不得已不要使用客户端检测；先设计最通用的方案，然后使用特定于浏览器的技术增强该方案。\n常用的客户端检测技术包括：\n能力检测  最常用最方便，只关注能力，不关注浏览器品牌和版本； 两个原则  先检测达成目的的最常用特性，避免测试多个条件\n必须测试实际用到的特性，一个特性存在不一定代表另一个特性也存在\n 在可能的情况下，尽量使用typeof进行能力检测； 低版本IE下或其他非标准浏览器下，使用typeof检测的值不一定符合标准；  低版本IE的DOM以COM的形式实现，很容易出现typeof检测结果不标准的情况\n 通过检测对象是否有某些原生属性时，要注意我们的代码是否定义了与要检测到的原生属性同名的属性，确保检测的目标是正确的； 一般通用方法：isHostMethod函数  function isHostMethod(object, property){ var t = typeof object[property]; return t == \u0026#39;function\u0026#39; || (!!(t == \u0026#39;object\u0026#39; \u0026amp;\u0026amp; object[property])) || t == \u0026#39;unknown\u0026#39;; } result = isHostMethod(document, \u0026#39;getElementById\u0026#39;);   根据浏览器不同将能力组合起来是更可取的方法； 如果你预先知道自己的程序需要使用某些特定的浏览器特性，那么最好一次性检测所有相关特性。  怪癖检测  目的是识别浏览器的特殊行为，与能级检测的检测能力刚好相反；\n 怪癖是个别浏览器独有的，通常归类为bug；\n 实例：IE8及更早版本中，如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么属性无法被for-in循环遍历\n  // 怪癖检测 var hasDontEnumQuirk = function(){ var o = {toString: function(){}}; for(var prop in o){ if(prop == \u0026#39;toString\u0026#39;){ return false; } } return true; }(); hasDontEnumQuirk;// false 说明浏览器没有这个怪癖  用户代理检测  通过检测用户代理字符串来确定实际使用的浏览器； 通常是在最后才选择这样的方法，或者想实现某些特定的功能才使用用户代理检测； 主要使用navigator.useragent 、navigator.platform和一些浏览器的特征对象来检测； 检测主要内容是：呈现引擎信息（engine)、浏览器信息、平台、设备、操作系统； 各个浏览器的用户代理字符串因为历史的原因十分复杂与怪异，具体见P222; 代码：  var client = function () { // 呈现引擎与版本  var engine = { ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 呈现引擎版本号  ver: null }; // 浏览器  var browser = { // 主要浏览器  ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 浏览器版本号  ver: null }; // 平台、设备和操作系统  var system = { win: false, max: false, x11: false, // 移动设备  iphone: false, ipod: false, ipad: false, android: false, nokiaN: false, winMobile: false, // 游戏系统  wii: false, ps: false }; // 检测呈现引擎和浏览器  var ua = navigator.userAgent; if (window.opera) { engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); } else if (/AppleWebKit\\/(\\S+)/.test(ua)) { engine.ver = RegExp[\u0026#39;$1\u0026#39;]; engine.webkit = parseFloat(engine.ver); // 确定是 Chrome 还是 Safari 还是 Edge  if (/Edge\\/(\\S+)/.test(ua)) { engine.ver = browser.ver = \u0026#39;Edge\u0026#39;; engine.ie = browser.ie = \u0026#39;Edge\u0026#39;; } else if (/Chrome\\/(\\S+)/.test(ua)) { browser.ver = RegExp[\u0026#39;$1\u0026#39;]; browser.chrome = parseFloat(browser.ver); } else if (/Version\\/(\\S+)/.test(ua)) { browser.ver = RegExp[\u0026#39;$1\u0026#39;]; browser.safari = parseFloat(browser.ver); } else { // 近似地确定版本号  var safariVersion = 1; if (engine.webkit \u0026lt; 100) { safariVersion = 1; } else if (engine.webkit \u0026lt; 312) { safariVersion = 1.2; } else if (engine.webkit \u0026lt; 412) { safariVersion = 1.3; } else { safariVersion = 2; } browser.safari = browser.ver.safariVersion; } } else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/(\\S+)/.test(ua)) { engine.ver = browser.ver = RegExp[\u0026#39;$1\u0026#39;]; engine.khtml = browser.konq = parseFloat(engine.ver); } else if (/rv:(\\S+)+\\) Gecko\\/\\d{8}/.test(ua)) { engine.ver = RegExp[\u0026#39;$1\u0026#39;]; engine.gecko = parseFloat(engine.ver); // 确定是不是 Firefox  if (/Firefox\\/(\\S+)/.test(ua)) { browser.ver = RegExp[\u0026#39;$1\u0026#39;]; browser.firefox = parseFloat(engine.ver); } } else if (/MSIE ([^;]+)/.test(ua)) { engine.ver = browser.ver = RegExp[\u0026#39;$1\u0026#39;]; engine.ie = browser.ie = parseFloat(engine.ver); } else if (/rv:(\\S+)+\\) like Gecko/) { engine.ver = browser.ver = RegExp[\u0026#39;$1\u0026#39;]; engine.ie = browser.ie = parseFloat(engine.ver); } // 检测浏览器  browser.ie = engine.ie; browser.opera = engine.opera; // 检测平台  var p = navigator.platform; system.win = p.indexOf(\u0026#39;Win\u0026#39;) == 0; system.mac = p.indexOf(\u0026#39;Mac\u0026#39;) == 0; system.x11 = (p == \u0026#39;X11\u0026#39;) || (p.indexOf(\u0026#39;Linux\u0026#39;) == 0); // 检测 windows 操作系统  if (system.win) { if (/Win(?:dows )?([^do]{2})\\s?(\\d+\\.\\d+)?/.test(ua)) { if (RegExp[\u0026#39;$1\u0026#39;] == \u0026#39;NT\u0026#39;) { switch (RegExp[\u0026#39;$2\u0026#39;]) { case \u0026#39;5.0\u0026#39;: system.win = \u0026#39;2000\u0026#39;; break; case \u0026#39;5.1\u0026#39;: system.win = \u0026#39;XP\u0026#39;; break; case \u0026#39;6.0\u0026#39;: system.win = \u0026#39;Vista\u0026#39;; break; case \u0026#39;6.1\u0026#39;: system.win = \u0026#39;7\u0026#39;; break; case \u0026#39;6.2\u0026#39;: system.win = \u0026#39;8\u0026#39;; break; case \u0026#39;10.0\u0026#39;: system.win = \u0026#39;10\u0026#39; break; default: system.win = \u0026#39;NT\u0026#39;; break; } } else if (RegExp[\u0026#39;$1\u0026#39;] == \u0026#39;9x\u0026#39;) { system.win = \u0026#39;ME\u0026#39;; } else { system.win = RegExp[\u0026#39;$1\u0026#39;]; } } } // 移动设备  system.iphone = ua.indexOf(\u0026#39;iPhone\u0026#39;) \u0026gt; -1; system.ipad = ua.indexOf(\u0026#39;iPad\u0026#39;) \u0026gt; -1; system.ipod = ua.indexOf(\u0026#39;iPod\u0026#39;) \u0026gt; -1; system.nokiaN = ua.indexOf(\u0026#39;NokiaN\u0026#39;) \u0026gt; -1; // windows mobile  if (system.win == \u0026#39;CE\u0026#39;) { system.winMobile = system.win; } else if (system.win == \u0026#39;Ph\u0026#39;) { if (/Windows Phone OS (\\d+.\\d+)/.test(ua)) { system.win = \u0026#39;Phone\u0026#39;; system.winMobile = parseFloat(RegExp[\u0026#39;$1\u0026#39;]); } } // 检测 iOS 版本  if (system.mac \u0026amp;\u0026amp; ua.indexOf(\u0026#39;Mobile\u0026#39;) \u0026gt; -1) { if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua)) { system.ios = parseFloat(RegExp.$1.replace(\u0026#39;_\u0026#39;, \u0026#39;.\u0026#39;)); } else { system.ios = 2; // 猜测检测  } } // 检测安卓版本  if (/Android (\\d+\\.\\d+)/.test(ua)) { system.android = parseFloat(RegExp.$1); } // 游戏系统  system.wii = ua.indexOf(\u0026#39;Wii\u0026#39;) \u0026gt; -1; system.ps = /playstation/i.test(ua); // 返回这些对象  return { engine: engine, browser: browser, system: system }; }(); ","href":"/post/20190601105750/","title":"JavaScript客户端检测"},{"content":"","href":"/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/","title":"客户端检测"},{"content":"  响应某个事件的函数叫做 事件处理程序 （或 事件侦听器 ），例如：click 事件的处理程序就是 onclick\n HTML事件处理程序  某个元素支持的所有事件都可以使用一个与相应事件处理程序同名的HTML特性来指定；  \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click me\u0026#34; onclick=\u0026#34;alert(\u0026#39;Clicked\u0026#39;)\u0026#34; /\u0026gt;  在这个特性里，不能使用未经转义的HTML语法字符：和号（\u0026amp;）、双引号（\u0026rdquo;\u0026ldquo;）、小于号（\u0026lt;）或大于号（\u0026gt;）；  \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click me\u0026#34; onclick=\u0026#34;alert(\u0026amp;quot;Clicked\u0026amp;quot;)\u0026#34; /\u0026gt;  特性值也可以是调用页面中其他地方定义的脚本， HTML事件处理程序在执行时 有权访问全局作用域中的任何代码 ；  \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click me\u0026#34; onclick=\u0026#34;showMessage()\u0026#34; /\u0026gt;  HTML事件处理程序内部可以 通过 event 变量直接访问事件对象 ，无需自己定义，也不用从函数的参数列表读取；\n HTML事件处理程序中的this等于事件的目标元素；\n  \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click me\u0026#34; onclick=\u0026#34;alert(this.value)\u0026#34; /\u0026gt;  HTML事件处理程序有着独特的扩展作用域：处理函数内部可以直接访问元素本身、document元素，类似使用with(this)、with(document)进行扩展一样；  \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(username.value)\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;  删除HTML事件处理程序的方法：设置事件处理程序对应的HTML特性值为null；\n HTML事件处理程序的三个缺点：\n  时差问题导致错误：当用户点击你的事件元素时你的处理函数可能还未准备好，例如页面上的处理程序调用了还未加载的脚本程序；\n扩展事件处理程序的作用域链在不同浏览器中会有差异；\nHTML事件处理程序与HTML紧密耦合，不便于修改。\nDOM 0级事件处理程序 var btn = document.getElementById(\u0026#39;myBtn\u0026#39;); btn.onclick = function(){ alert(this.value); }  ###\n DOM 0 级事件处理程序将之前HTML事件处理程序的处理权交还给JavaScript，现在为所有浏览器支持； 每个元素（包括window和document）都有自己的时间处理程序属性； DOM 0 级方法指定的事件处理程序被认为是元素的方法； DOM 0 级事件处理程序的作用域是元素本身，处理程序内的this指向元素； DOM 0 级事件处理程序会在事件流的冒泡阶段被处理； 缺点：  使用DOM 0 级时间处理程序无法为元素绑定多个事件，后面的同名事件处理程序会覆盖前面的；\n定制化不强。\n 删除DOM 0 级事件处理程序的方法：  ele.onclick = null;  DOM 2 级事件处理程序 var btn = document.getElementById(\u0026#39;myBtn\u0026#39;); var process = function(){ alert(this.value); } btn.addEventListener(\u0026#39;click\u0026#39;, process, false); btn.addEventListener(\u0026#39;click\u0026#39;, process, false);   两个方法：addEventListener()、removeEventListener(); window、document和所有DOM节点都有这两个属性（方法）； 三个参数：事件名、事件处理函数、是否捕获阶段即调用布尔值； 最佳实践：无特殊要求，第三个参数始终设为false（见11）； 最佳实践：事件处理函数最好预先定义，避免使用匿名函数（见10）; 事件处理程序在其依附的元素的作用域中运行，事件处理函数中的this指向元素本身； 主要优点：可以为一个元素添加多个同名的事件处理程序； 通过addEventListener()添加的事件处理程序只能调用removeEventListener()来移除； removeEventListener()移除事件处理程序时传入的参数必须与添加事件处理程序时传入的参数相同，且第二个参数：事件处理函数的指向必须相同，否则无法移除事件处理程序； 将第三个参数设置为false是为了最大限度地兼容各个浏览器，除非需要在时间到达目标之前截获它，才将第三个参数设置为true; IE9+支持(包括9)； 技巧：当事件处理函数是匿名函数时如何移除实践处理程序—使用arguments.callee指向当前函数本身来移除事件处理函数  var clickNumber = 0; window.addEventListener(\u0026#39;click\u0026#39;, function(){ if(clickNumber == 1){ window.removeEventListener(\u0026#39;click\u0026#39;, arguments.callee, false); }else{ alert(\u0026#39;clicked!\u0026#39;); clickNumber = 1; } });  IE事件处理程序 var btn = document.getElementById(\u0026#39;myDiv\u0026#39;); var process = function(){ alert(this); }; btn.attachEvent(\u0026#39;onClick\u0026#39;, process); btn.detachEvent(\u0026#39;onClick\u0026#39;, process);   IE8不支持DOM2级事件； 注意点：attachEvent()、detachEvent()特殊之处  接收的第一个参数为 on+'event'，并不是DOM2级事件的'event'；\n接收无需指定是否捕获阶段截获的布尔值参数，默认冒泡阶段截获事件。\n 牢记：attachEvent() 事件处理程序的事件处理函数的作用域是全局作用域，this指向window，与HTML事件处理程序、DOM 0级事件处理程序、DOM 2级事件处理程序有所不同； attachEvent()也可以为一个元素添加多个同名的时间处理程序； detachEvent()移除事件处理程序接收的参数必须与attachEvent()接收的参数一致，且事件处理函数的指向必须一致（匿名函数无法被移除）。  跨浏览器的事件处理程序  基本原则：使用能力检测；\n 为保证处理事件的代码能在大多数浏览器下运行，只关注冒泡阶段是很好的选择；\n 结合DOM 0 级方法、DOM 2 级方法或IE方法来添加事件，使用能力检测向后兼容；\n  var EventUtil = { addEventHandler: function(element, type, handler){ if(element.addEventListener){ element.addEventListener(type, handler, false); }else if(element.attachEvent){ element.attachEvent(\u0026#39;on\u0026#39;+type, handler); }else{ element[\u0026#39;on\u0026#39;+type]=handler; } }, removeEventHandler: function(element, type, handler){ if(element.removeEventListener){ element.removeEventListener(type, handler, false); }else if(element.detachEvent){ element.detachEvent(\u0026#39;on\u0026#39;+type, handler); }else{ element[\u0026#39;on\u0026#39;+type] = null; } } }   以上代码的局限性：没有考虑各个事件处理程序的作用域问题  HTML事件处理程序关联作用域：document、（this.form）、this element\nDOM 0 级事件处理程序关联作用域：this element\nDOM 2 级事件处理程序关联作用域：this element\nIE事件处理程序关联作用域：window\n","href":"/post/20190531215629/","title":"javascript 事件处理程序"},{"content":" 事件流 描述的是从页面中 接收事件的顺序 。\n对待事件流的问题上，IE和Netscape提出了完全相反的两个概念：IE的事件流是 冒泡流 ，而Netscape的事件流是 捕获流。\n事件冒泡  IE的 事件流类型；现已被所有现代浏览器支持； 时间开始时由最具体的元素——文档中嵌套层次最具体的元素（可理解为最小的同心圆）接收，然后事件沿DOM树向上传播到document对象； 所有的现代浏览器都支持冒泡，各浏览器之间的差异  IE8- 事件冒泡到document即停止；\n其他现代浏览器支持一直冒泡到window对象；\n事件捕获  Netscape浏览器的事件流机制； 事件开始时由不具体的节点——文档中嵌套层次最上级的元素（可理解为最大的同心圆）最早接收，然后事件沿着DOM树向下传播，直到传播到最具体的节点； 现代浏览器都支持 事件捕获 模型； DOM2级 事件规范要求：从document对象开始传播；但一般的现代浏览器都从window对象开始捕获。  DOM事件流  ”DOM 2级事件“规定的事件包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段； 实例：document\u0026gt;html\u0026gt;body\u0026gt;div  在DOM事件流中，实际的目标(div)在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到html再到body后就会停止。下一个阶段就是处于\u0026rdquo;处于目标\u0026rdquo;阶段，于是事件在div上发生，并 在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播到文档。\n ”DOM2级事件“规定：捕获阶段不涉及事件目标；但一般的现代浏览器都会在捕获阶段触发事件对象上的事件；导致的结果就是：有两个机会（捕获、冒泡）在目标对象上面操作事件； IE8- 不支持DOM事件流。  ","href":"/post/20190531210541/","title":"javascript 事件流"},{"content":"JavaScript与HTML之间的交互是通过事件实现的。\n事件 ：文档或浏览器窗口中发生的一些交互瞬间；可以使用 侦听器 （或处理程序） 预订 事件，以便事件发生时执行相应的代码。\n这种 侦听事件——执行操作 的模式在传统软件过程中叫做 观察者模式 。\nDOM2级规范开始规范标准化DOM事件，IE8是最后一个仍然使用其专有事件系统的浏览器。\n除了DOM事件，还有BOM事件，HTML5致力于规范BOM事件。\n所有事件：\n","href":"/post/20190531204033/","title":"JavaScript 事件"},{"content":"","href":"/tags/%E6%97%B6%E9%97%B4/","title":"时间"},{"content":" 插入文本： innerText, outerText\ninnerText  读取元素中包含的所有文本内容，只读取文本内容； 写入时会删除元素的所有节点，插入文本内容； 不同浏览器处理空白和换行的方式不一样； firefox不支持innerText，但支持textContent属性；   textContent与innerText的不同点在于：innerText会忽略行内的样式和脚本，textContent不会；\n最佳实践 ：从不包含行内样式和行内脚本的DOM中读取文本\n  使用innerText可以过滤标签，快捷地获得纯文本。  function getInnerText(element){ return (typeof element.textContent == \u0026#39;string\u0026#39;) ? element.textContent : element.innerText; } function setInnerText(element, text){ if(typeof element.textContent == \u0026#39;string\u0026#39;){ elemnt.textContent = text; }else{ element.innerText = text; } }  滚动相关  scrollIntoView()：对元素调用此方法可以使页面滚动到与元素顶部平齐； scrollIntoViewIfNeeded(alignCenter)：调用方法的元素不可见的情况下运行，接受一个参数：是否垂直居中，布尔值； scrollByLines(lineCount)：将元素内容滚动到指定的行高； scrollByPages(pageCount)：将元素内容滚动至指定的页面高度；  以上三个方法支持性都不是很好！\n","href":"/post/20190531153512/","title":"DOM专有扩展"},{"content":"","href":"/tags/dom%E6%89%A9%E5%B1%95/","title":"DOM扩展"},{"content":"处于安全等方面的考虑：\n 通过innerHTML直接插入\u0026lt;script\u0026gt;元素在大多数浏览器中并不会执行其中的脚本； 通过innerHTML直接插入\u0026lt;style\u0026gt;在一些浏览器中无效。   在这些浏览器中，这两个元素被认为是”无作用域的元素“（不会在页面上显示的元素），如果通过innerHTML插入的字符串开头就是”无作用域的元素“，那么这些浏览器就会解决这个字符串前先删除该元素。解决的方法：在这些”无作用域的元素“前临时增加一个有作用域的元素，之后再将临时元素删除，同时为脚本元素设置defer特性。\n  部分元素不支持innerHTML; 冷知识：firefox浏览器在XHTML文档中设置innerHTML是要求XHTML必须严格符合要求，否则，innerHTML将会静默地失败； 最佳实践：使用innerHTML插入代码片时，请通过特定的方法过滤掉script标签（可能引入恶意脚本）。  ","href":"/post/20190531113301/","title":"HTML5之插入标记innerHTML"},{"content":"","href":"/tags/html5/","title":"html5"},{"content":" 该方法用于确定文档是否获得焦点； 可以通过检测文档是否获得焦点得知用户是否正在与页面交互。  ","href":"/post/20190531104239/","title":"Javascript焦点管理—document.hasFocus()"},{"content":" document.activeElement指向页面中当前获得焦点的元素； 元素获得焦点的方式； 文档刚加载完，document.activeElement指向document.body； 文档加载期间，document.activeElement指向null。  ","href":"/post/20190531103901/","title":"Javascript焦点管理-document.activeElement"},{"content":" 页面加载 Tab切换 元素的focus()方法  ","href":"/post/20190531103310/","title":"元素获得焦点的方式"},{"content":"","href":"/tags/java/","title":"java"},{"content":" 将*.tar.gz解压（以jdk8.144为例）：\ntar -xzvf jdk-8u144-linux-x64.tar.gz  得到的文件夹为jdk1.8.0_144，将其移动到/usr/lib/jvm中： bash sudo mv jdk1.8.0_144 /usr/lib/jvm   设置环境变量：\nsudo gedit /etc/profile 打开文件，在结尾处输入：\nexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 export JRE_HOME=/usr/lib/jvm/jdk1.8.0_144/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 生效配置文件：\n  source /etc/profile  创建jdk软链接：  update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_144/bin/java 300 update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_144/bin/javac 300  设置默认jdk：  update-alternatives --config java  查看jdk版本，检查是否安装完成：  java -version","href":"/post/20190531102524/","title":"orcle jdk linux 安装教程"},{"content":"","href":"/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/","title":"编程开发"},{"content":"  HTML5规范定义了一系列与DOM规范重叠的API;\nHTML5的规范涉及面非常广，新增的DOM API只是其一部分。\n getElementsByClassName()  可以通过document和所有HTML元素对象调用此方法；\n 返回带有指定类的NodeList;\n 传入的一个字符串参数可以包含多个类；\n  classList属性  所有元素都拥有，是新集合类型DOMTokenList的对象实例； 访问classList的项: []、item()、classList对象属性; 对象属性: length; 删除一个元素多个类名中的某个类名的旧版方法：  function removeClass(element, toDelClass){ var classNames = element.className.split(/\\s+/); var pos = -1, i, len = className.length; for(i=0; i\u0026lt;len; i++){ if(classNames[i] == toDelClass){ pos = i; break; } } classNames.splice(i, 1); element.className = classNames.join(\u0026#39; \u0026#39;); } removeClass(document.body, \u0026#39;any-class\u0026#39;);   使用classList对象的方法操作元素的className：  var element = document.getElementById(\u0026#39;myDiv\u0026#39;); // add(value) -- 如果存在就不添加了 element.classList.add(\u0026#39;newClassName\u0026#39;); // 输出：undefined  // contains(value) -- 如果存在返回true，否则false element.classList.contains(\u0026#39;newClassName\u0026#39;); // 输出：true  // remove(value) -- 从列表中删除给定的字符串 element.classList.remove(\u0026#39;newClassName\u0026#39;); // 输出：undefined  // toggle(value) -- 如果列表中存在给定值，就删除；否则，添加 element.classList.toggle(\u0026#39;newClassName\u0026#39;); // 输出：undefined  焦点管理  document.activeElement； document.hasFocus();  HTMLDocument的变化 readyState  属性可用于实现一个文档的加载完成指示器； loading：正在加载的文档； complete: 已经完成加载；  兼容模式  document.compatMode可以侦测渲染的页面是标准模式还是混杂模式； 两个取值：CSS1Compat（标准模式）、BackCompat（混杂模式）；  head属性  类似于document.body的作用，document.head用于快捷访问文档的head标签； 兼容性写法：  var head = document.head || document.getElementsByTagName(\u0026#39;head\u0026#39;)[0];  字符集属性  document.charset属性表示文档实际使用的字符集；\n document.charset是可写的；\n document.defaultCharset表示操作系统和浏览器默认的字符集，中文操作系统一般是gb2312；\n  自定义数据属性  HTML5规定可以为元素添加非标准的属性，但需要添加前缀data-； 自定义数据属性提供的是与渲染无关，但用于存储不可见的重要数据的属性； 元素相应地增加了dataset属性来访问和编辑自定义的属性值；  var div = document.getElementById(\u0026#39;myDiv\u0026#39;); // 设置值 div.dataset.appId = 23456; div.dataset.myname = \u0026#39;Michael\u0026#39;; // 取得自定义属性的值 var appId = div.dataset.appId; var myName = div.dataset.myname;   实际应用：可以为文档不同位置的元素添加data-属性，设置加载的百分比，然后该数据可以用于制作加载进度条；  插入标记 ### innerHTML\nouterHTML  与innerHTML的不同的是，返回和写入调用它的元素及其子节点的HTML标签\n insertAdjacentHTML()方法  所有元素新增的方法； 两个参数：插入位置、插入的HTML字符串文本； 位置参数的取值：  beforebegin：作为前一个同辈元素插入；\nafterbegin：作为第一个子元素插入；\nbeforeend：作为最后一个子元素插入；\nafterned：作为后一个同辈元素插入；\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var element = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; // 作为前一个同辈元素插入  element.insertAdjacentHTML(\u0026#39;beforebegin\u0026#39;, \u0026#39;\u0026lt;p\u0026gt;beforebegin\u0026lt;/p\u0026gt;\u0026#39;); // 作为第一个子元素插入  element.insertAdjacentHTML(\u0026#39;afterbegin\u0026#39;, \u0026#39;\u0026lt;p\u0026gt;afterbegin\u0026lt;/p\u0026gt;\u0026#39;); // 作为最后一个子元素插入  element.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;\u0026lt;p\u0026gt;beforeend\u0026lt;/p\u0026gt;\u0026#39;); // 作为后一个同辈元素插入  element.insertAdjacentHTML(\u0026#39;afterend\u0026#39;, \u0026#39;\u0026lt;p\u0026gt;afterend\u0026lt;/p\u0026gt;\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  与此同时，还有insertAdjacentElement()用法与insertAdjacentHTML()一致，但第二个参数需传入元素节点。  内存与性能问题  innerHTML等操作会在浏览器底层运行，效率高，但过度使用会使页面的性能表现下降； 不要频繁插入，最好将要插入的HTML先保存在一个字符串内，然后一次性插入。  scrollIntoView()  HTML5为所有的元素节点新增的方法； 接收一个参数：true/false  true：元素顶部与视口顶部平齐；\nfalse：元素底部与视口底部平齐；\n专有扩展  IE文档模式属性：document.documentMode   可以通过HTML文档头部的meta、X-UACompatible设置\n  children属性：  i. HTMLCollection实例；\nii. 与childNodes的不同点是：只包含元素的子节点；\n contains()方法——元素的新增方法：一个元素节点参数，检测是否被调用方法的元素包含； DOM Level3 为元素节点新增方法：compareDocumentPosition() 同样接收一个元素节点作为参数，返回位掩码的➕和，用于确定两个节点间的关系：     掩码 节点关系     1 无关（给定的节点不在当前文档中）   2 居前（给定的节点在DOM树中位于参考节点之前）   4 居后（给定的节点在DOM树种位于参考节点之后）   8 包含（给定的节点是参考节点的祖先）   16 被包含（给定的节点是参考节点的后代）    \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var result = document.documentElement.compareDocumentPosition(document.body); console.log(result); // 输出：4+16 = 20  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  contains()兼容代码：  function contains(refNode, otherNode){ if(typeof refNode.contains == \u0026#39;function\u0026#39;){ return refNode.contains(otherNode); }else if(typeof refNode.compareDocumentPosition == \u0026#39;function\u0026#39;){ return !!(refNode.compareDocumentPosition(otherNode) \u0026amp; 16); }else{ var node = otherNode.parentNode; do{ if(node === refNode){ return true; }else{ node = node.parentNode; } }while(node !== null); return false; } } ","href":"/post/20190530225803/","title":"HTML5的特性"},{"content":" 使用循环语句进行常规遍历的不方便性：  元素间的空格(空行)的对待方式不一致，除IE9-外的浏览器都视作文本节点，所以未使用新API之前遍历元素都需要检测节点的类型，跳开空格（空行）代表文本节点。\n W3C的Element Traversal规范新定义了一组属性：IE9+支持：  childElementCount: 子元素节点的个数； firstElementChild: 第一个子元素节点； lastElementChild: 最后一个子元素节点； previousElementSibling: 后一个元素节点  旧的写法： var i, len, child = element.firstChild; while(child != element.lastChild){ if(child.nodeType == 1){ // 检查是不是元素  processChild(child); } child = child.nextSubling; }  新API下的写法： var i, len, child = element.firstElementChild; while(child != element.lastElementChild){ processChild(child); child = child.nextElementSibling; } ","href":"/post/20190530192147/","title":"DOM扩展-元素遍历"},{"content":"","href":"/tags/%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/","title":"元素遍历"},{"content":" 关闭pyspider 进入data目录 删除目录下面除了project.db之外的文件 重新启动pyspider  ","href":"/post/20190530170113/","title":"pyspider如何刷新项目的状态"},{"content":"","href":"/tags/mongodb/","title":"mongodb"},{"content":"","href":"/categories/mongodb/","title":"mongodb"},{"content":" 关键字的名称：test\n数据表名：test\n搜索关键字：test\n    作用 命令 例子     列出所有包含test的item {\u0026quot;test\u0026quot;: {\u0026quot;$exists\u0026quot;: true}} db.getCollection('test').find({\u0026quot;test\u0026quot;: {\u0026quot;$exists\u0026quot;: true}})   根据test进行排序 新版本：[(\u0026quot;test\u0026quot;, 1或-1)]\n老版本：{\u0026quot;test\u0026quot;:1或-1}\n，\u0026rdquo;1\u0026rdquo;表示升序，”-1“表示降序 db.getCollection('test').find().sort([(\u0026quot;test\u0026quot;, -1)])   列出所有符合正则表达式的item {\u0026quot;test\u0026quot;: {\u0026quot;$regex\u0026quot;: \u0026quot;test\u0026quot;}} db.getCollection('test').find({\u0026quot;test\u0026quot;: {\u0026quot;$regex\u0026quot;: \u0026quot;test\u0026quot;}})   限制列出的item的数量 数字 db.getCollection('test').find().limit(自定义数字)   列出所有符合字符串长度的item {\u0026quot;$where\u0026quot;: \u0026quot;(this.test.length \u0026gt; 自定义长度)\u0026quot;} db.getCollection('test').find({\u0026quot;$where\u0026quot;: \u0026quot;(this.test.length \u0026gt; 自定义长度)\u0026quot;})   统计item的数量 collection.count_documents({}) db.getCollection(\u0026quot;test\u0026quot;).count_documents({})    持续更新\u0026hellip;\n","href":"/post/20190530161620/","title":"mongodb常用命令大全"},{"content":"","href":"/tags/pyspider/","title":"pyspider"},{"content":" 工具： pyspider\n数据库： mongodb\n思路：  假设你要根据两个关键字搜索百度知道答案，比如：”购物“和”价格“； 组建爬虫的url，需要把这两个关键字转化为url编码的格式，url编码教程详见； 取出搜索页面列表上面所有项的url链接; 然后，爬取步骤3的url，取出页面上面的question和最佳答案； 循环往复，进行2、3、4步骤；  代码： #!/usr/bin/env python # -*- encoding: utf-8 -*- from pyspider.libs.base_handler import * from urllib.parse import quote, unquote from pymongo import MongoClient import datetime import time import random client = MongoClient(\u0026#34;自定义数据库接口\u0026#34;) db = client.自定义数据库名 class Handler(BaseHandler): crawl_config = { } key_word1 = quote(\u0026#34;自定义关键字1\u0026#34;.encode(\u0026#34;GB2312\u0026#34;)) key_word2_list = [\u0026#34;自定义关键字2\u0026#34;] key_word2_list = [quote(i.encode(\u0026#34;GB2312\u0026#34;)) for i in key_word2_list] url_format = \u0026#34;https://zhidao.baidu.com/search?word={}\u0026amp;ie=gbk\u0026amp;site=-1\u0026amp;sites=0\u0026amp;date=0\u0026amp;pn={}\u0026#34; page_num = 76 # 最大页码 start_page = 0 # 开始的页码 max_random = 5 # 随机数的最大值 headers1 = { \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9,en;q=0.8\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;zhidao.baidu.com\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;自定义系统的浏览器版本号\u0026#34;, } fetch_count = 0 # 访问api计数 @every(minutes=24 * 60) def on_start(self): start_time = time.time() for kw2 in Handler.key_word2_list: kw = Handler.key_word1 + \u0026#34;+\u0026#34; + kw2 for p in range(Handler.start_page, Handler.page_num): url = Handler.url_format.format(kw, p*10) Handler.headers1[\u0026#34;Referer\u0026#34;] = url Handler.fetch_count += 1 # 抓取次数累计 start_time = start_time+Handler.fetch_count*random.randint(0, Handler.max_random) self.crawl(url, callback=self.index_page, headers=Handler.headers1, save={\u0026#34;url\u0026#34;: url, \u0026#34;kw2\u0026#34;: unquote(kw2, \u0026#34;GB2312\u0026#34;), \u0026#34;start_time\u0026#34;: start_time}, exetime=start_time) @config(age=24 * 60 * 60) def index_page(self, response): start_time = response.save[\u0026#34;start_time\u0026#34;] for i in response.doc(\u0026#34;#wgt-list \u0026gt; dl\u0026#34;).items(): url = i(\u0026#34;dt \u0026gt; a\u0026#34;).attr(\u0026#34;href\u0026#34;) Handler.headers1[\u0026#34;Referer\u0026#34;] = response.save[\u0026#34;url\u0026#34;] Handler.fetch_count += 1 # 抓取次数累计 start_time = start_time+Handler.fetch_count*random.randint(0, Handler.max_random) self.crawl(url, callback=self.detail_page, headers=Handler.headers1, save={\u0026#34;kw2\u0026#34;: response.save[\u0026#34;kw2\u0026#34;]}, exetime=start_time) @config(priority=2) def detail_page(self, response): data = {} data[\u0026#34;url\u0026#34;] = response.url data[\u0026#34;question\u0026#34;] = response.doc(\u0026#34;#wgt-ask \u0026gt; h1\u0026#34;).text().strip() data[\u0026#34;answer\u0026#34;] = response.doc(\u0026#34;div.best-text\u0026#34;).text().strip().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;展开全部\u0026#34;, \u0026#34;\u0026#34;) if not data[\u0026#34;answer\u0026#34;]: data[\u0026#34;answer\u0026#34;] = response.doc(\u0026#34;div.answer-text\u0026#34;).text().strip().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;展开全部\u0026#34;, \u0026#34;\u0026#34;) data[\u0026#34;kw2\u0026#34;] = response.save[\u0026#34;kw2\u0026#34;] data[\u0026#34;kw1\u0026#34;] = unquote(Handler.key_word1, \u0026#34;GB2312\u0026#34;) data[\u0026#34;crawl_time\u0026#34;] = datetime.datetime.strptime(datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;), \u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;) print(data) if db[\u0026#34;自定义表名\u0026#34;].find({\u0026#34;kw2\u0026#34;: data[\u0026#34;kw2\u0026#34;], \u0026#34;question\u0026#34;: data[\u0026#34;question\u0026#34;]}).count() == 0: result = db[\u0026#34;自定义表名\u0026#34;].insert(data) else: result = db[\u0026#34;自定义表名\u0026#34;].update(data) print(result)","href":"/post/20190530153141/","title":"百度知道爬虫"},{"content":"","href":"/tags/url%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/","title":"url编码和解码"},{"content":"  百度搜索编码的格式与国际上面其他搜索的格式有所不同，比如google的是UTF-8，但是百度使用的是GB2312编码。\n 应用场景  在爬虫当中我们经常需要组装url来进行页面的爬虫，这个时候我们就需要把搜索的关键字编码为url的形式，下面我们以python3代码为例讲解url的编码和解码：  # -*- coding: utf-8 -*- from urllib.parse import quote, unquote key_word = \u0026#34;购车\u0026#34;; # url编码 key_word_quote = quote(key_word.encode(\u0026#34;GB2312\u0026#34;), \u0026#39;gbk\u0026#39;) print(key_word_quote) # url解码 print(unquote(key_word_quote, \u0026#39;gbk\u0026#39;))","href":"/post/20190530113844/","title":"百度搜索-url编码"},{"content":"","href":"/categories/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/","title":"编码转换"},{"content":"  选择符API允许直接使用CSS选择器来选取页面元素，众多库推进了选择符API的标准化。\n选择符API性能因为原生，所以性能必定强于各个库同类型的查询操作。\n querySelector()  Selector API Level 1;\n 接收一个css选择符（可复杂）,返回匹配的第一个元素或返回null;\n 传入不支持的选择符会抛出错误；\n 能调用querySelector()的对象为：Document类型，Element类型，DocumentFragment类型。\n  querySelectorAll()  Selector API Level 1; 接收一个CSS选择符（可复杂），返回所有匹配元素组成的NodeList实例或null; 传入不支持的选择符会抛出错误； 能调用querySelector()的对象为：Document类型，Element类型，DocumentFragment类型。  matchesSelector()  Selector API Level 2; 接收一个css选择器做参数，比较选择符与调用方法的元素是否匹配，返回布尔值； 各个浏览器支持性不同：IE9+通过document.body.msMatchesSelector()支持该方法，Firefox3.6通过document.body.mozMatchesSelector()支持该方法，Safari5+和Chrome通过document.body.webkitMatchesSelector()支持该方法。下面是一个包装的函数：  function matchesSelector(element, selector){ if(element.matchesSelector){ return element.matchesSelector(selector); }else if(element.msMatchesSelector){ return element.msMatchesSelector(selector); }else if(element.mozMatchesSelector){ return element.mozMatchesSelector(selector); }else if(element.webkitMatchesSelector){ return element.webkitMatchesSelector(selector); }else{ throw new Error(\u0026#34;Not supported.\u0026#34;); } } if(matchesSelector(document.body, \u0026#34;body.page1\u0026#34;)){ //执行操作 } ","href":"/post/20190530105836/","title":"DOM扩展-选择符API"},{"content":"2008年之前，几乎所有的DOM扩展都是专有的，之后W3C着手将一些已经成为事实的专有扩展标准化并写入规范当中；\n大部分扩展都来自社区的呼声，虽然现在标准已经涵盖了大量的以前的DOM扩展，但是各个浏览器的专有扩展依然存在。\n","href":"/post/20190530103703/","title":"DOM扩展的发展和现状"},{"content":" \u0026lt;table\u0026gt;元素的属性和方法：  caption：返回表格的caption元素节点，没有则返回null； tHead, tBodies, tFoot: 返回表格\u0026lt;thead\u0026gt;, \u0026lt;tbody\u0026gt;, \u0026lt;tfoot\u0026gt;元素； rows: 返回元素所有行\u0026lt;tr\u0026gt;元素的HTMLCollection; createTHead(), createTFoot(), createCaption(): 创建\u0026lt;thead\u0026gt;, \u0026lt;tfoot\u0026gt;, \u0026lt;caption\u0026gt;空元素，将其放到表格中，返回创建的\u0026lt;thead\u0026gt;, \u0026lt;tfoot\u0026gt;, \u0026lt;caption\u0026gt;元素节点； deleteTHead(), deleteTFoot(), deleteCaption(): 删除\u0026lt;thead\u0026gt;, \u0026lt;tfoot\u0026gt;, \u0026lt;caption\u0026gt;空元素，无返回值（或返回值为undefined） deleteRow(pos): 删除指定位置（注意参数不是索引，而是从0开始的位置）的行，返回undefined; insertRow(pos): 向rows集合中的指定位置（不是索引）插入一行；  \u0026lt;tbody\u0026gt;元素的属性和方法：  rows: 返回\u0026lt;tbody\u0026gt;元素下所有行\u0026lt;tr\u0026gt;元素的HTMLCollection; deleteRow(pos): 删除指定位置（注意参数不是索引，而是从0开始的位置）的行，返回undefined; insertRow(pos):向rows集合中的指定位置（不是索引）插入一行；  \u0026lt;tr\u0026gt;元素的属性和方法：  cells: 返回\u0026lt;tr\u0026gt;元素中单元格的HTMLCollection; deleteCell(pos): 删除指定位置（不是索引）的单元格； insertCell(pos): 向cells集合中的指定位置（不是索引）插入一个单元格，返回对新插入单元格的引用；   \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 创建table  var table = document.createElement(\u0026#39;table\u0026#39;); table.border = 1; table.width = \u0026#39;100%\u0026#39;; // 创建caption  var caption = table.createCaption(); caption.innerHTML = \u0026#39;My Table\u0026#39;; // 创建thead  var thead = document.createElement(\u0026#39;thead\u0026#39;); thead.insertRow(0); thead.rows[0].insertCell(0); thead.rows[0].cells[0].appendChild(document.createTextNode(\u0026#39;标题一\u0026#39;)); thead.rows[0].insertCell(1); thead.rows[0].cells[1].appendChild(document.createTextNode(\u0026#39;标题二\u0026#39;)); table.appendChild(thead); // 创建tbody  var tbody = document.createElement(\u0026#39;tbody\u0026#39;); table.appendChild(tbody); // 创建第一行  tbody.insertRow(0); tbody.rows[0].insertCell(0); tbody.rows[0].cells[0].appendChild(document.createTextNode(\u0026#39;Cell 1, 1\u0026#39;)); tbody.rows[0].insertCell(1); tbody.rows[0].cells[1].appendChild(document.createTextNode(\u0026#39;Cell 2, 1\u0026#39;)); // 创建第二行  var row02 = tbody.insertRow(1); var cell0201 = row02.insertCell(0), cell0202 = row02.insertCell(1); cell0201.appendChild(document.createTextNode(\u0026#39;cell 2,1\u0026#39;)); cell0202.appendChild(document.createTextNode(\u0026#39;cell 2,2\u0026#39;)); // 将表格添加到文档主体中  document.body.appendChild(table); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;","href":"/post/20190530100359/","title":"table, tbody, tr 元素的属性和方法"},{"content":"","href":"/tags/table%E6%A0%87%E7%AD%BE/","title":"table标签"},{"content":"","href":"/tags/%E5%B1%9E%E6%80%A7/","title":"属性"},{"content":"","href":"/tags/%E6%96%B9%E6%B3%95/","title":"方法"},{"content":"  DOM操作最大的两个麻烦就是：操作效率问题、浏览器兼容问题\n 动态脚本  通过修改DOM动态添加的脚本的两种模式：插入外部文件，插入JavaScript代码 插入外部文件  var script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;client.js\u0026#39;; document.body.appendChild(script);   封装为外部脚本插入函数  fucntion loadScript(url){ var script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; document.body.appendChild(script); } loadScript(\u0026#39;script.js\u0026#39;);   插入行内代码：不兼容IE,它将\u0026lt;script\u0026gt;视为一个特殊的元素，不允许DOM访问其子节点： ```javascript\nvar script = document.createElement(\u0026lsquo;script\u0026rsquo;); var textNode = document.createTextNode(\u0026lsquo;function sayHi(){alert(\\\u0026lsquo;Hi!\\\u0026lsquo;)}\u0026rsquo;); script.appendChild(textNode);  document.body.appendChild(script);\n 3. 插入行内代码的兼容性解决方案：行内脚本插入封装函数 ```javascript function loadScript(code){ var script = document.createElement('script'); try{ script.appendChild(document.createTextNode(code)); }catch(err){ script.text = code; } document.body.appendChild(script); } loadScript(' function sayHi(){alert(\u0026quot;Hi!\u0026quot;)}');   以上两种模式加载的脚本代码会立刻执行；\n 虽然可以，但是不推荐使用eval()来执行字符串代码；\n  动态样式  通过DOM动态添加样式的两种模式：\u0026lt;link\u0026gt;引入外部样式；\u0026lt;style\u0026gt;嵌入样式； 插入外部样式文件封装函数：  function loadStyles(url){ var head = document.getElementByTagName(\u0026#39;head\u0026#39;)[0]; var link = document.createElement(\u0026#39;link\u0026#39;); link.el = \u0026#39;stylesheet\u0026#39;; link.href = url; head.appendChild(link); } loadStyles(\u0026#39;styles.css\u0026#39;);   插入行内样式的兼容性解决方案：行内样式插入封装函数  function loadInlineStyle(css){ var head = document.getElementsByTagName(\u0026#39;head\u0026#39;)[0]; var style = document.createElement(\u0026#39;style\u0026#39;); try{ style.appendChild(document.createTextNode(css)); }catch(){ style.styleSheet.cssText = css } head.appendChild(style); } loadInlineStyle(\u0026#39;body{background-color: red;}\u0026#39;);   IE将\u0026lt;style\u0026gt;视为一个特殊元素的，与\u0026lt;script\u0026gt;类似的节点，所以需要写入内联的样式代码，需要使用IE下的style节点的特征属性：style.styleSheet.cssText。  操作表格  HTML DOM为了方便操作表格，为\u0026lt;table\u0026gt;, \u0026lt;tbody\u0026gt;, \u0026lt;tr\u0026gt;元素添加了特殊的属性和方法； \u0026lt;table\u0026gt;, \u0026lt;tbody\u0026gt;, \u0026lt;tr\u0026gt;元素的属性和方法  使用NodeList 理解并区别三个概念：NodeList, NamedNodeMap, HTMLCollection;\n 上面三个集合都是动态的，所有以上集合都是在访问DOM文档时实时运行的查询； 动态性实例：每一次访问的都是更新后的集合  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;), i, div; for(var i=0; i\u0026lt;divs.length; i++){ div = document.createElement(\u0026#39;div\u0026#39;); document.body.appendChild(div); } // 页面挂掉了 \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  最佳实践：防止出现上面的情况的解决方案是，将NodeList的length缓存到一个变量中：  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;), i, len, div; for(var i=0, len = divs.length; i\u0026lt;len; i++){ div = document.createElement(\u0026#39;div\u0026#39;); document.body.appendChild(div); } // 页面挂掉了 \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  最佳实践：减少访问NodeList的次数，每次访问都会重新查询一次。  ","href":"/post/20190529225444/","title":"DOM操作技术"},{"content":" Comment类型  nodeType为8，nodeName为#comment，nodeValue为注释内容； Comment类型拥有除splitText()之外的所有的属性和方法； 创建注释节点只需要传入注释内容即可  document.createComment(\u0026#39;Hi\u0026#39;);   一般浏览器不会识别位于后面的注释；\n 在IE8中，注释节点被视作标签名为\u0026rdquo;!\u0026rdquo; 的元素，注释节点可以使用getElementsByTagName('!')取得；\n  CDATASection类型  nodeType为4，nodeName为#cdata-section，nodeValue为CDATA区域的内容； CDATASection类型针对的是XML文档，表示的是CDATA区域，在HTML文档中会错误地把CDATA区域解析为Comment或Element； 针对XML文档，可以使用document.createCDATASection()来创建CDATASection类型对象，接收一个参数：CDATA区域的内容； CDATASection类型继承自Text类型，除了splitText()方法外所有的属性和方法都拥有；  DocumentType类型  nodeType为0；nodeName为#document，nodeValue为null； 不能动态的创建，只能有html文档规定； document.doctype.name(entities、notations这两个属性没有用)属性； 使用document.doctype访问DocumentType对象；  DocumentFragment类型  文档碎片； DocumentFragment节点类型在文档中没有对应标记，它是游离于文档之外的； DocumentFragment类型是一种轻量级的文档（类似完整的HTML文档），可以包含和控制节点，但不会像完整的文档那样占用额外的资源； nodeType为11;nodeName为#document-fragment；nodeValue为null；可以包含任意类型的子节点； DocumentFrgment类型一般作为一个节点仓库来使用，可以在里面保存将来可能添加到文档的节点，然后DocumentFragment整体插入到文档内； DocumentFragment类型继承了node类型的所有方法； 创建：document.createDocumentFragment(); 文档碎片可以通过appendChild(DoCFrag), insertBefore(DocFrag)来插入文档，此时文档碎片便成为了文档的一部分；  Attr类型  元素的特性在DOM中以Attr类型来表示； 特性就是存在于元素的attributes属性对象中的节点； 三个属性：name, value, specified; 创建特性节点：document.createAttribute(attrName); 新创建的特性节点需要添加到元素上，使用元素的setAttribute(attrName)方法； html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026quot;123\u0026quot; style=\u0026quot;height: 20px;\u0026quot;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; ele.setAttribute('align', 'left'); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  6. 不建议直接访问元素的特性节点（getAttributeNode()等），而使用getAttribute(), setAttribute(), removeAttribute()来访问和操作元素的特性。  ","href":"/post/20190529223557/","title":"javascript的Comment、CDATASection、DocumentType、DocumentFragment、Attr类型"},{"content":"  nodeType为3, nodeName为#text; 不支持子节点； 可以包含转义的HTML字符； 文本节点的值可以通过nodeValue属性或data属性访问；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var text = document.createTextNode(\u0026#34;Hello world!\u0026#34;); console.log(text.nodeType); // 输出：3  console.log(text.nodeName); // 输出：#text  console.log(text.nodeValue); // 输出：Hello world!  console.log(text.data); // 输出：Hello world!  console.log(text.nodeValue.length); // 输出：12  console.log(text.data.length); // 输出：12  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  操作文本节点的方法\n 默认情况下。每个包含内容的元素最多只能有一个文本节点，而且必须有内容存在；\n 创建和修改文本节点时，字符串会经过HTML（或XML）编码转义，防止对原文档造成解析错误；\n  div.firstChild.nodeValue = \u0026#34;\u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt;\u0026#34;; // \u0026#34;\u0026amp;lt;p\u0026amp;gt;Hello world!\u0026amp;lt;/p\u0026amp;gt;\u0026#34;  创建文本节点  document.createTextNode(); 可以人为使一个元素包含多个文本节点，虽然多个文本节点的表现形式与单个节点的表现形式没什么两样；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var element = document.createElement(\u0026#39;div\u0026#39;); element.className = \u0026#39;message\u0026#39;; var textNode = document.createTextNode(\u0026#39;Hello world!\u0026#39;); element.appendChild(textNode); var anotherTextNode = document.createTextNode(\u0026#39;Yippee!\u0026#39;); element.appendChild(anotherTextNode); document.body.appendChild(element); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 规范化文本节点 元素节点的方法：element.normalize()方法用于合并元素内的多个文本节点\n分隔文本节点 Text类型的splitText()方法接收一个参数：分割的位置索引，将一个文本节点分为两个，同时返回后一个新文本节点;\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var element = document.createElement(\u0026#39;div\u0026#39;); element.className = \u0026#39;message\u0026#39;; var textNode = document.createTextNode(\u0026#39;Hello world!\u0026#39;); var newNode = textNode.splitText(5); element.appendChild(textNode); element.appendChild(newNode); document.body.appendChild(element); document.body.appendChild(); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这个方法一般用于从文本节点提取数据\n","href":"/post/20190529203530/","title":"javascript Text类型"},{"content":"","href":"/tags/text%E7%B1%BB%E5%9E%8B/","title":"text类型"},{"content":" appendText(text); deleteData(offset, count); insertData(offset, count); replaceData(offset, count, text); splitText(offset); substringData(offset, count);  ","href":"/post/20190529203109/","title":"javascript操作文本节点的方法"},{"content":"  Element节点是Element类型的实例； Element节点的nodeName与tagName属性元素的标签名的大写;nodeValue为null;  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.getElementById(\u0026#34;123\u0026#34;); console.log(_div.nodeName); console.log(_div.tagName); console.log(_div.nodeValue); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  最佳实践：在比较标签名与字符串时，最好先将标签名转为为全小写。  HTML元素  所有HTML元素都由HTMLElement类型表示，HTMLElement类型继承自Element类型并添加了一些属性和方法；   所有HTML元素都是由HTMLElement或者其子类型表示的，每个HTML元素都由与之关联的类型，如：HTMLAnchorElement, HTMLBodyElement, HTMLDivElement\u0026hellip;, 这些类型都继承HTMLElement类型的属性和方法，也有着自己的扩展\n  大部分HTML标签的原生特性作为Element节点对象的属性都可以直接通过\u0026rdquo;.\u0026ldquo;或\u0026rdquo;[]\u0026ldquo;操作符读写，但无法读写自定义的特性（见下面的取得特性一节）  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.getElementById(\u0026#34;123\u0026#34;); console.log(_div.id); console.log(_div.className); console.log(_div.name); console.log(_div[\u0026#34;id\u0026#34;]); console.log(_div[\u0026#34;className\u0026#34;]); console.log(_div[\u0026#34;name\u0026#34;]); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  class为ES的保留字，使用“.” 或\u0026rdquo;[]\u0026ldquo;访问元素类名需要使用className。  取得特性 getAttribute(), setAttribute(), removeAttribute()三个特性操作的方法：\n 传递给getAttribute()的特性名字符串与实际的特性名相同，比如：要获取class的特性值，应该传入\u0026rsquo;class\u0026rsquo;,而不是\u0026rsquo;className\u0026rsquo;; 通过getAttribute()方法可以取得自定义特性； 最佳实践：根据HTML5的规范推荐，自定义特性应该加上data-前缀以便验证； getAttribute()方法与节点的访问方法\u0026rdquo;.style\u0026rdquo;返回值的类型不同，前者返回一个字符串，后者返回CSSStypleDeclaration对象；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.getElementById(\u0026#34;123\u0026#34;); console.log(_div.getAttribute(\u0026#34;style\u0026#34;)); // 输出：height: 20px;  console.log(_div.style); // 输出：CSSStyleDeclaration {0: \u0026#34;height\u0026#34;, alignContent: \u0026#34;\u0026#34;, …}  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 同理，访问节点的\u0026rdquo;onclick\u0026rdquo;也分别返回function和字符串\n 最佳实践：只在获取标签的自定义特性值的情况下才使用getAttribute()方法，其余情况直接访问属性。  设置特性  setAttribute()接收两个字符串参数：name 和value； setAttribute()方法可以操作自定义特性； setAttribute()设置的特性名会自动转换为小写； 最佳实践：只有在设置自定义标签的时候才使用setAttribute()方法，其余情况直接操作属性； removeAttribute()用于彻底删除元素的特性和值，包括自定义特性；  attributes属性  attributes属性是Element类型独有的； attributes属性是一个NamedNodeMap对象，类似NodeList，是由特性节点组成对象； NamedNodeMap对象中的每一项又是一个单独的特性节点，有nodeName，nodeValue等属性； NamedNodeMap对象拥有的方法  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.getElementById(\u0026#34;123\u0026#34;); // item()  console.log(_div.attributes.item(1)); // 输出：style=\u0026#34;height: 20px;\u0026#34;  // getNamedItem()  console.log(_div.attributes.getNamedItem(\u0026#34;id\u0026#34;)); // 输出：id=\u0026#34;123\u0026#34;  console.log(_div.attributes.getNamedItem(\u0026#34;id\u0026#34;).nodeValue); // 输出：123  // removeNamedItem()  console.log(_div.attributes.removeNamedItem(\u0026#34;style\u0026#34;)); // 输出：style=\u0026#34;height: 20px;\u0026#34;  // setNamedItem()  var newAttr = document.createAttribute(\u0026#34;newAttr\u0026#34;); newAttr.nodeValue = \u0026#34;456\u0026#34;; _div.attributes.setNamedItem(newAttr); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  使用attributes对象来操作元素节点的特性与直接使用getAttribute(), setAttribute(), removeAttribute()效果一致，attributes的方法可以找到别的简单的替代者；\n 针对attributes对象中的特性，不同浏览器返回的顺序不同；IE7会将没有指定的特性一并返回，需要使用NamedNodeMap中节点的specified属性检测是否为已定义特性\nconsole.log(_div.attributes[1].specified); // 输出：true或false\n 最佳实践：只使用attributes属性对象来遍历元素的特性：\n  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function outputAttributes(element){ var attrs = new Array(), attrName, attrValue, i, len; for(i = 0, len=element.attributes.length; i\u0026lt;len; i++){ attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; if(element.attributes[i].specified){ attrs.push(attrName + \u0026#39;=\\\u0026#34;\u0026#39; + attrValue + \u0026#39;\\\u0026#34;\u0026#39;); } } return attrs.join(\u0026#34; \u0026#34;); } var _div = document.getElementById(\u0026#34;123\u0026#34;); console.log(outputAttributes(_div)); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 创建元素  document.createElement()传入参数为标签名（小写）：  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.createElement(\u0026#34;div\u0026#34;); _div.className = \u0026#39;div\u0026#39;; _div.innerHTML = \u0026#39;Hi!\u0026#39;; document.body.appendChild(_div); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  可以创建自定义的非标准标签，例如：\ndocument.createElement(\u0026#34;abc\u0026#34;);   在IE8及以下可以传入整个元素标签，包括属性、content等，其他浏览器不支持；兼容性写法：  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; if(document.documentMode \u0026amp;\u0026amp; document.documentMode \u0026lt;= 8){ var div = document.createElement(\u0026#39;\u0026lt;div class=\\\u0026#34;demo\\\u0026#34;\u0026gt;Content\u0026lt;/div\u0026gt;\u0026#39;); }else{ var div = document.createElement(\u0026#39;div\u0026#39;); div.calssName = \u0026#39;div\u0026#39;; div.innerHTML = \u0026#39;Content\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  元素的子节点  不同的浏览器对待元素间的空白符的解析不同。低版本IE会忽略元素之间的无用的空白符，其他浏览器会将空白符视作一个文本节点；\n 需要对元素的childNodes进行操作时，通常先检测一下nodeType属性：\n  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;123\u0026#34; style=\u0026#34;height: 20px;\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var element = document.getElementById(\u0026#34;123\u0026#34;); for(var i=0; i\u0026lt;element.childNodes.length; i++){ if(element.childNodes[i].nodeType == 1){ // do something  } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 元素尺寸与位置  关于滚动条： 页面的滚动条是属于html元素的，而不是body元素的 滚动条的宽度是包含在元素的宽度里面的 document.documentElement.clientTop和document.documentElement.clientLeft访问的是盒子上边框和左边框的值；\n ","href":"/post/20190529160524/","title":"javascript Element类型"},{"content":" 传入参数对应的ID的元素不存在，返回null； 传入参数大小写需与实际元素id特性严格匹配； 多个元素的id特性相同，方法返回文档中第一次出现的那个；  ","href":"/post/20190529111342/","title":"getElementById()的注意事项"},{"content":" 文档的子节点  使用documentElement属性快捷访问页面的元素； 使用body属性可以快捷的访问页面的元素; doctype属性可在部分浏览器下访问文档的类型声明；各个浏览器对于文档声明的支持方式存在较大差异：IE8-:文档类型声明被解释为一个注释，当做comment节点，document.doctype返回值为null；大部分浏览器：文档类型声明作为文档的第一个子节点，是一个DocumentType节点，可以通过document.doctype, document.childNodes[0], document.firstChild访问  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; console.log(document.doctype); // 输出: \u0026lt;!DOCTYPE html\u0026gt;  console.log(document.childNodes[0]); // 输出: \u0026lt;!DOCTYPE html\u0026gt;  console.log(document.firstChild); // 输出: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  各个浏览器对于元素外的注释的解析方式不同，比如  \u0026lt;!--第一条注释--\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; console.log(document.childNodes.length); // chrome输出: 3 \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!--第二条注释--\u0026gt; 部分浏览器会为两个注释都建立注释节点，部分浏览器会忽略第二条，只为第一条创建注释节点，大部分浏览器现在回完全忽略第二条注释，比如这里的chrome。\n文档信息  title属性用于便捷读写title标签； URL属性只读，referrer属性只读； domain属性可读可写，但不能设置为当前URL中不包含的域，通过设置domain属性相同可实现框架间不同子域页面的JavaScript通信； document.domain只能往上级域名方向设置，设置为非上级域名会报错，不能设置为顶级域名; 使用document.domain实现跨父子域  查找元素  getElementById()的注意事项; getElementByTagName() 方法返回的是HTMLCollection对象；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; console.log(document.getElementsByTagName(\u0026#34;div\u0026#34;) instanceof HTMLCollection); // 输出：true  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  HTMLCollection对象类似NodeList对象； HTMLCollection对象可以使用namedItem()方法通过元素的name取得特定的项，或者更简单的，直接方括号+name访问特定元素；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div name=\u0026#34;123\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _div = document.getElementsByTagName(\u0026#34;div\u0026#34;); console.log(_div.namedItem(\u0026#34;123\u0026#34;)); console.log(_div[\u0026#34;123\u0026#34;]); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  getElementsByTagName(\u0026quot;*\u0026quot;)可以获得文档中所有的元素[旧版本IE将注释(comment)实现为元素(Element),在IE中使用getElementsByTagName()查询会返回注释节点]\n getElementsByName()常用于取得表单元素；\n getElementByClassName()在IE8及以下不支持。\n  特殊集合 其他作为document对象属性的HTMLCollection对象：\ndocument.anchors; document.forms; document.images; document.links;  DOM一致性检测 浏览器实现DOM的范围有多有少，document对象属性docment.implementation是提供相应的信息和功能的对象，该对象在DOM1级的规范下规定了一个方法：hasFeature()，接受两个参数：要检测的DOM功能的名称和版本号，返回值为布尔值；\nvar hasXmlDom = document.implementation.hasFeature(\u0026#39;XML\u0026#39;, \u0026#39;1.0\u0026#39;);   限制：只是检测支不支持（部分）DOM功能（并且浏览器厂商自己说了算），不一定遵守规范\n 文档写入 四个方法：write(str), writeln(str), open(), close()\n writeln()与write()的不同是会在字符串的末尾添加一个换行符\u0026rdquo;\\n\u0026rdquo;； write()和writeln()用于动态地包含外部脚本时，需要对\u0026lt;/script\u0026gt;做转移处理，否则会导致字符串被解释为脚本块执行，后面的代码块无法执行；正确写法如下：  \u0026lt;script\u0026gt; document.write(\u0026#39;\u0026lt;script type=\\\u0026#34;text\\/javascript\\\u0026#34; src=\\\u0026#34;file.js\\\u0026#34;\\\u0026#34;\u0026gt;\u0026#39; + \u0026#39;\u0026lt;\\/script\u0026gt;\u0026#39;); \u0026lt;/script\u0026gt;  在文档加载结束后调用document.write()输出的内容会重写整个页面；\n open()和close()分别用于打开和关闭网页的输出流；\n 最佳实践：避免使用document.write()\n  ","href":"/post/20190529094341/","title":"Document类型"},{"content":"","href":"/tags/document%E7%B1%BB%E5%9E%8B/","title":"document类型"},{"content":"   名称 快捷键     上下移动行 Alt(option) + 上下键   删除行 Ctrl(command) + Shift( \\( \\Uparrow \\) ) + K    持续更新中\u0026hellip;\n","href":"/post/20190528191941/","title":"vs code快捷键大全"},{"content":" Dcoment表示文档，这里的文档可以是HTML文档，也可以是XML文档，换句话说Document类型能表示HTML和XML等文档； HTMLDocument对象继承自Document对象，专用于表示HTML文档； document对象是HTMLDocument对象的一个实例，表示整个HTML页面，又叫做页面的根节点；  Document对象（根节点）的特征：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; console.log(document.nodeType); console.log(document.nodeName); console.log(document.nodeValue); console.log(document.parentNode); console.log(document.ownerDocument); console.log(document.childNodes); // 其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;","href":"/post/20190528111913/","title":"Document类型、HTMLDocument类型和document对象的区别"},{"content":"","href":"/tags/document/","title":"document"},{"content":"举例说明：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt; 123 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 456 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 789 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _childNodes = document.getElementById(\u0026#34;ul\u0026#34;).childNodes; function convertToArray(nodes) { var array = null; try { array = Array.prototype.slice.call(nodes, 0); // 针对非IE浏览器  } catch (ex) { array = new Array(); for (var i = 0, len = nodes.length; i \u0026lt; len; i++) { array.push(nodes[i]); } } return array; } console.log(convertToArray(_childNodes)); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;","href":"/post/20190528101901/","title":"Javascript-DOM中NodeList对象转数组的通用方法"},{"content":"","href":"/tags/dom/","title":"dom"},{"content":"","href":"/tags/arguments%E8%BD%AC%E6%95%B0%E7%BB%84/","title":"arguments转数组"},{"content":"","href":"/tags/function/","title":"function"},{"content":"举例说明:\nfunction arr(){ console.log(arguments); // 输出：[Arguments] { \u0026#39;0\u0026#39;: 1, \u0026#39;1\u0026#39;: 2, \u0026#39;2\u0026#39;: 3 }  _array = Array.prototype.slice.apply(arguments); console.log(_array); // 输出：[ 1, 2, 3 ] } arr(1, 2, 3) ","href":"/post/20190528095304/","title":"function中的arguments转数组的标准方法"},{"content":"  DOM1级定义了一个Node接口，该接口作为Node类型实现;  // 节点类型（nodeType）1~12 Node.ELEMENT_NODE; // 1 Node.ATTRIBUTE_NODE; // 2 Node.TEXT_NODE; // 3 Node.CDATA_SECTION_NODE; // 4 Node.ENTITY_REFERENCE_NODE; // 5 Node.ENTITY_NODE; // 6 Node.PROCESSING_INSTRUCTION_NODE; // 7 Node.COMMENT_NODE; // 8 Node.DOCUMENT_NODE; // 9 Node.DOCUMENT_TYPE_NODE; // 10 Node.DOCUMENT_FRAGMENT_NODE; // 11 Node.NOTATION_NODE; // 12   JavaScript中所有节点类型都继承自Node类型，所有的节点类型都共享相同的基本属性和方法；\n 最佳实践：对节点进行操作时，最好使用nodeType检测节点的类型;\n  nodeName和nodeValue 对于元素节点(nodeType === 1)，nodeName是元素标签名的大写，nodeValue的值始终是null;\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;ele\u0026#34;\u0026gt; some text \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var ele = document.getElementById(\u0026#34;ele\u0026#34;); console.log(ele.nodeType === 1); // 输出：true  console.log(ele.nodeName); // 输出：DIV  console.log(ele.nodeValue); // 输出：null  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 节点关系  节点关系可以用传统的家族关系来表示，文档树可以看做家谱； 节点的childNodes属性保存的是一个NodeList对象；  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt; 123 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 456 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 789 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var ul = document.getElementById(\u0026#34;ul\u0026#34;); console.log(ul.childNodes instanceof NodeList); // 输出：True  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  NodeList是一种类数组对象，但不是Array的实例，用于保存一组有序的节点，因为是基于DOM结构动态执行查询的结果，所以NodeList对象是动态变化的（例如length属性） NodeList中节点的访问方法：  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt; 123 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 456 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 789 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _childNodes = document.getElementById(\u0026#34;ul\u0026#34;).childNodes; console.log(_childNodes[3]); // 方法1  console.log(_childNodes.item(3)); // 方法2  \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  NodeList对象转数组的通用方法：详见Javascript-DOM中NodeList对象转数组的通用方法\n previousSibling, nextSibling, previousElementSibling, nextElementSibling, firstChild, lastChild, firstElementChild, lastElementChild 如果以上属性没有指向，则返回null\n children可以过滤所有其他节点类型，返回所有元素类型的子节点：\n  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt; 123 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 456 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 789 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var _children = document.getElementById(\u0026#34;ul\u0026#34;).children; console.log(_children); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  hasChildNodes() 方法用于检测是否含有该子节点\n ownerDocument 属性指向于整个文档的文档节点，每个节点都有这个属性；\n  节点的操作  appendChild()新增节点：  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt; 123 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 456 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 789 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var ul = document.getElementById(\u0026#34;ul\u0026#34;); var newLi = document.createElement(\u0026#34;li\u0026#34;); ul.appendChild(newLi); console.log(ul.childNodes.length); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  insertBefore() 包含两个参数，顺序分别是：要插入的节点和参照的节点，返回被插入的节点；\n replaceChild(), removeChild() 返回的是被替换、移除的节点 ，被替换和移除的节点仍然在文档中存在，只不过没有了位置。\n 在不支持子节点的节点上调用上面提到的子节点的方法，会导致错误的发生；\n  其他方法  cloneNode() 创建调用这个方法的节点的一个完全相同的副本，当传入可选布尔参数为true时，将执行深拷贝； cloneNode() 不会拷贝添加到DOM节点中的Javascript属性，例如事件处理程序；IE浏览器会连带事件处理程序一起拷贝； 最佳实践：在cloneNode()之前先移除事件处理程序； normalize()的作用：处理文档树中的文本节点，它会删除空文本节点，合并相邻的两个文本节点。  ","href":"/post/20190527223544/","title":"DOM-Node基本类型"},{"content":"var Tv = { open: function(){ console.log(\u0026#39;打开电视机\u0026#39;); }, close: function(){ console.log(\u0026#39;关上电视机\u0026#39;); }, }; var OpenTvCommand = function(receiver){ this.receiver = receiver; }; OpenTvCommand.prototype.execute = function(){ this.receiver.open(); // 执行命令，打开电视机 }; OpenTvCommand.prototype.undo = function(){ this.receiver.close(); // 撤销命令，关闭电视机 }; command = new OpenTvCommand(Tv); command.execute() // 输出：打开电视机 command.undo() // 输出：关上电视机  博客参考自JavaScript设计模式与开发实践，[p41-p42]\n","href":"/post/20190527140401/","title":"用闭包实现命令模式"},{"content":"","href":"/tags/%E9%97%AD%E5%8C%85/","title":"闭包"},{"content":"下面这段是闭包的代码：\nvar extent = function(){ var value = 0; return { call: function(){ value++; console.log(value); } } }; var extent = extent(); extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3  转换成面向对象的写法是：\nvar extent = { value: 0, call: function(){ this.value++; console.log(this.value); } }; extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3  原型链写法：\nvar extent = function(){ this.value = 0; }; Extent.prototype.call = function(){ this.value++; console.log(this.value); } var extent = new Extent(); extent.call(); extent.call(); extent.call();  博客参考自JavaScript设计模式与开发实践，[p40-p41]\n","href":"/post/20190527113008/","title":"闭包和面向对象设计的等价实现举例"},{"content":"","href":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":" 闭包的两个知识点：  变量搜索方向：在javascript中，函数可以创造函数作用域。在函数作用域里面可以看到外面的变量，而函数的外面无法访问到函数里面的变量。因此，在作用域里面的变量搜索方向是：自内向外。比如，下面这段代码就验证了这个搜索方向：  var a = 1; var func1 = function(){ var b = 2; var func2 = function(){ var c = 3; console.log(b); // 输出：2  console.log(a); // 输出：1  } func2(); console.log(c); // 输出：Uncaught ReferenceError: c is not defined }; func1();   变量的生存的周期：全局变量的生存周期是永久的，局部变量随着函数调用的结束而销毁。  // 例一 var func = function(){ var a = 1; // 退出函数后局部变量a将被销毁  console.log(a); }; func(); // 例二 var func = function(){ var a = 1; return function(){ a++; console.log(a); } } var f = func(); f(); // 输出：2 f(); // 输出：3 f(); // 输出：4 f(); // 输出：5  闭包举例 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var nodes = document.getElementsByTagName(\u0026#39;div\u0026#39;); for(var i=0, len = nodes.length; i \u0026lt; len; i++){ (function(i){ nodes[i].onclick = function(){ alert(i); }; })(i); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; var Type = {}; for(var i=0, type; type=[\u0026#39;String\u0026#39;, \u0026#39;Array\u0026#39;, \u0026#39;Number\u0026#39;][i++]; ){ (function(type){ Type[\u0026#39;is\u0026#39; + type] = function(obj){ return Object.prototype.toString.call(obj) === \u0026#39;[object \u0026#39;+ type +\u0026#39;]\u0026#39;; } })(type); } console.log(Type.isArray([])); // 输出: true console.log(Type.isString(\u0026#34;str\u0026#34;)); // 输出: true  闭包的作用  封装变量：我们通过一个计算乘积的简单函数来介绍，这个计算函数加入缓存机制，来提高函数的而运行性能，然而cache处于全局作用域下面，但是只被mult函数使用。  var cache = {}; var mult = function(){ var args = Array.prototype.join.call(arguments, \u0026#39;,\u0026#39;); if(cache[args]){ return cache[args]; } var a = 1; for(var i = 0, l = arguments.length; i \u0026lt; l; i++){ a = a * arguments[i]; } return cache[args] = a; }; console.log(mult(1, 2, 3)); // 输出：6 console.log(mult(1, 2, 3)); // 输出：6  为了避免这个变量在其他地方被不小心修改而引发错误，我们把cache加入到函数作用域下面，用闭包封装起来，具体代码如下：\nvar mult = (function(){ var cache = {}; return function(){ var args = Array.prototype.join.call(arguments, \u0026#39;,\u0026#39;); if(args in cache){ return cache[args]; } var a = 1; for(var i = 0, l = arguments.length; i \u0026lt; l; i++){ a = a * arguments[i]; } return cache[args] = a; } })(); mult(1, 2, 3); // 输出：6  从上面我们可以看出，计算乘积的部分可以独立出来，提炼函数是代码重构的一种常见技巧，独立出来的小函数由于不需要在其他位置使用，我们可以使用闭包封装起来，代码如下：\nvar mult = (function () { var cache = {}; var caculate = function () { // 封闭caculate函数  var a = 1; for (var i = 0, l = arguments.length; i \u0026lt; l; i++) { a = a * arguments[i]; } return a; } return function () { var args = Array.prototype.join.call(arguments, \u0026#39;,\u0026#39;); if (args in cache) { return cache[args]; } return cache[args] = caculate.apply(null, arguments); } })(); console.log(mult(1, 2, 3)); console.log(mult(1, 2, 3));   延续局部变量的寿命： 我们通过一个数据上报的例子来说明这种情况。  var report = function(src){ var img = new Image(); img.src = src; }; report(\u0026#39;http://xxx.com/getUserInfo\u0026#39;);  由于浏览器的兼容性问题，在report函数进行上报之前就会丢失30%左右的数据，由于report函数的http请求并不是每次都有效的。导致这个问题的根本原因在于img是局部变量，img变量随着report函数的结束而销毁。通过闭包可以解决这个bug。代码如下:\nvar report = (function(src){ var imgs = []; return function(src){ var img = new Image(img); imgs.push(img); img.src = src; } })(); report(\u0026#39;http://xxx.com/getUserInfo\u0026#39;);  上面代码中的imgs依靠report这个全局变量而存在，而之前的report是一个函数变量，里面的变量随着函数结束而结束。\n本篇博客参考自JavaScript设计模式与开发实践，[p35-p40]\n","href":"/post/20190527104504/","title":"javascript闭包详解"},{"content":"","href":"/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA/","title":"交换机"},{"content":" 网卡扩展坞由于带电会影响交换机，导致局域网断网  持续更新\u0026hellip;\n","href":"/post/20190527102625/","title":"交换机断网的原因分析"},{"content":"","href":"/tags/%E6%96%AD%E7%BD%91/","title":"断网"},{"content":"","href":"/categories/%E7%BD%91%E7%BB%9C/","title":"网络"},{"content":" 在非严格模式下：  主要通过arguments.callee实现递归，它是一个指向正在执行的函数的指针。\n function factorial(num){ if(num \u0026lt;= 1){ return 1; }else{ return num * arguments.callee(num - 1); } }  在严格模式下：  虽然访问arguments.callee这个属性会导致错误，但是可以使用函数表达式来达成相同的结果。\n var factorial = function f(num){ if(num \u0026lt;= 1){ return 1; }else{ return num * f(num-1); } };  本篇博客参考自JavaScript高级程序设计，[p177-p178]\n","href":"/post/20190522223920/","title":"javascript函数递归实现"},{"content":"","href":"/tags/array.prototype.push/","title":"Array.prototype.push"},{"content":"","href":"/tags/v8%E5%BC%95%E6%93%8E/","title":"v8引擎"},{"content":" 具体实现如下： function ArrayPush(){ var n = TO_UINT32(this.length); // 被push的对象的length  var m = %_AraumentsLength(); // push的参数个数  for(var i=0; i\u0026lt;m; i++){ this[i+n] = %_Arguments(i); // 复制元素 （1）  } this.length = n + m; // 修正length属性的值  return this.length; }   从上面的代码可以看出，Array.prototype.push实际上是一个属性复制的过程，把参数按照下标依次添加到被push的对象上面，同时修改了对象的length属性，不需要关注被修改的对象是数组还是类数组。 因此，我们可以把任意类型的对象传入到Array.prototype.push中，比如下面这个例子：\n var a = {}; Array.prototype.push.call(a, \u0026#34;first\u0026#34;, \u0026#34;second\u0026#34;); console.log(a);   观察上面这个例子我们发现如果要实现javascript中call和apply的区别与联系中\u0026rdquo;借用其他对象的方法\u0026rdquo;，需要满足下面的条件：\n 对象本身可以存取属性；\n 对象的length属性可读写；\n   本篇博客参考自JavaScript设计模式与开发实践，[p33-p34]\n","href":"/post/20190522211458/","title":"v8引擎源码—Array.prototype.push实现详解"},{"content":" apply接收两个参数：  指定了函数体内this对象的指向； 一个带下标的集合（可以是数组或类数组）   var func = function(a, b, c){ console.log([a, b, c]); // 输出[1, 2, 3] } func.apply(null, [1, 2, 3]);  call接收一个或多个参数：  指定了函数体内this对象的指向； 从第二个参数往后，每个参数被依次传入函数；   var func = function(a, b, c){ console.log([a, b, c]); // 输出[1, 2, 3] } func.call(null, 1, 2, 3);   从上面的两个例子我们可以看出apply和call的唯一的区别就是：传入参数的数量是否固定。通常call在以下情况使用：  函数传入的参数数量确定； 需要清晰地表达形参和实参之间的对应关系  apply和call使用注意点：  如果传入的第一个参数是null，this就会指向全局对象，在浏览器上面是window，在nodejs上是global; 在1的条件下，如果使用严格模式，函数体内的this还是为null;   var func = function(a, b, c){ \u0026#34;use strict\u0026#34;; console.log(this === null); // 输出true } func.apply(null, [1, 2, 3]);  apply和call的用途：  借用其他对象的方法：  // 例一 Math.max.apply(null, [1, 2, 5, 3, 4]); // 输出5  // 例二 var A = function(name){ this.name = name; }; var B = function(){ A.apply(this, arguments); }; B.prototype.getName = function(){ return this.name; }; var b = new B(\u0026#39;sven\u0026#39;); console.log(b.getName()); // 输出：\u0026#39;sven\u0026#39;   改变this的指向：  var obj1 = { name: \u0026#39;sven\u0026#39;, }; var obj2 = { name: \u0026#39;anne\u0026#39;, }; global.name = \u0026#39;global\u0026#39;; var getName = function(){ console.log(this.name); } getName(); // 输出：global getName.call(obj1); // 输出：sven getName.call(obj2); // 输出: anne   Function.prototype.bind的模拟实现：   // 简单实现 Function.prototype.bind = function(context){ var self = this; return function(){ return self.apply(context, arguments); } } var obj = { name: \u0026#39;sven\u0026#39;, } var func = function(){ console.log(this.name); // 输出：sevn }.bind(obj); func(); // 复杂实现 Function.prototype.bind = function(){ var self = this, context = [].shift.call(arguments), args = [].slice.call(arguments); return function(){ return self.apply(context, [].concat.call(args, [].slice.call(arguments))); } } var obj = { name: \u0026#39;sven\u0026#39;, }; var func = function(a, b, c, d){ console.log(this.name); // 输出：sven  console.log([a, b, c, d]); // 输出：[1, 2, 3, 4] }.bind(obj, 1, 2); func(3, 4);  本篇博客参考自JavaScript设计模式与开发实践，[p29-p33]\n","href":"/post/20190522204729/","title":"javascript中call和apply的区别与联系"},{"content":" ES5  this的指向分为4种：\n 隐式的this指向  作为对象的方法调用，this指向的是当前对象\n var obj = { a: 1, getA: function(){ console.log(this == obj); // true  console.log(this.a); // 1  } } obj.getA();  硬指定的this  作为普通函数调用，this指向的是全局对象\n name = \u0026#39;globalName\u0026#39;; var getName = function(){ console.log(this == window); console.log(name); }; getName();  或者 将对象的方法加入全局对象中，会改变原本的this指向\nname = \u0026#39;globalName\u0026#39;; var myObject = { name: \u0026#34;sven\u0026#34;, getName: function(){ console.log(this == window); console.log(this.name); } } var getName = myObject.getName; //主要是这一句 getName(); //globalName   当this在普通函数里面被用到时，this指向的是一个全局对象，在浏览器上是window，在nodejs上是global\n 构造函数调用  构造函数的外表和普通函数一样，它们主要区别于调用的方式，构造函数需要用 new运算符，在这里this指向的是一个局部对象，即这个返回的对象\n var MyClass = function(){ console.log(this == window); this.name = \u0026#34;sven\u0026#34;; } var obj = new MyClass(); console.log(obj.name);    apply、call和bind  Function.prototype.call或Function.prototype.apply的调用，与普通函数不一样，call和apply可以动态地修改this的指向，bind也一样，只不过bind不是立刻执行的\n var obj1 = { name: \u0026#39;sven\u0026#39;, getName: function(){ console.log(this); console.log(this.name); } }; var obj2 = { name: \u0026#39;anne\u0026#39;, }; obj1.getName(); //输出：sven obj1.getName.call(obj2); //输出：anne var getName = obj1.getName; // 把对象函数的方法加入到全局作用域中，对象的属性无法访问 getName = getName.bind(obj1); // 使用bind方法把这个方法绑定到obj1上 getName();  博客内容参考自JavaScript设计模式与开发实践，[p24-p27]\nES6 箭头函数内部的this指向动态变化  因为箭头函数内部的this后一直会向上级作用域进行查找 也因为这个原因，它不可以使用在Vue的选项属性或者回调函数中\n 比如下面的例子\n 上级是全局作用域 \u0026gt; 上级就是全局作用域，所以this指向全局作用域  var a = () =\u0026gt; { console.log(this == window); } a();   上级是局部作用域  var name= \u0026#34;全局\u0026#34;; var test = (callback) =\u0026gt; { var name = \u0026#34;局部\u0026#34;; (() =\u0026gt; { console.log(this.name); // 局部  })(); } test(); ","href":"/post/20190522152759/","title":"javascript中的this"},{"content":"","href":"/tags/this/","title":"this"},{"content":" 原生实现\n function Person(name){ this.name = name; }; Person.prototype.getName = function(){ return this.name; } var a = new Person(\u0026#39;sven\u0026#39;); console.log(a.name); console.log(a.getName()); console.log(Object.getPrototypeOf(a) === Person.prototype);  代码实现\nfunction Person(name){ this.name = name; }; Person.prototype.getName = function(){ return this.name; } var objectFactory = function(){ var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === \u0026#34;object\u0026#34; ? ret: obj; } var a = objectFactory(Person, \u0026#34;sven\u0026#34;); console.log(a.name); console.log(a.getName()); console.log(Object.getPrototypeOf(a) === Person.prototype);   下面的代码可以实现原生的效果，参考自JavaScript设计模式与开发实践，[p18-p20]\n ","href":"/post/20190522102308/","title":"js通过代码来理解构造函数的实现过程"},{"content":" 语法：  Object.create(proto, [propertiesObject])\n//方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。\n 参数：   proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是null， 对象， 函数的prototype属性 （创建空的对象时需传null , 否则会抛出TypeError异常）。 propertiesObject : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。  3 返回值：\n在指定原型对象上添加新属性后的对象。\n 案例说明：  1）创建对象的方式不同\nnew Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。\nObject.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。\n// new Object() 方式创建 var a = { rep : \u0026#39;apple\u0026#39; }; var b = newObject(a); console.log(b); // {rep: \u0026#34;apple\u0026#34;} console.log(b.__proto__); //{} console.log(b.rep); // {rep: \u0026#34;apple\u0026#34;} // Object.create() 方式创建 var a = { rep: \u0026#39;apple\u0026#39; }; var b = Object.create(a); console.log(b); // {} console.log(b.__proto__);// {rep: \u0026#34;apple\u0026#34;} console.log(b.rep); // {rep: \u0026#34;apple\u0026#34;}  Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: \u0026ldquo;apple\u0026rdquo;} ,\n此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。\n2）创建对象属性的性质不同\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象 o = Object.create({}, { p: { value: 42 } }) //省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的: o.p = 24; o.p; //42 o.q = 12 for(var prop in o) { console.log(prop) } //\u0026#34;q\u0026#34; delete o.p //false  Object.create()用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。\n3）创建空对象时不同\n当用构造函数或对象字面量方法创建空对象时，对象时有原型属性的，即有_proto_;\n当用Object.create()方法创建空对象时，对象是没有原型属性的。\n4）__proto__ 属性\nJavaScript 的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。\n__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前只有浏览器环境必须部署有这个属性，其他运行环境不一定要部署，因此不建议使用这个属性，而是使用下面这些来Object.setPrototypeOf()（写操作）、 Object.getPrototypeOf() （读操作）、 Object.create()（生成操作）代替。\n Object.create()  描述：该方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__；\n格式：Object.create(proto[, propertiesObject])\n用法：如果用传统的方法要给一个对象的原型上添加属性和方法，是通过 __propt__实现的\nvar o = {}; o.prototype.y = 20; o.__proto__.showNum = function(){ }  现在有 Object.create() 就简单的多了。\nvar proto = { y: 20, z: 40, showNum(){}}; var o = Object.create(proto);   Object.setPrototypeOf  描述：该方法的作用与 __proto__ 相同，用来设置一个对象的 prototype 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。\n格式：Object.setPrototypeOf(object, prototype)\n用法：\nvar proto = { y: 20, z: 40}; var o = { x: 10 }; Object.setPrototypeOf(o, proto);  输出结果中看出，添加的方法是在原型上的。就类似于\nobj.__proto__ = proto;   Object.getPrototypeOf()  描述：用于读取一个对象的原型对象；\n格式：Object.getPrototypeOf(obj);\n用法：\nObject.getPrototypeOf(\u0026#39;foo\u0026#39;) === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true  4.1）原型属性的继承\n这里结合一个例子来说说这几个方法的使用：\n场景：拷贝一个构造函数的实例。\nvar triangle = {a: 1, b: 2, c: 3}; functionColoredTriangle() { this.color = \u0026#39;red\u0026#39;; } ColoredTriangle.prototype = triangle; ColoredTriangle.prototype.constructor === ColoredTriangle falseObject.assign(ColoredTriangle.prototype, triangle) ColoredTriangle.prototype.constructor === ColoredTriangle truevar c = new ColoredTriangle();  打印出 实例c 看看结构是怎样的\n其中 color 属性在实例上，而其他的原型上。\n现在来拷贝一个 实例 c2\nvar c2 = Object.assign({},c); console.log(c2.color); // redconsole.log(c2.a); //undefined  因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。那要怎么要才能拷贝到原型上的方法呢？\n4.1.1）第一种方法\nvar originProto = Object.getPrototypeOf(c); var originProto2 = Object.create(originProto); var c2 = Object.assign(originProto2, c); var c2 = Object.assign(Object.create(Object.getPrototypeOf(c)), c) console.log(c2.color); // red console.log(c2.a); //1  这样就实现了原型属性的拷贝。\nObject.getPrototypeOf(c) 既 originProto 得到的是原型上的 //{a: 1, b: 2, c: 3}；\nObject.create(originProto) 既 originProto2 既是创建了一个 {a: 1, b: 2, c: 3} 在原型上的新对象；\nObject.assign(originProto2, c) 在源对象originProto2 上合并对象 c；\n4.1.2）第二种方法 （推荐）\nvar c = new ColoredTriangle(); var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); console.log(c2.color); //red console.log(c2.a); // 1  可以把Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。\n所以上面例子\nObject.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。\nObject.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。\n为什么说推荐这个方法呢？ 因为Object.assign() 方法不能正确拷贝 get ，set 属性。\n例如，我们给 c 实例添加一个 \u0026ldquo;colorGet\u0026rdquo; 属性，并设置该属性的get 描述符：\nvar c = new ColoredTriangle(); Object.defineProperty( c,\u0026#39;colorGet\u0026#39;, {enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性  get(){ return \u0026#34;Could it return \u0026#34; + this.color; } } ); var c3 = Object.assign( Object.create(Object.getPrototypeOf(c)), c )  这里没有拷贝到 \u0026ldquo;colorGet\u0026rdquo; 的 get 描述符，而是直接把获取到的值赋值给 \u0026ldquo;colorGet\u0026rdquo; 。\n那对于 get 描述符要怎么获取呢？ Object.getOwnPropertyDescriptors就专为解决这问题而生。\n而又因为要拷贝原型上的属性，所以结合Object.create、Object.getPrototypeOf 方法一起使用。即上面的第二种实现方法，如下：\nvar c = new ColoredTriangle(); Object.defineProperty( c,\u0026#39;colorGet\u0026#39;, { enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性  get(){ return \u0026#34;Could it return \u0026#34; + this.color } } ); var c3 = Object.create( Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c) );  此时已经成功的拷贝到了get描述符啦。\n虽然说实际开发上很少会要去修改 get 描述符，但是知道多一种方法，遇到这种情况时就知道该怎么去解决了。\n注意：这些都只是一个层级的深拷贝。\n上面实现 原型属性拷贝 中的两种方法中用到了 Object.getOwnPropertyDescriptors 、 Object.assing() 、Object.create、Object.getPrototypeOf()方法，通常这几种方法都有一起结合使用。\n如果上面的例子还不理解，这里把他简单的拿到 对象的继承 来讲解。理解的话就可以忽略啦。\n4.2）原型属性的继承\n以前，继承另一个对象，常常写成下面这样。\nconst obj = { __proto__: prot, foo: 123,};  ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，可以用 Object.create() 和Object.assign() 来实现。\n//现在可以这样写 方法1 const obj = Object.create(prot); obj.foo = 123; // 或者 方法2 const obj = Object.assign( Object.create(prot), { foo: 123, } ); // 或者 方法3 const obj = Object.create( prot,Object.getOwnPropertyDescriptors({ foo: 123 }) );  但是 Object.assign() 无法正确拷贝get属性和set属性的问题。例如：\nvar prot = {x: 1, y: 2}; var obj = { __proto__: prot, foo: 100, bar(){ return this.foo}, get baz() {return this.foo}}; var obj2 = Object.assign(Object.create(prot), obj)  上图中，obj 对象的 foo 属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值赋上去。\n而 Object.getOwnPropertyDescriptors() 可以解决这个问题 实现get 、set 属性的正确拷贝，即方法3 ，如下：\nvar prot = {x: 1, y: 2}; var obj = { __proto__: prot, foo: 100, bar(){ returnt his.foo}, get baz() {return this.foo} }; var obj2 = Object.create( prot, Object.getOwnPropertyDescriptors(obj) )  说了那么多种拷贝方法，怎么去选择呢，还是要看实际应用中的情况:\n如果只是拷贝 自身可枚举属性，就可以只用 Object.assign 方法；\n如果是要拷贝原型上的属性，就需要 Object.assign , Object.create, Object.getPrototypeOf 方法结合使用\n如果是拷贝get /set 属性，就需要 结合 Ojbect.getOwnPropertyDescriptors 方法\n参考资料：\n MDN 阮一峰：es6对象的新增方法  ","href":"/post/20190522093759/","title":"js: new Object()与Object.create()的区别"},{"content":" result = 变量 instanceof 数据类型; //ECMAScript 提供了 instanceof 操作符来检测引用类型   Array,Regex和Date等引用数据类型都是Object的实例，因此\u0026rdquo;instanceof\u0026rdquo;返回的都是\u0026rdquo;object\u0026rdquo;\n ","href":"/post/20190520112215/","title":"js 引用类型的判断"},{"content":" Function不介意传入多少个参数，也不在乎传入参数的类型（参数在内部使用数组来表示，在函数内部可以通过arguments访问）； Function没有重载 Function传入的参数只能按值传递(即使传入的是引用类型)，详细请看js Function 参数按值传递详解 Function可以设置默认参数，比如：  function randomNum(max=100, start=33){ return Math.floor(Math.random() * max + start) } console.log(randomNum(1000, 33)); ","href":"/post/20190520110931/","title":"js Function详解"},{"content":"  如果传入参数是基本数据类型，那么按值传递是很容易理解的； 如果传入参数是引用数据类型，那么会很容易陷入误区，错误地认为是引用传递；   错误例子一：\nfunction setColor(obj){ obj.color = \u0026#34;red\u0026#34;; } var picture = new Object(); setColor(picture); console.log(picture); //\u0026#34;red\u0026#34;  看到上面这个例子后，很容易认为：”函数的值是传入了引用，然后通过引用修改了对象的属性。“\n纠正例子二：\nfunction setColor(obj){ obj.color = \u0026#34;red\u0026#34;; obj = new Object(); obj.color = \u0026#34;blue\u0026#34;; } var picture = new Object(); setColor(picture); console.log(picture.color); //\u0026#34;red\u0026#34;  我们发现，如果函数传入的是引用，那么在函数内部的修改picture的引用就会对象把指向color为”blue“的对象；但是根据输出的结果，很显然是错误；\n 结论：因此，不管函数传入的是什么数据类型，都是按值传递的。\n ","href":"/post/20190520110829/","title":"js Function 参数按值传递详解"},{"content":"| 数据类型 | typeof | 访问方式 | 包含关系 | 大小关系\n\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;\nUndefined | 基本 | \u0026ldquo;undefined\u0026rdquo; | 按值访问 | Undefined是null的一个子集 | Undefined=null\nnull(首字母小写) | \u0026ldquo;object\u0026rdquo; | null包含Undefined | null=Underfined\nBoolean | \u0026ldquo;boolean\u0026rdquo; | |\nNumber | \u0026ldquo;number\u0026rdquo; | |\nString(不是引用类型) | \u0026ldquo;string\u0026rdquo; | |\nObject | 复杂 | \u0026ldquo;object\u0026rdquo; | 按引用访问 | |\n","href":"/post/20190520102008/","title":"js 的6个数据类型"},{"content":"操作符两边操作数先转换数据类型，然后再比较它们的相等性，具体的规则如下：\n   操作符规则 操作符a的数据类型 操作符b的数据类型 == != 备注     Boolean转为Number — — — Boolean无条件转为Number类型   String转为Number Number — — —   Object转为a.valueOf() 除了Object之外的所有类型 — — —   null undefined true false null等于underfined   NaN — false true NaN不等于NaN   Object Object — — 如果a和b指向同一个对象，相等操作符返回true，否则返回false     上述表格归纳自javascript高级程序设计，[p51-p53]\n ","href":"/post/20190517165040/","title":"js 相等和不相等操作符总结"},{"content":"","href":"/tags/%E5%89%8D%E7%AB%AF/","title":"前端"},{"content":"","href":"/tags/jupyter/","title":"jupyter"},{"content":"","href":"/categories/jupyter/","title":"jupyter"},{"content":"# Configuration file for jupyter-notebook. #------------------------------------------------------------------------------ # Application(SingletonConfigurable) configuration #------------------------------------------------------------------------------ ## This is an application. ## The date format used by logging formatters for %(asctime)s #c.Application.log_datefmt = \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39; ## The Logging format template #c.Application.log_format = \u0026#39;[%(name)s]%(highlevel)s %(message)s\u0026#39; ## Set the log level by value or name. #c.Application.log_level = 30 #------------------------------------------------------------------------------ # JupyterApp(Application) configuration #------------------------------------------------------------------------------ ## Base class for Jupyter applications ## Answer yes to any prompts. #c.JupyterApp.answer_yes = False ## Full path of a config file. #c.JupyterApp.config_file = \u0026#39;\u0026#39; ## Specify a config file to load. #c.JupyterApp.config_file_name = \u0026#39;\u0026#39; ## Generate default config file. #c.JupyterApp.generate_config = False #------------------------------------------------------------------------------ # NotebookApp(JupyterApp) configuration #------------------------------------------------------------------------------ ## Set the Access-Control-Allow-Credentials: true header #c.NotebookApp.allow_credentials = False ## Set the Access-Control-Allow-Origin header #  # Use \u0026#39;*\u0026#39; to allow any origin to access your server. #  # Takes precedence over allow_origin_pat. #c.NotebookApp.allow_origin = \u0026#39;\u0026#39; ## Use a regular expression for the Access-Control-Allow-Origin header #  # Requests from an origin matching the expression will get replies with: #  # Access-Control-Allow-Origin: origin #  # where `origin` is the origin of the request. #  # Ignored if allow_origin is set. #c.NotebookApp.allow_origin_pat = \u0026#39;\u0026#39; ## Allow password to be changed at login for the notebook server. #  # While loggin in with a token, the notebook server UI will give the opportunity # to the user to enter a new password at the same time that will replace the # token login mechanism. #  # This can be set to false to prevent changing password from the UI/API. #c.NotebookApp.allow_password_change = True ## Allow requests where the Host header doesn\u0026#39;t point to a local server #  # By default, requests get a 403 forbidden response if the \u0026#39;Host\u0026#39; header shows # that the browser thinks it\u0026#39;s on a non-local domain. Setting this option to # True disables this check. #  # This protects against \u0026#39;DNS rebinding\u0026#39; attacks, where a remote web server # serves you a page and then changes its DNS to send later requests to a local # IP, bypassing same-origin checks. #  # Local IP addresses (such as 127.0.0.1 and ::1) are allowed as local, along # with hostnames configured in local_hostnames. #c.NotebookApp.allow_remote_access = False ## Whether to allow the user to run the notebook as root. #c.NotebookApp.allow_root = False ## DEPRECATED use base_url #c.NotebookApp.base_project_url = \u0026#39;/\u0026#39; ## The base URL for the notebook server. #  # Leading and trailing slashes can be omitted, and will automatically be added. #c.NotebookApp.base_url = \u0026#39;/\u0026#39; ## Specify what command to use to invoke a web browser when opening the notebook. # If not specified, the default browser will be determined by the `webbrowser` # standard library module, which allows setting of the BROWSER environment # variable to override it. #c.NotebookApp.browser = \u0026#39;\u0026#39; ## The full path to an SSL/TLS certificate file. #c.NotebookApp.certfile = \u0026#39;\u0026#39; ## The full path to a certificate authority certificate for SSL/TLS client # authentication. #c.NotebookApp.client_ca = \u0026#39;\u0026#39; ## The config manager class to use #c.NotebookApp.config_manager_class = \u0026#39;notebook.services.config.manager.ConfigManager\u0026#39; ## The notebook manager class to use. #c.NotebookApp.contents_manager_class = \u0026#39;notebook.services.contents.largefilemanager.LargeFileManager\u0026#39; ## Extra keyword arguments to pass to `set_secure_cookie`. See tornado\u0026#39;s # set_secure_cookie docs for details. #c.NotebookApp.cookie_options = {} ## The random bytes used to secure cookies. By default this is a new random # number every time you start the Notebook. Set it to a value in a config file # to enable logins to persist across server sessions. #  # Note: Cookie secrets should be kept private, do not share config files with # cookie_secret stored in plaintext (you can read the value from a file). #c.NotebookApp.cookie_secret = b\u0026#39;\u0026#39; ## The file where the cookie secret is stored. #c.NotebookApp.cookie_secret_file = \u0026#39;\u0026#39; ## Override URL shown to users. #  # Replace actual URL, including protocol, address, port and base URL, with the # given value when displaying URL to the users. Do not change the actual # connection URL. If authentication token is enabled, the token is added to the # custom URL automatically. #  # This option is intended to be used when the URL to display to the user cannot # be determined reliably by the Jupyter notebook server (proxified or # containerized setups for example). #c.NotebookApp.custom_display_url = \u0026#39;\u0026#39; ## The default URL to redirect to from `/` #c.NotebookApp.default_url = \u0026#39;/tree\u0026#39; ## Disable cross-site-request-forgery protection #  # Jupyter notebook 4.3.1 introduces protection from cross-site request # forgeries, requiring API requests to either: #  # - originate from pages served by this server (validated with XSRF cookie and # token), or - authenticate with a token #  # Some anonymous compute resources still desire the ability to run code, # completely without authentication. These services can disable all # authentication and security checks, with the full knowledge of what that # implies. #c.NotebookApp.disable_check_xsrf = False ## Whether to enable MathJax for typesetting math/TeX #  # MathJax is the javascript library Jupyter uses to render math/LaTeX. It is # very large, so you may want to disable it if you have a slow internet # connection, or for offline use of the notebook. #  # When disabled, equations etc. will appear as their untransformed TeX source. #c.NotebookApp.enable_mathjax = True ## extra paths to look for Javascript notebook extensions #c.NotebookApp.extra_nbextensions_path = [] ## handlers that should be loaded at higher priority than the default services #c.NotebookApp.extra_services = [] ## Extra paths to search for serving static files. #  # This allows adding javascript/css to be available from the notebook server # machine, or overriding individual files in the IPython #c.NotebookApp.extra_static_paths = [] ## Extra paths to search for serving jinja templates. #  # Can be used to override templates from notebook.templates. #c.NotebookApp.extra_template_paths = [] ##  #c.NotebookApp.file_to_run = \u0026#39;\u0026#39; ## Extra keyword arguments to pass to `get_secure_cookie`. See tornado\u0026#39;s # get_secure_cookie docs for details. #c.NotebookApp.get_secure_cookie_kwargs = {} ## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS # recompilation #c.NotebookApp.ignore_minified_js = False ## (bytes/sec) Maximum rate at which stream output can be sent on iopub before # they are limited. #c.NotebookApp.iopub_data_rate_limit = 1000000 ## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are # limited. #c.NotebookApp.iopub_msg_rate_limit = 1000 ## The IP address the notebook server will listen on. #c.NotebookApp.ip = \u0026#39;localhost\u0026#39; ## Supply extra arguments that will be passed to Jinja environment. #c.NotebookApp.jinja_environment_options = {} ## Extra variables to supply to jinja templates when rendering. #c.NotebookApp.jinja_template_vars = {} ## The kernel manager class to use. #c.NotebookApp.kernel_manager_class = \u0026#39;notebook.services.kernels.kernelmanager.MappingKernelManager\u0026#39; ## The kernel spec manager class to use. Should be a subclass of # `jupyter_client.kernelspec.KernelSpecManager`. #  # The Api of KernelSpecManager is provisional and might change without warning # between this version of Jupyter and the next stable one. #c.NotebookApp.kernel_spec_manager_class = \u0026#39;jupyter_client.kernelspec.KernelSpecManager\u0026#39; ## The full path to a private key file for usage with SSL/TLS. #c.NotebookApp.keyfile = \u0026#39;\u0026#39; ## Hostnames to allow as local when allow_remote_access is False. #  # Local IP addresses (such as 127.0.0.1 and ::1) are automatically accepted as # local as well. #c.NotebookApp.local_hostnames = [\u0026#39;localhost\u0026#39;] ## The login handler class to use. #c.NotebookApp.login_handler_class = \u0026#39;notebook.auth.login.LoginHandler\u0026#39; ## The logout handler class to use. #c.NotebookApp.logout_handler_class = \u0026#39;notebook.auth.logout.LogoutHandler\u0026#39; ## The MathJax.js configuration file that is to be used. #c.NotebookApp.mathjax_config = \u0026#39;TeX-AMS-MML_HTMLorMML-full,Safe\u0026#39; ## A custom url for MathJax.js. Should be in the form of a case-sensitive url to # MathJax, for example: /static/components/MathJax/MathJax.js #c.NotebookApp.mathjax_url = \u0026#39;\u0026#39; ## Sets the maximum allowed size of the client request body, specified in the # Content-Length request header field. If the size in a request exceeds the # configured value, a malformed HTTP message is returned to the client. #  # Note: max_body_size is applied even in streaming mode. #c.NotebookApp.max_body_size = 536870912 ## Gets or sets the maximum amount of memory, in bytes, that is allocated for # use by the buffer manager. #c.NotebookApp.max_buffer_size = 536870912 ## Dict of Python modules to load as notebook server extensions.Entry values can # be used to enable and disable the loading ofthe extensions. The extensions # will be loaded in alphabetical order. #c.NotebookApp.nbserver_extensions = {} ## The directory to use for notebooks and kernels. #c.NotebookApp.notebook_dir = \u0026#39;\u0026#39; ## Whether to open in a browser after starting. The specific browser used is # platform dependent and determined by the python standard library `webbrowser` # module, unless it is overridden using the --browser (NotebookApp.browser) # configuration option. #c.NotebookApp.open_browser = True ## Hashed password to use for web authentication. #  # To generate, type in a python/IPython shell: #  # from notebook.auth import passwd; passwd() #  # The string should be of the form type:salt:hashed-password. #c.NotebookApp.password = \u0026#39;\u0026#39; ## Forces users to use a password for the Notebook server. This is useful in a # multi user environment, for instance when everybody in the LAN can access each # other\u0026#39;s machine through ssh. #  # In such a case, server the notebook server on localhost is not secure since # any user can connect to the notebook server via ssh. #c.NotebookApp.password_required = False ## The port the notebook server will listen on. #c.NotebookApp.port = 8888 ## The number of additional ports to try if the specified port is not available. #c.NotebookApp.port_retries = 50 ## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib. #c.NotebookApp.pylab = \u0026#39;disabled\u0026#39; ## If True, display a button in the dashboard to quit (shutdown the notebook # server). #c.NotebookApp.quit_button = True ## (sec) Time window used to check the message and data rate limits. #c.NotebookApp.rate_limit_window = 3 ## Reraise exceptions encountered loading server extensions? #c.NotebookApp.reraise_server_extension_failures = False ## DEPRECATED use the nbserver_extensions dict instead #c.NotebookApp.server_extensions = [] ## The session manager class to use. #c.NotebookApp.session_manager_class = \u0026#39;notebook.services.sessions.sessionmanager.SessionManager\u0026#39; ## Shut down the server after N seconds with no kernels or terminals running and # no activity. This can be used together with culling idle kernels # (MappingKernelManager.cull_idle_timeout) to shutdown the notebook server when # it\u0026#39;s not in use. This is not precisely timed: it may shut down up to a minute # later. 0 (the default) disables this automatic shutdown. #c.NotebookApp.shutdown_no_activity_timeout = 0 ## Supply SSL options for the tornado HTTPServer. See the tornado docs for # details. #c.NotebookApp.ssl_options = {} ## Supply overrides for terminado. Currently only supports \u0026#34;shell_command\u0026#34;. #c.NotebookApp.terminado_settings = {} ## Set to False to disable terminals. #  # This does *not* make the notebook server more secure by itself. Anything the # user can in a terminal, they can also do in a notebook. #  # Terminals may also be automatically disabled if the terminado package is not # available. #c.NotebookApp.terminals_enabled = True ## Token used for authenticating first-time connections to the server. #  # When no password is enabled, the default is to generate a new, random token. #  # Setting to an empty string disables authentication altogether, which is NOT # RECOMMENDED. #c.NotebookApp.token = \u0026#39;\u0026lt;generated\u0026gt;\u0026#39; ## Supply overrides for the tornado.web.Application that the Jupyter notebook # uses. #c.NotebookApp.tornado_settings = {} ## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded- # For headerssent by the upstream reverse proxy. Necessary if the proxy handles # SSL #c.NotebookApp.trust_xheaders = False ## DEPRECATED, use tornado_settings #c.NotebookApp.webapp_settings = {} ## Specify Where to open the notebook on startup. This is the `new` argument # passed to the standard library method `webbrowser.open`. The behaviour is not # guaranteed, but depends on browser support. Valid values are: #  # - 2 opens a new tab, # - 1 opens a new window, # - 0 opens in an existing window. #  # See the `webbrowser.open` documentation for details. #c.NotebookApp.webbrowser_open_new = 2 ## Set the tornado compression options for websocket connections. #  # This value will be returned from # :meth:`WebSocketHandler.get_compression_options`. None (default) will disable # compression. A dict (even an empty one) will enable compression. #  # See the tornado docs for WebSocketHandler.get_compression_options for details. #c.NotebookApp.websocket_compression_options = None ## The base URL for websockets, if it differs from the HTTP server (hint: it # almost certainly doesn\u0026#39;t). #  # Should be in the form of an HTTP origin: ws[s]://hostname[:port] #c.NotebookApp.websocket_url = \u0026#39;\u0026#39; #------------------------------------------------------------------------------ # ConnectionFileMixin(LoggingConfigurable) configuration #------------------------------------------------------------------------------ ## Mixin for configurable classes that work with connection files ## JSON file in which to store connection info [default: kernel-\u0026lt;pid\u0026gt;.json] #  # This file will contain the IP, ports, and authentication key needed to connect # clients to this kernel. By default, this file will be created in the security # dir of the current profile, but can be specified by absolute path. #c.ConnectionFileMixin.connection_file = \u0026#39;\u0026#39; ## set the control (ROUTER) port [default: random] #c.ConnectionFileMixin.control_port = 0 ## set the heartbeat port [default: random] #c.ConnectionFileMixin.hb_port = 0 ## set the iopub (PUB) port [default: random] #c.ConnectionFileMixin.iopub_port = 0 ## Set the kernel\u0026#39;s IP address [default localhost]. If the IP address is # something other than localhost, then Consoles on other machines will be able # to connect to the Kernel, so be careful! #c.ConnectionFileMixin.ip = \u0026#39;\u0026#39; ## set the shell (ROUTER) port [default: random] #c.ConnectionFileMixin.shell_port = 0 ## set the stdin (ROUTER) port [default: random] #c.ConnectionFileMixin.stdin_port = 0 ##  #c.ConnectionFileMixin.transport = \u0026#39;tcp\u0026#39; #------------------------------------------------------------------------------ # KernelManager(ConnectionFileMixin) configuration #------------------------------------------------------------------------------ ## Manages a single kernel in a subprocess on this host. #  # This version starts kernels with Popen. ## Should we autorestart the kernel if it dies. #c.KernelManager.autorestart = True ## DEPRECATED: Use kernel_name instead. #  # The Popen Command to launch the kernel. Override this if you have a custom # kernel. If kernel_cmd is specified in a configuration file, Jupyter does not # pass any arguments to the kernel, because it cannot make any assumptions about # the arguments that the kernel understands. In particular, this means that the # kernel does not receive the option --debug if it given on the Jupyter command # line. #c.KernelManager.kernel_cmd = [] ## Time to wait for a kernel to terminate before killing it, in seconds. #c.KernelManager.shutdown_wait_time = 5.0 #------------------------------------------------------------------------------ # Session(Configurable) configuration #------------------------------------------------------------------------------ ## Object for handling serialization and sending of messages. #  # The Session object handles building messages and sending them with ZMQ sockets # or ZMQStream objects. Objects can communicate with each other over the # network via Session objects, and only need to work with the dict-based IPython # message spec. The Session will handle serialization/deserialization, security, # and metadata. #  # Sessions support configurable serialization via packer/unpacker traits, and # signing with HMAC digests via the key/keyfile traits. #  # Parameters ---------- #  # debug : bool # whether to trigger extra debugging statements # packer/unpacker : str : \u0026#39;json\u0026#39;, \u0026#39;pickle\u0026#39; or import_string # importstrings for methods to serialize message parts. If just # \u0026#39;json\u0026#39; or \u0026#39;pickle\u0026#39;, predefined JSON and pickle packers will be used. # Otherwise, the entire importstring must be used. #  # The functions must accept at least valid JSON input, and output *bytes*. #  # For example, to use msgpack: # packer = \u0026#39;msgpack.packb\u0026#39;, unpacker=\u0026#39;msgpack.unpackb\u0026#39; # pack/unpack : callables # You can also set the pack/unpack callables for serialization directly. # session : bytes # the ID of this Session object. The default is to generate a new UUID. # username : unicode # username added to message headers. The default is to ask the OS. # key : bytes # The key used to initialize an HMAC signature. If unset, messages # will not be signed or checked. # keyfile : filepath # The file containing a key. If this is set, `key` will be initialized # to the contents of the file. ## Threshold (in bytes) beyond which an object\u0026#39;s buffer should be extracted to # avoid pickling. #c.Session.buffer_threshold = 1024 ## Whether to check PID to protect against calls after fork. #  # This check can be disabled if fork-safety is handled elsewhere. #c.Session.check_pid = True ## Threshold (in bytes) beyond which a buffer should be sent without copying. #c.Session.copy_threshold = 65536 ## Debug output in the Session #c.Session.debug = False ## The maximum number of digests to remember. #  # The digest history will be culled when it exceeds this value. #c.Session.digest_history_size = 65536 ## The maximum number of items for a container to be introspected for custom # serialization. Containers larger than this are pickled outright. #c.Session.item_threshold = 64 ## execution key, for signing messages. #c.Session.key = b\u0026#39;\u0026#39; ## path to file containing execution key. #c.Session.keyfile = \u0026#39;\u0026#39; ## Metadata dictionary, which serves as the default top-level metadata dict for # each message. #c.Session.metadata = {} ## The name of the packer for serializing messages. Should be one of \u0026#39;json\u0026#39;, # \u0026#39;pickle\u0026#39;, or an import name for a custom callable serializer. #c.Session.packer = \u0026#39;json\u0026#39; ## The UUID identifying this session. #c.Session.session = \u0026#39;\u0026#39; ## The digest scheme used to construct the message signatures. Must have the form # \u0026#39;hmac-HASH\u0026#39;. #c.Session.signature_scheme = \u0026#39;hmac-sha256\u0026#39; ## The name of the unpacker for unserializing messages. Only used with custom # functions for `packer`. #c.Session.unpacker = \u0026#39;json\u0026#39; ## Username for the Session. Default is your system username. #c.Session.username = \u0026#39;用户名\u0026#39; #------------------------------------------------------------------------------ # MultiKernelManager(LoggingConfigurable) configuration #------------------------------------------------------------------------------ ## A class for managing multiple kernels. ## The name of the default kernel to start #c.MultiKernelManager.default_kernel_name = \u0026#39;python3\u0026#39; ## The kernel manager class. This is configurable to allow subclassing of the # KernelManager for customized behavior. #c.MultiKernelManager.kernel_manager_class = \u0026#39;jupyter_client.ioloop.IOLoopKernelManager\u0026#39; #------------------------------------------------------------------------------ # MappingKernelManager(MultiKernelManager) configuration #------------------------------------------------------------------------------ ## A KernelManager that handles notebook mapping and HTTP error handling ## Whether messages from kernels whose frontends have disconnected should be # buffered in-memory. #  # When True (default), messages are buffered and replayed on reconnect, avoiding # lost messages due to interrupted connectivity. #  # Disable if long-running kernels will produce too much output while no # frontends are connected. #c.MappingKernelManager.buffer_offline_messages = True ## Whether to consider culling kernels which are busy. Only effective if # cull_idle_timeout \u0026gt; 0. #c.MappingKernelManager.cull_busy = False ## Whether to consider culling kernels which have one or more connections. Only # effective if cull_idle_timeout \u0026gt; 0. #c.MappingKernelManager.cull_connected = False ## Timeout (in seconds) after which a kernel is considered idle and ready to be # culled. Values of 0 or lower disable culling. Very short timeouts may result # in kernels being culled for users with poor network connections. #c.MappingKernelManager.cull_idle_timeout = 0 ## The interval (in seconds) on which to check for idle kernels exceeding the # cull timeout value. #c.MappingKernelManager.cull_interval = 300 ## Timeout for giving up on a kernel (in seconds). #  # On starting and restarting kernels, we check whether the kernel is running and # responsive by sending kernel_info_requests. This sets the timeout in seconds # for how long the kernel can take before being presumed dead. This affects the # MappingKernelManager (which handles kernel restarts) and the # ZMQChannelsHandler (which handles the startup). #c.MappingKernelManager.kernel_info_timeout = 60 ##  #c.MappingKernelManager.root_dir = \u0026#39;\u0026#39; #------------------------------------------------------------------------------ # ContentsManager(LoggingConfigurable) configuration #------------------------------------------------------------------------------ ## Base class for serving files and directories. #  # This serves any text or binary file, as well as directories, with special # handling for JSON notebook documents. #  # Most APIs take a path argument, which is always an API-style unicode path, and # always refers to a directory. #  # - unicode, not url-escaped # - \u0026#39;/\u0026#39;-separated # - leading and trailing \u0026#39;/\u0026#39; will be stripped # - if unspecified, path defaults to \u0026#39;\u0026#39;, # indicating the root path. ## Allow access to hidden files #c.ContentsManager.allow_hidden = False ##  #c.ContentsManager.checkpoints = None ##  #c.ContentsManager.checkpoints_class = \u0026#39;notebook.services.contents.checkpoints.Checkpoints\u0026#39; ##  #c.ContentsManager.checkpoints_kwargs = {} ## handler class to use when serving raw file requests. #  # Default is a fallback that talks to the ContentsManager API, which may be # inefficient, especially for large files. #  # Local files-based ContentsManagers can use a StaticFileHandler subclass, which # will be much more efficient. #  # Access to these files should be Authenticated. #c.ContentsManager.files_handler_class = \u0026#39;notebook.files.handlers.FilesHandler\u0026#39; ## Extra parameters to pass to files_handler_class. #  # For example, StaticFileHandlers generally expect a `path` argument specifying # the root directory from which to serve files. #c.ContentsManager.files_handler_params = {} ## Glob patterns to hide in file and directory listings. #c.ContentsManager.hide_globs = [\u0026#39;__pycache__\u0026#39;, \u0026#39;*.pyc\u0026#39;, \u0026#39;*.pyo\u0026#39;, \u0026#39;.DS_Store\u0026#39;, \u0026#39;*.so\u0026#39;, \u0026#39;*.dylib\u0026#39;, \u0026#39;*~\u0026#39;] ## Python callable or importstring thereof #  # To be called on a contents model prior to save. #  # This can be used to process the structure, such as removing notebook outputs # or other side effects that should not be saved. #  # It will be called as (all arguments passed by keyword):: #  # hook(path=path, model=model, contents_manager=self) #  # - model: the model to be saved. Includes file contents. # Modifying this dict will affect the file that is stored. # - path: the API path of the save destination # - contents_manager: this ContentsManager instance #c.ContentsManager.pre_save_hook = None ##  #c.ContentsManager.root_dir = \u0026#39;/\u0026#39; ## The base name used when creating untitled directories. #c.ContentsManager.untitled_directory = \u0026#39;Untitled Folder\u0026#39; ## The base name used when creating untitled files. #c.ContentsManager.untitled_file = \u0026#39;untitled\u0026#39; ## The base name used when creating untitled notebooks. #c.ContentsManager.untitled_notebook = \u0026#39;Untitled\u0026#39; #------------------------------------------------------------------------------ # FileManagerMixin(Configurable) configuration #------------------------------------------------------------------------------ ## Mixin for ContentsAPI classes that interact with the filesystem. #  # Provides facilities for reading, writing, and copying both notebooks and # generic files. #  # Shared by FileContentsManager and FileCheckpoints. #  # Note ---- Classes using this mixin must provide the following attributes: #  # root_dir : unicode # A directory against against which API-style paths are to be resolved. #  # log : logging.Logger ## By default notebooks are saved on disk on a temporary file and then if # succefully written, it replaces the old ones. This procedure, namely # \u0026#39;atomic_writing\u0026#39;, causes some bugs on file system whitout operation order # enforcement (like some networked fs). If set to False, the new notebook is # written directly on the old one which could fail (eg: full filesystem or quota # ) #c.FileManagerMixin.use_atomic_writing = True #------------------------------------------------------------------------------ # FileContentsManager(FileManagerMixin,ContentsManager) configuration #------------------------------------------------------------------------------ ## If True (default), deleting files will send them to the platform\u0026#39;s # trash/recycle bin, where they can be recovered. If False, deleting files # really deletes them. #c.FileContentsManager.delete_to_trash = True ## Python callable or importstring thereof #  # to be called on the path of a file just saved. #  # This can be used to process the file on disk, such as converting the notebook # to a script or HTML via nbconvert. #  # It will be called as (all arguments passed by keyword):: #  # hook(os_path=os_path, model=model, contents_manager=instance) #  # - path: the filesystem path to the file just written - model: the model # representing the file - contents_manager: this ContentsManager instance #c.FileContentsManager.post_save_hook = None ##  #c.FileContentsManager.root_dir = \u0026#39;\u0026#39; ## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0 #c.FileContentsManager.save_script = False #------------------------------------------------------------------------------ # NotebookNotary(LoggingConfigurable) configuration #------------------------------------------------------------------------------ ## A class for computing and verifying notebook signatures. ## The hashing algorithm used to sign notebooks. #c.NotebookNotary.algorithm = \u0026#39;sha256\u0026#39; ## The sqlite file in which to store notebook signatures. By default, this will # be in your Jupyter data directory. You can set it to \u0026#39;:memory:\u0026#39; to disable # sqlite writing to the filesystem. #c.NotebookNotary.db_file = \u0026#39;\u0026#39; ## The secret key with which notebooks are signed. #c.NotebookNotary.secret = b\u0026#39;\u0026#39; ## The file where the secret key is stored. #c.NotebookNotary.secret_file = \u0026#39;\u0026#39; ## A callable returning the storage backend for notebook signatures. The default # uses an SQLite database. #c.NotebookNotary.store_factory = traitlets.Undefined #------------------------------------------------------------------------------ # KernelSpecManager(LoggingConfigurable) configuration #------------------------------------------------------------------------------ ## If there is no Python kernelspec registered and the IPython kernel is # available, ensure it is added to the spec list. #c.KernelSpecManager.ensure_native_kernel = True ## The kernel spec class. This is configurable to allow subclassing of the # KernelSpecManager for customized behavior. #c.KernelSpecManager.kernel_spec_class = \u0026#39;jupyter_client.kernelspec.KernelSpec\u0026#39; ## Whitelist of allowed kernel names. #  # By default, all installed kernels are allowed. #c.KernelSpecManager.whitelist = set()","href":"/post/20190515155513/","title":"jupyter_notebook_config.py的配置详解"},{"content":"","href":"/tags/%E9%85%8D%E7%BD%AE/","title":"配置"},{"content":"# -*- coding: utf-8 -*- # notebook服务会监听的IP地址，这个ip地址最好不要填任意的，否则不安全 c.NotebookApp.ip = \u0026#39;localhost\u0026#39; # 这条命令会与下面的一条命令hostnames冲突，如果这个设置为True,这下面这条命令不生效，反之，则生效 c.NotebookApp.allow_remote_access = True # 为本地主机取多个ip别名 c.NotebookApp.local_hostnames = [\u0026#39;localhost\u0026#39;] c.NotebookApp.open_browser = False c.NotebookApp.password = \u0026#34;密码\u0026#34; c.NotebookApp.port = 8888 c.NotebookApp.notebook_dir = \u0026#34;文件路径\u0026#34; 密码的生成详见jupyter如何设置密码\n如果，想要在其他主机上面访问 jupyter, 必须设置\nc.NotebookApp.allow_remote_access = True","href":"/post/20190515154121/","title":"jupyter_notebook_config.py常用配置"},{"content":"打开python命令行，输入\nfrom notebook.auth import passwd passwd() 以密码\u0026rdquo;123\u0026rdquo;为例，输出结果得到如下\n\u0026#39;sha1:da00fa1e950a:0adb64c8359ef97932e5dde02d6167e140bac4e0\u0026#39; 然后把上面的sha写入到配置文件\u0026rdquo;jupyter_notebook_config.py\u0026rdquo;, 这个文件一般需要使用命令生成\n完整的一条配置命令如下：\nc.NotebookApp.password = \u0026#39;sha1:da00fa1e950a:0adb64c8359ef97932e5dde02d6167e140bac4e0\u0026#39; 上面这条配置命令可以放在配置文件任意位置\n","href":"/post/20190515153220/","title":"jupyter 如何设置密码"},{"content":"jupyter notebook --generate-config","href":"/post/20190515151225/","title":"jupyter_notebook_config.py 文件的生成命令"},{"content":"出现这个问题的主要原因是\u0026rdquo;/lib/x86_64-linux-gnu/\u0026ldquo;目录下缺少libgcc_s.so.1\n解决方案：从其他相同操作系统的主机上的\u0026rdquo;/lib/x86_64-linux-gnu/\u0026ldquo;目录，拷贝libgcc_s.so.1\n","href":"/post/20190513111449/","title":"apt-get: error loading libgcc_s.so.1的解决方案"},{"content":"","href":"/tags/contains-empty-filename/","title":"contains empty filename"},{"content":"","href":"/tags/dpkg-error/","title":"dpkg error"},{"content":" 原因分析 后面的错误Sub-process /usr/bin/dpkg returned an error code (2)是由于前面的一个错误引起的\n因此，只需要解决前面的错误就行了\n查找资料 解决这个错误其实很简单，只需要理解前面一个错误里面的empty filename就行了\n我看过很多教程，说只要删除/var/lib/dpkg/info/x.list就可以了，我试过，每次删除，之后这个目录下面都会重新生成x.list文件\n解决方案 之后我找到解决方案，发现只要把x.list改为x.list.broke就可以了，之后就没有empty filename的报错\u0026rdquo;\n","href":"/post/20190513111048/","title":"dpkg error package `x' contains empty filename"},{"content":"","href":"/tags/https/","title":"https"},{"content":"","href":"/tags/ssl/","title":"ssl"},{"content":"","href":"/tags/%E5%9F%9F%E5%90%8D/","title":"域名"},{"content":"","href":"/categories/%E7%B3%BB%E7%BB%9F/","title":"系统"},{"content":"","href":"/tags/%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/","title":"证书申请"},{"content":"","href":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91/","title":"阿里云"},{"content":" 第一步：在阿里云申请域名  登录阿里云， 在搜索框中输入\u0026rdquo;域名 控制台\u0026rdquo;， 进行域名的购买或则注册。   我强烈不推荐购买阿里云的二手域名，虽然价格很便宜，但是大多数域名都有问题，比如被注册局暂停解析等等\n 第二步：在阿里云申请免费的ssl证书  同样在搜索框中输入\u0026rdquo;dns 控制台\u0026rdquo;， 在域名的列表里面可以看到你已经购买的域名， 然后在列表的每个item中点击“更多”，出现\u0026rdquo;ssl\u0026rdquo;证书的字样，点击进去。 选择免费版的ssl证书（这里只能单个子域名进行注册） 点击申请，跳到ssl证书列表页面， 点击验证，大概过5-6分钟，ssl证书就可以审核通过， 下载证书我推荐下载nginx版本的，nginx配置域名最方便，配置域名的教程可以参看我的https服务器搭建详细教程(ubuntu系统实测可行)这个教程  ","href":"/post/20190502140132/","title":"阿里云免费ssl证书申请"},{"content":"du -h -d 1  查看当前目录下面所有文件夹所占的空间\n ","href":"/post/20190502134205/","title":"linux如何查看文件夹占用磁盘空间"},{"content":" 第一步：把指定的域名绑定到服务器指定的端口 1、安装nginx sudo apt-get install nginx  查看nginx版本，确认安装成功\nnginx -v  安装完nginx以后，通过浏览器访问127.0.0.1，再次确认安装成功（访问127.0.0.1其实等价于访问127.0.0.1:80）  2、修改nginx配置文件 sudo vim /etc/nginx/nginx.conf  通过上面的命令打开文件以后，键盘按 “i” 键，进入编辑模式，然后找到类似下面的内容：   ssl的获取可以参看我的阿里云免费ssl证书申请\nhttp { #在这里填写你的配置  #下面省略若干行..... }  完整的配置是这样的（第一个server配置的是http服务，第二个server配置的https服务）：  http { server { listen 80; server_name 指定的域名; root html; index index.html index.htm; location / { proxy_pass http://127.0.0.1:指定的端口/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_redirect off; } } server { listen 443; server_name 指定的域名; ssl on; root html; index index.html index.htm; ssl_certificate .pem后缀文件; ssl_certificate_key .key后缀文件; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:指定的端口/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_redirect off; } } #下面省略若干行\u0026hellip; }\n 键盘按Ctrl+C退出编辑模式，然后输入:wq回车保存文件并退出  第二步：在服务器指定的端口开放访问服务 1、安装tomcat wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.40/bin/apache-tomcat-8.5.40.tar.gz unar apache-tomcat-8.5.40.tar.gz mv apache-tomcat-8.5.40 /usr/local/ 2、修改tomcat的配置文件，支持文件夹或文件的软链接 sudo vim /usr/local/apache-tomcat-8.5.40/conf/context.xml 在文件里面的context标签下面添加\n\u0026lt;Resources allowLinking=\u0026#34;true\u0026#34; /\u0026gt;  修改后是这样的   \u0026lt;Context\u0026gt; \u0026lt;Resources allowLinking=\u0026#34;true\u0026#34; /\u0026gt; #下面省略若干行.... \u0026lt;/Context\u0026gt;  然后运行tomcat  sudo sh /usr/local/apache-tomcat-8.5.40/bin/startup.sh 3、建立一个文件夹的软链接，使得通过服务器指定的端口访问文件夹中的页面 sudo ln -sfn 你的文件夹的绝对路径 /usr/local/apache-tomcat-8.5.40/webapps/ROOT/你的文件夹的别名  由于这里使用的是tomcat，它的默认端口是8080，所以上面指定的端口是8080\n 第三步：测试https服务器是否搭建成功  浏览器访问：\nhttps://指定的域名/你的文件夹别名/要访问的文件名\n ","href":"/post/20190501225058/","title":"https服务器搭建详细教程(ubuntu系统实测可行)"},{"content":"","href":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"服务器"},{"content":"只要修改两个文件：\n /etc/hostname\n /etc/hosts\n  ","href":"/post/20190501213953/","title":"linux修改设备名"},{"content":"","href":"/tags/%E8%BF%90%E7%BB%B4/","title":"运维"},{"content":"","href":"/tags/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/","title":"视频下载"},{"content":" 1、downie 可以下载🌎上面所有你想的到的视频网站的视频，而且下载速度很快。\n2、ykdl 可以通过命令行下载爱奇艺的视频，还有其他网站的视频\n3、you-get 4、youtube-dl ","href":"/post/20190404094748/","title":"视频下载4大神器"},{"content":" 1、以test用户和数据库admin为例：\n use admin db.auth(\u0026#34;test\u0026#34;,\u0026#34;test\u0026#34;) # 两个test分别是用户名和密码","href":"/post/20190212155427/","title":"在开启用户验证的情况下，如何登录mongodb用户"},{"content":"","href":"/tags/%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/","title":"用户验证"},{"content":"1、创建管理员，下面以用户test1为例：\nuse admin db.createUser({user: \u0026#34;test1\u0026#34;, pwd: \u0026#34;test1\u0026#34;, roles: [{role: \u0026#34;root\u0026#34;, db: \u0026#34;admin\u0026#34;}]}) 2、创建test2db对应的test2用户:\nuse test2db db.createUser({user: \u0026#34;test2\u0026#34;, pwd: \u0026#34;test2\u0026#34;, roles: [{role: \u0026#34;readWrite\u0026#34;, db: \u0026#34;test2db\u0026#34; }]})","href":"/post/20190212154741/","title":"mongodb创建root和普通user"},{"content":"","href":"/tags/root/","title":"root"},{"content":"","href":"/tags/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7/","title":"创建用户"},{"content":"","href":"/tags/%E6%99%AE%E9%80%9Auser/","title":"普通user"},{"content":"在这里，我不废话，直接给出mongodb配置文件模板\n# mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # Where and how to store data. storage: dbPath: mongodb数据库的路径（自己可以随便取，只要不与默认的一样就行了） journal: enabled: true # engine: # mmapv1: # wiredTiger: # where to write logging data. systemLog: destination: file logAppend: true path: mongodb日志路径（自己可以随便取，只要不与默认的一样就行了） # network interfaces net: port: 端口0~65536(不常用的端口可以随便取，不可以和默认的一样) bindIp: 0.0.0.0 # how the process runs processManagement: # timeZoneInfo: /usr/share/zoneinfo fork: false #开启用户认证 security: authorization: enabled #operationProfiling: #replication: #sharding: ## Enterprise-Only Options: #auditLog: #snmp:  ","href":"/post/20190212144306/","title":"mongodb多实例启动和开启用户验证"},{"content":"","href":"/tags/%E5%A4%9A%E5%AE%9E%E4%BE%8B/","title":"多实例"},{"content":"这些年，我看了很多关于创建linux用户的博客。发现当中都是写了一大堆废话，都是复制粘贴的，而且介绍的一点都不全面，有些甚至直接是错误的。\n我在这里将按如下步骤来详细的描述创建用户的过程。以用户名test为例：\n1、\nuseradd -d /home/test -m test 上面表示的是创建一个名为test的用户，且同时给他在home目录下面创建了文件夹。\n2、\npasswd test 上面的命令是给test用户设置密码。\n3、\nusermod -s /bin/bash test 上面这段代码的含义是，把命令行的模式换为bash，默认是sh。你肯定会问为什么要这样，因为如果使用默认的sh，你打开终端的提示符显示的是$，不是“用户名$主机名”这种形式。\n4、\nusermod -a -G sudo test usermod -a -G adm test 上面这个代码的意思是，把test用户添加到sudo和admin用户组里面。这里要注意的是系统里面的admin的用户组的名字是\u0026rdquo;adm\u0026rdquo;。\n还有，我经常看到博客说只要改/etc/sudoers文件就可以了。虽然这种方法可行，但是这种方法不利于管理用户。最重要的是，这种方法很low，很垃圾，我很看不起这种方法。做为高水平的技术人才，该装逼的地方还是要装逼的，这样才可彰显牛逼之处。\n5、\ngroups test 上面这个命令的意思是检查test所在的用户组\n6、\nsudo su 首先，你要重新登录一下，然后输入上面这个命令，密码就是使用该用户的密码，然后你就发现可以sudo了，哈哈哈哈啊哈哈，这样你就成功了。\n","href":"/post/20190211224353/","title":"linux创建用户并给用户sudo权限"},{"content":"","href":"/tags/sudo/","title":"sudo"},{"content":"","href":"/post/20180830110337/","title":"mac修改默认终端为iterm2"},{"content":"","href":"/tags/%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF/","title":"默认终端"},{"content":"1.command line tools没有安装，如果执行在线安装的命令也卡死，请看我的上一篇博客的离线安装方法；\n","href":"/post/20180829101640/","title":"brew安装卡死原因"},{"content":"","href":"/tags/command-line-tools/","title":"command-line-tools"},{"content":"https://developer.apple.com/download/more/\n","href":"/post/20180829101005/","title":"mac command line tools离线安装"},{"content":"","href":"/tags/config/","title":"Configuration"},{"content":" For enabling KaTeX, add this to your content\u0026rsquo;s frontmatter:\n--- katex: true --- KaTeX Syntax for Markdown In your Markdown content, use \\\\(\u0026hellip;\\\\) delimiters for in-line mathematics.\nFor mathematics blocks you can use either $$\u0026hellip;$$ or \\\\[\u0026hellip;\\\\] as delimiters.\nHere\u0026rsquo;s an example Markdown content:\nWhen \\\\( a \\ne 0 \\\\), there are two solutions to $$ ax^2 + bx + c = 0 $$ and they are: \\\\[ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} \\\\] Output:\nWhen \\( a \\ne 0 \\), there are two solutions to\n$$ ax^2 + bx + c = 0 $$\nand they are:\n\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]\nCustomize KaTeX Configuration You can customize the default behavior of KaTeX if you want.\nMinimo picks up configuration for KaTeX from the /data/config/katex.json file.\nThe default configuration options look like this:\n{ \u0026#34;library\u0026#34;: { \u0026#34;js\u0026#34;: { \u0026#34;main\u0026#34;: \u0026#34;//unpkg.com/katex/dist/katex.min.js\u0026#34;, \u0026#34;autoRender\u0026#34;: \u0026#34;//unpkg.com/katex/dist/contrib/auto-render.min.js\u0026#34; }, \u0026#34;css\u0026#34;: { \u0026#34;main\u0026#34;: \u0026#34;//unpkg.com/katex/dist/katex.min.css\u0026#34; } }, \u0026#34;options\u0026#34;: {} }  library [Object]:  js [Object]:  main [String]: URL for the main KaTeX library autoRender [String]: URL for the auto-render extension  css [Object]:  main [String]: URL for the main KaTeX stylesheet   options [Object]:  KaTeX configuration options   So, if you want to tinker with it\u0026rsquo;s configuration options:\n Create a /data/config/katex.json file in your site\u0026rsquo;s repository Copy the default configuration options Start hacking  Related Guides  Configuration Options Auto-render Extension  ","href":"/docs/katex-support/","title":"KaTeX Support"},{"content":"","href":"/categories/features/","title":"features"},{"content":"","href":"/tags/katex/","title":"katex"},{"content":"","href":"/authors/muniftanjim/","title":"muniftanjim"},{"content":"","href":"/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式"},{"content":"    字符 描述     \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。   ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。   $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。   * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。   + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。   ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。   {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。   {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。   {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。   ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。   . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(.   (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。   (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(   (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95   (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95   (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95   (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“```(?\u0026lt;!95   `x y`   [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。   [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。   [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。   [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。   \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。   \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。   \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。   \\d 匹配一个数字字符。等价于[0-9]。   \\D 匹配一个非数字字符。等价于[^0-9]。   \\f 匹配一个换页符。等价于\\x0c和\\cL。   \\n 匹配一个换行符。等价于\\x0a和\\cJ。   \\r 匹配一个回车符。等价于\\x0d和\\cM。   \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。   \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。   \\t 匹配一个制表符。等价于\\x09和\\cI。   \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。   \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。   \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。   \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。.   \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。   \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。   \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。   \\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。   \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。   \\p{Latin} 匹配全部拉丁字母   [\\u4e00-\\u9fa5] 匹配中文字符的正则表达式    常见错误 {1-2}错误写法，应该是{1,2}\n持续更新\u0026hellip;\n","href":"/post/20180731192512/","title":"正则表达式符号大全"},{"content":"","href":"/tags/%E7%AC%A6%E5%8F%B7/","title":"符号"},{"content":"","href":"/categories/pip/","title":"pip"},{"content":" 配置文件格式：  以阿里云为例\n [global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com  配置文件路径：  放置配置文件的位置各个操作系统各部相同，下面我将一一列举。\n linux系统: 超级用户： 如果存在/etc/xdg/目录，则使用/etc/xdg/pip/pip.conf路径；不存在使用/etc/pip.conf路径\n普通用户： 使用.config/pip/pip.conf\nmac系统: 超级用户： .config/pip/pip.conf 普通用户： .pip/pip.conf windows系统： 全局配置（win7及以上系统，这里文件名改为pip.ini）： C:\\ProgramData\\pip\\pip.ini ###\n","href":"/post/20180726111905/","title":"python教程之pip使用国内源"},{"content":"","href":"/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"配置文件"},{"content":"","href":"/tags/aggregate/","title":"aggregate"},{"content":"最近看了一些关于mongodb的教程，感觉很费力，尤其涉及到了一些复杂的操作。比如很多贴上了大段数据来描述样例、或者翻译了大段官方文档的文字，这些都让我感觉疲劳。 下面我用自己写的一些话来描述我对mongodb聚合的理解：\n 注： \u0026lt;\u0026gt;用来标识变量（即里面的内容可以替换成其他），可以按照\u0026lt;\u0026gt;里面的单词的含义来理解下面的代码。\n 例子：假设你有一组数据，需要按照顺序做这些操作：筛选、分组、求和，你可以用如下代码实现：\ndb.\u0026lt;collection_name\u0026gt;.aggregate([ {$match:key}, {$group:{_id:$\u0026lt;group_filed_name\u0026gt;, \u0026lt;dispaly_field_name\u0026gt;:{$first:\u0026lt;nonkey_name\u0026gt;}}}, {$group:{_id:null, \u0026lt;sum_name\u0026gt;:{$sum:$\u0026lt;sum_field_name\u0026gt;}}} ]).next().get('\u0026lt;sum_name\u0026gt;')    \u0026lt; key\u0026gt;表示用来筛选的关键字，它的里面结构形如\n {\u0026lt;key1_name\u0026gt;:\u0026lt;key1_value\u0026gt;, \u0026lt;key2_name\u0026gt;:\u0026lt;key2_value\u0026gt;, ...}   表示用来给数据分组的字段名称，其中 _id 是一个内置的关键字，在_id所在字段的值用来划分分组。\n 表示最后输出的字段的名称，表示某个非关键字字段的名称\n 在第二步分组操作做完显示的数据结构是这样的\n {_id:\u0026lt;group_field1_value\u0026gt;,  :}\n {_id:, :}\n\u0026hellip;\n  * 表示最后要显示的求和字段的名称，表示要求和的字段的名称,_id:null表示不分组，这里使用$group符号的原因是$sum必须在$group实现\n 在求和之后数据的结构是这样的\n {_id:null,\u0026lt;sum_name\u0026gt;:\u0026lt;sum_value\u0026gt;}     从上面的例子，我们不难看出mongodb的聚合管道操作它允许分组、求和、筛选等等不同的操作依次进行，从代码里面使用了”[]“这个列表操作符，可以想像mongodb的聚合操作就像python的列表一样依次进行读取、操作，而且聚合操作允许重复多次进行的相同的操作。因此，我认为不管多复杂的操作只要分成一些基本操作，都可以用mongodb的聚合操作实现。\n","href":"/post/20180723195612/","title":"对mongodb的aggregate管道用法的理解"},{"content":"","href":"/tags/%E7%89%9B%E5%AE%A2/","title":"牛客"},{"content":"","href":"/tags/%E7%AE%97%E6%B3%95%E9%A2%98/","title":"算法题"},{"content":"   错误的代码 正确代码 备注     break; break 在任何语言中break后面都没有\u0026rdquo;;\u0026rdquo;\n比如在牛客的在线js中会出现”数组越界的提示“   True和true\nFalse和false 正确区分大小写 js中小写\npython中大写    ","href":"/post/20180723113409/","title":"算法题编码如何躲坑"},{"content":"","href":"/tags/%E5%89%91%E6%8C%87offer/","title":"剑指offer"},{"content":" 算法题尤其要注意细节\n    描述 解读 备注     非减排序的数组 包含了两种情况：\n1. 递增\n2.数字保持不变 剑指offer-06-翻转的数组   若干个 表示\\(\\geq 0\\) 剑指offer-06-翻转的数组   计算机浮点数之间的误差在-0.0000001和0.0000001之间，两个数相等 计算机浮点数存在误差    高效的算法基本上最多使用两个指针     链表问题的关键点：\n1.确定头节点；\n2.保存上一个指针的状态；     循环问题的解决思路 找到前后不变的状态作为终止条件    具有很多标志位的问题 必须找到不变的规律(终止条件)    做二叉树类型的题目 必用递归 因为二叉树太复杂了，一般在面试的时候不用非递归实现    ","href":"/post/20180723093847/","title":"算法题读题注意点"},{"content":"","href":"/tags/%E6%97%A0%E7%9B%91%E7%9D%A3/","title":"无监督"},{"content":" 对监督学习的理解： 监督学习，通俗来讲就是分类，就是把训练样本，在某种评价下得到最佳的模型，然后再利用这个模型将输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的。在人对事物的认识中，我们从孩时就被大人们教授这是鸟，那是房子等等。我们所见到的景物就是输入数据，而大人们对这些事物的判断结果就是相应的输出。当我们见识多了以后，脑子就慢慢地得到了一些泛化的模型，这就是训练得到的那个函数，从而没有大人在旁边指点的时候，我们就可自己分辨哪些是房子，哪些是鸟。\n对无监督学习的理解： 它与非监督学习的不同之处，在于我们事先没有任何训练样本，而直接对数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知,但是欣赏完多幅作品之后，我们也能把它们分成不同的派别。比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分成两个类。无监督学习的里典型的例子就是聚类。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法只需要知道如何计算相似度就可以开始工作了。\n","href":"/post/20180720170528/","title":"机器学习面试知识点一(无监督和有监督算法的区别)"},{"content":"","href":"/tags/%E7%9B%91%E7%9D%A3/","title":"监督"},{"content":" Configure Fuse.js Search Client Select Fuse.js as the search client in your config.toml file:\n[params.search] client = \u0026#34;fuse\u0026#34;","href":"/docs/search-fuse-js/","title":"Search: Fuse.js"},{"content":"","href":"/tags/fuse.js/","title":"fuse.js"},{"content":"","href":"/tags/search/","title":"search"},{"content":" Configure Algolia Search Client Select Algolia as the search client in your config.toml file:\n[params.search] client = \u0026#34;algolia\u0026#34; Also, add configuration options for Algolia:\n[params.search.algolia] appId = \u0026#34;\u0026#34; indexName = \u0026#34;\u0026#34; searchApiKey = \u0026#34;\u0026#34;  params.search.algolia [Map]:  appId [String]: Algolia Application ID indexName [String]: Name for Algolia Indices\ndefault: minimo_site searchApiKey [String]: Algolia Search-Only API Key   You\u0026rsquo;ll find various information related to your Algolia account in the Algolia Dashboard.\nGenerate Search Index for Algolia Algolia will need a search index for searching across your site. So, you\u0026rsquo;ll need to generate that search index for Algolia before you deploy your site.\nMinimo comes with a script for generating the search index for Algolia: /scripts/generate-search-index-algolia.js.\nInstall Dependencies Node.js must be installed on your system for using the generator script.\nIt also needs the following npm packages:\n algoliasearch glob  For installing algoliasearch and glob globally use the following command:\nnpm install -g algoliasearch glob Set Environment Variables The generator script uses the following environment variables:\n ALGOLIA_APP_ID (required): Algolia Application ID ALGOLIA_ADMIN_API_KEY (required): Algolia Admin API Key ALGOLIA_INDEX_NAME (optional): Name for Algolia Indices\ndefault: minimo_site  Run the Script After you\u0026rsquo;ve generated your site with Hugo, run generate-search-index-algolia.js with node.\nIf Minimo is installed under /themes/minimo directory, you\u0026rsquo;ll run it as:\nnode ./themes/minimo/scripts/generate-search-index-algolia.js The generate-search-index-algolia.js script accepts an optional argument for Hugo\u0026rsquo;s publishDir (relative to your site\u0026rsquo;s root directory).\nSo, if you\u0026rsquo;ve got a different publishDir (say site), pass it as the first argument:\nnode ./themes/minimo/scripts/generate-search-index-algolia.js site If the generation was successful, you\u0026rsquo;ll see output like this:\nAlgolia Index Generated for: /search/index.json  That\u0026rsquo;s all. Now you can deploy your site.\n","href":"/docs/search-algolia/","title":"Search: Algolia"},{"content":"","href":"/tags/algolia/","title":"algolia"},{"content":" Configure Lunr.js Search Client Select Lunr.js as the search client in your config.toml file:\n[params.search] client = \u0026#34;lunr\u0026#34; Generate Search Index for Lunr.js Lunr.js will need a search index for searching across your site. So, you\u0026rsquo;ll need to generate that search index for Lunr.js before you deploy your site.\nMinimo comes with a script for generating the search index for Lunr.js: /scripts/generate-search-index-lunr.js.\nInstall Dependencies Node.js must be installed on your system for using the generator script.\nIt also need the following npm packages:\n glob lunr  For installing lunr and glob globally use the following command:\nnpm install -g lunr glob Run the Script After you\u0026rsquo;ve generated your site with Hugo, run generate-search-index-lunr.js with node.\nIf Minimo is installed under /themes/minimo directory, you\u0026rsquo;ll run it as:\nnode ./themes/minimo/scripts/generate-search-index-lunr.js The generate-search-index-lunr.js script accepts an optional argument for Hugo\u0026rsquo;s publishDir (relative to your site\u0026rsquo;s root directory).\nSo, if you\u0026rsquo;ve got a different publishDir (say site), pass it as the first argument:\nnode ./themes/minimo/scripts/generate-search-index-lunr.js site If the generation was successful, you\u0026rsquo;ll see output like this:\nLunr.js Index Generated for: /search/index.json That\u0026rsquo;s all. Now you can deploy your site.\n","href":"/docs/search-lunr-js/","title":"Search: Lunr.js"},{"content":"","href":"/tags/lunr.js/","title":"lunr.js"},{"content":" Minimo supports the following clients for the search feature:\n Algolia Fuse.js Lunr.js  Follow the following steps for enabling search in your site.\nCreate Search Page First of all, you\u0026rsquo;ll need to create a search page.\nCreate a markdown file under /content/page/ directory with the filename search. If your site is multilingual, you can include language code in the filename. For example:\n /content/page/search.md /content/page/search.en.md  Add the following options in the frontmatter:\ntype: page layout: search outputs: - html - json Select Search Client For selecting the client for search feature, use the following options in your config.toml file:\n[params.search] client = \u0026#34;\u0026#34;  params.search [Map]:  client [String]: Name of the Search Client (supported values: algolia,fuse,lunr)   Client Specific Steps The next steps are different for each search client:\n Algolia Fuse.js Lunr.js  After you complete those steps, you are good to go!\nAdd Search Widget You might also want to add the search widget.\n","href":"/docs/search-support/","title":"Search Support"},{"content":" 联系方式  手机：13588796263 Email：wujunleiwang@gmail.com 微信号：bubaizhansheng  个人信息   吴俊磊/男/1994 本科/西南民族大学/网络工程 硕士/杭州电子科技大学/计算机科学与技术 技术博客：https://mannuan.github.io Github：http://github.com/mannuan 期望职位：Web前端初级程序员 期望城市：杭州       校园项目经历 研究生期间 智慧旅游-爬虫管理系统 (2018年1月~2018年8月)  项目描述：对大众点评、携程和马蜂窝等旅游网站进行爬虫，并用页面展示数据； 项目职责：  对python库selenium进行封装，爬取动态网页； 使用ip代理和爬虫策略解决服务器403拒绝请求问题； 使用预先加载cookie的方式，解决登录验证问题； 总结爬虫的字体反爬和css反爬的解决方案； 使用mongodb存储数据，并使用aggregate查询数据； 使用基于nodejs的koa作为web后端开发框架，接收post和get请求； 使用vue和element-ui完成页面的布局，利用ajax进行数据解析显示和查询；  项目成果：  每天可以稳定的爬取几万条数据。在几十万条数据中，从数据的查询到页面完成数据加载花费的时间不超过3秒。   河长信息管理系统-爬虫脚本开发 (2017年10月~2018年1月)  项目描述：对万方数据、浙江省水利厅和百度百科等含有河流信息的网站进行爬虫； 项目职责：  使用pyspider作为爬虫框架，编写爬虫脚本； 使用正则表达式编写一套通用的爬虫脚本模板； 制定爬虫策略解决服务器403拒绝请求的问题；  项目成果：在该系统上线以后，每天都可以稳定地获取到最新的数据。  本科阶段 基于LLDP协议捎带式服务质量采集机制(2016年3月~2017年3月)  项目描述：这是一个软件定义网络的创新项目，目的是在占用少量的网络带宽的情况下，使用链路发现协议(LLDP)来传递网络的服务质量信息(QoS)。 项目职责：  在网络控制器Floodlight上创建一个修改LLDP数据包结构的模块； 修改虚拟网络交换机Vswitch的源代码，把网络QoS信息填写到LLDP数据包中； 使用网络仿真器Mininet，完成网络的一键式部署； 使用jquery和dataTable等javascript库完成页面布局，使用ajax异步加载网络的QoS信息；  项目成果：  在2016年的第三届全国高校软件定义网络（SDN）应用创新开发大赛中获得了二等奖。 发表了一篇sci 4区的论文-The Top-K QoS-aware Paths Discovery for Source Routing in SDN。我是这篇论文的第二作者，我对这篇论文的主要贡献就是提高实验数据。   技能清单 以下均为我熟练使用的技能\n Web开发：Node Web框架：django 前端框架：Vue 前端工具：webpack 数据库相关：MySQL/mongodb 版本管理、文档和自动化部署工具：Git  自我评价 致谢 感谢您花时间阅读我的简历，期待能有机会和您共事。\n","href":"/post/20180704142218/","title":"个人简历"},{"content":"","href":"/categories/%E4%BD%9C%E8%80%85/","title":"作者"},{"content":"","href":"/tags/%E7%AE%80%E5%8E%86/","title":"简历"},{"content":" Minimo has support for comments baked into it.\nEnable/Disable Comments Globally For enabling or disabling comments globally, check the following setting in your config.toml file:\n[params.comments] enable = false  params.comments [Map]:  enable [Boolean]: Enable/Disable comments globally   For Specific Posts The global .Site.Params.comments.enable setting can be overridden for specific posts in their content\u0026rsquo;s frontmatter with this option:\n--- comments: true ---  comments [Boolean]: Enable/Disable comments for specific posts  Of course, you\u0026rsquo;ll also need to setup a comment system ( Disqus or Staticman ).\nSetting Up Comment System Minimo currently supports Disqus, Isso, Staticman and Utterances to be used as your site\u0026rsquo;s comment system.\nDisqus Disqus comments require you set a single value to the following option in your config.toml file:\ndisqusShortname = \u0026#34;\u0026#34;  disqusShortname [String]: Shortname for you site\u0026rsquo;s Disqus account  And that\u0026rsquo;s all!\nIsso Isso is a lightweight alternative to Disqus. You need to have a Isso server running somewhere, then set up the following options in your config.toml file:\n[params.comments.isso] enable = true scriptSrc = \u0026#34;https://isso.example.com/js/embed.min.js\u0026#34; dataAttrs = \u0026#34;data-isso=\u0026#39;https://isso.example.com data-isso-require-author=\u0026#39;true\u0026#39;\u0026#34;  params.comments.isso [Map]:  enable [Boolean]: Enable Isso scriptSrc [String]: URL of the Isso integration script. dataAttrs [String]: Data attributes to add to the Isso \u0026lt;script\u0026gt; tag. Optional, but the Isso documentation recommends to at least include the data-isso attribute.   Staticman For up-to-date information, check out the Documentation Site and the Public Repository of Staticman.\nConfigure Minimo for Staticman First of all, set up the following options in your config.toml file:\n[params.comments.staticman] enable = true apiEndpoint = \u0026#34;https://api.staticman.net/v2/entry\u0026#34; maxDepth = 2 username = \u0026#34;MunifTanjim\u0026#34; repository = \u0026#34;minimo\u0026#34; branch = \u0026#34;master\u0026#34;  params.comments.staticman [Map]:  enable [Boolean]: Enable Staticman apiEndpoint [String]: API endpoint for Staticman instance maxDepth [Integer]: Maximum allowed comments depth username [String]: Your Git Username repository [String]: Name of your Site\u0026rsquo;s Git Repository branch [String]: Branch name of Site\u0026rsquo;s Git Repository   Staticman Configuration File Next, you\u0026rsquo;ll need a Staticman Configuration File (staticman.yml) in the root of your site\u0026rsquo;s repository. Here\u0026rsquo;s a sample of it:\nstaticman.yml\ncomments: allowedFields: [\u0026#34;author\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;parent_id\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;site\u0026#34;] branch: \u0026#34;master\u0026#34; commitMessage: \u0026#34;add [comment]: by {fields.author} \u0026lt;Staticman\u0026gt;\\n\\n{fields.permalink}#comment-{@id}\u0026#34; filename: \u0026#34;{@id}\u0026#34; format: \u0026#34;yaml\u0026#34; generatedFields: date: type: date options: format: \u0026#34;timestamp\u0026#34; moderation: false name: \u0026#34;Minimo\u0026#34; path: \u0026#34;data/comments/{options.postId}\u0026#34; requiredFields: [\u0026#34;author\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;permalink\u0026#34;] transforms: email: md5 Notes  In most cases, you\u0026rsquo;ll only need to change the name option (Site\u0026rsquo;s name) If you set moderation: true, Staticman will send a Pull Request whenever a new comment is submitted. You\u0026rsquo;ll need to Merge the Pull Request to approve it, or Close to discard. Use the same branch name in both config.toml \u0026amp; staticman.yml  Add Staticman to Your Site\u0026rsquo;s Repository Staticman will need push access to your site\u0026rsquo;s repository for committing comment files. In GitHub, go to your repository Settings page, navigate to the Collaborators tab and add the username staticmanapp.\nAt this point, the invitation will be pending. In order for Staticman to accept it, you\u0026rsquo;ll need to open:\nhttps://api.staticman.net/v2/connect/{github.username}/{github.repository}\n[ Replace the {github.username} and {github.repository} with your GitHub username and repository\u0026rsquo;s name. ]  If all goes well, you should receive a message saying OK!\nAnd you should be good to go!\nUtterances Utterances only supports GitHub. So, if your site\u0026rsquo;s repository is not hosted in GitHub, it won\u0026rsquo;t work.\nFor using Utterances, set up the following options in your config.toml file:\n[params.comments.utterances] enable = true issueTerm = \u0026#34;pathname\u0026#34; # pathname / url / title [params.comments.utterances.github] username = \u0026#34;MunifTanjim\u0026#34; repository = \u0026#34;minimo\u0026#34;  params.comments.utterances [Map]:  enable [Boolean]: Enable Utterances issueTerm [String]: Entry to Issue mapping option (pathname / url / title)  params.comments.utterances.github [Map]:  username [String]: Your GitHub Username repository [String]: Name of your Site\u0026rsquo;s GitHub Repository   Check utteranc.es for more information.\nThat should do it!\n","href":"/docs/comments-support/","title":"Comments Support"},{"content":"First of all, if you really want emojis, set the enableEmoji setting to true in your config.toml file:\nenableEmoji = true This will enable Hugo to find Emoji Shorthands in your content files and render them as Unicode Emoji Characters.\nFor example:\n will become 😃  No, it\u0026rsquo;ll probably not be that colorful! Unless your device\u0026rsquo;s operating system natively supports colorful emojis, you will see a black \u0026amp; white one instead. 🔥\n✏️ For getting that colorful look, you will have to add this to your content\u0026rsquo;s frontmatter:\n--- emoji: true --- And where can you find these Emoji Shorthands ❓\n🎉 Go take a look at: Emoji Cheat Sheet\n","href":"/docs/emoji-support/","title":"Emoji Support"},{"content":" For enabling MathJax, add this to your content\u0026rsquo;s frontmatter:\n--- mathjax: true --- MathJax Syntax for Markdown In your Markdown content, use \\\\(\u0026hellip;\\\\) delimiters for in-line mathematics.\nFor mathematics blocks you can use either $$\u0026hellip;$$ or \\\\[\u0026hellip;\\\\] as delimiters.\nHere\u0026rsquo;s an example Markdown content:\nWhen \\\\( a \\ne 0 \\\\), there are two solutions to $$ ax^2 + bx + c = 0 $$ and they are: \\\\[ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} \\\\] Output:\nWhen \\( a \\ne 0 \\), there are two solutions to\n$$ ax^2 + bx + c = 0 $$\nand they are:\n\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]\nCustomize MathJax Configuration You can customize the default behavior of MathJax if you want.\nMinimo picks up configuration for MathJax from the /data/config/mathjax.json file.\nThe default configuration options look like this:\n{ \u0026#34;library\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;//unpkg.com/mathjax/MathJax.js\u0026#34;, \u0026#34;config\u0026#34;: \u0026#34;TeX-MML-AM_CHTML\u0026#34; }, \u0026#34;config\u0026#34;: {} }  library [Object]:  path [String]: URL for the main MathJax.js file. config [String]: Configuration file\u0026rsquo;s name/path  config [Object]:  In-line configuration options   So, if you want to tinker with it\u0026rsquo;s configuration options:\n Create a /data/config/mathjax.json file in your site\u0026rsquo;s repository Copy the default configuration options Start hacking  For exmaple, if you want to enable $\u0026hellip;$ delimiters for in-line mathematics, you probably want something like this:\n{ \u0026#34;library\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;//unpkg.com/mathjax/MathJax.js\u0026#34;, \u0026#34;config\u0026#34;: \u0026#34;TeX-MML-AM_CHTML\u0026#34; }, \u0026#34;config\u0026#34;: { \u0026#34;tex2jax\u0026#34;: { \u0026#34;inlineMath\u0026#34;: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;], [\u0026#34;\\\\(\u0026#34;, \u0026#34;\\\\)\u0026#34;]], \u0026#34;processEscapes\u0026#34;: true } } } Related Guides  Using a configuration file Combined Configurations Using in-line configuration options Configuration Options  ","href":"/docs/mathjax-support/","title":"MathJax Support"},{"content":" Enabling Sidebar For enabling Sidebar, use the following configuration options in your config.toml file:\n[params.sidebar] enable = true  params.sidebar [Map]:  enable [Boolean]: Switch for enabling sidebar   Adding Widgets to Sidebar For adding Widgets to the Sidebar, check the Widgets documentation.\n","href":"/docs/sidebar/","title":"Sidebar"},{"content":" Minimo supports Widgets that you can place on specific Widget Areas.\nAvailable Widgets Minimo has the following built-in Widgets:\n   Name Slug     1. About about   2. Breadcrumbs breadcrumbs   3. Recent Posts recent_posts   4. Search search   5. Sidebar Menu sidebar_menu   6. Social Menu social_menu   7. Taxonomy Cloud taxonomy_cloud    Widget Configuration Options Here are the configuration options available for the Widgets:\nWidget: About  about [Map]:  title [String]: Title\ndefault: .Site.Title description [String]: Description\ndefault: .Site.Params.info.description logo [String]: path/url of Logo\ndefault: \u0026quot;/images/logo.png\u0026quot;   Widget: Breadcrumbs  breadcrumbs [Map]:  separator [String]: Breadcrumb separator\ndefault: \u0026quot;/\u0026quot; excludeParents [Array of Strings]: Types of parents to exclude\ndefault: [\u0026quot;page\u0026quot;]   Widget: Recent Posts  recent_posts [Map]:  title [String]: Title\ndefault: \u0026quot;Recent Posts\u0026quot; length [Integer]: Number of posts to show\ndefault: 5 excludeTypes [Array of Strings]: Types of posts to exclude\ndefault: [\u0026quot;page\u0026quot;]   Widget: Search  search [Map]:  title [String]: Title\ndefault: \u0026quot;Search\u0026quot;   Widget: Sidebar Menu  sidebar_menu [Map]:  title [String]: Title\ndefault: \u0026quot;\u0026quot; mirror [String]: Name of menu to mirror (e.g. \u0026quot;main\u0026quot;)\ndefault: \u0026quot;\u0026quot;   Widget: Social Menu  social_menu [Map]:  title [String]: Title\ndefault: \u0026quot;\u0026quot; platforms [Array of Strings]: Social platform to show   Widget: Taxonomy Cloud  taxonomy_cloud [Map]:  title [String]: Title\ndefault: Plural Name for taxonomyCloud.taxonomy taxonomy [String]: Taxonomy to show\ndefault: .Site.Params.info.description shuffle [Boolean]: Shuffle Taxonomy Terms\ndefault: true   Available Widget Areas    Name Slug     Header header   Homepage homepage   Sidebar sidebar   Footer footer    You can add Widgets to Widget Areas from your config.toml file:\n[params.widgets] header = [\u0026#34;breadcrumbs\u0026#34;] homepage = [\u0026#34;recent_posts\u0026#34;] sidebar = [\u0026#34;about\u0026#34;,\u0026#34;taxonomy_cloud\u0026#34;] footer = [\u0026#34;social_menu\u0026#34;] The syntax for adding Widgets to Widget Areas is:\nwidget_area_slug = [ widget_slug_1, widget_slug_2, ...] Widgets Configuration File Minimo picks up Widgets\u0026rsquo; configuration from the /data/config/widgets.toml file.\nHere\u0026rsquo;s the Widgets Config file for this site:\n/data/config/widgets.toml\n# About Widget config [about] title = \u0026#34;\u0026#34; # default: .Site.Title description = \u0026#34;\u0026#34; # default: .Site.Params.info.description logo = \u0026#34;/images/我的头像.jpeg\u0026#34; # default: \u0026#34;/images/logo.png\u0026#34; # Breadcrumbs Widget config [breadcrumbs] separator = \u0026#34;/\u0026#34; # default: \u0026#34;/\u0026#34; excludeParents = [\u0026#34;page\u0026#34;] # default: [\u0026#34;page\u0026#34;] # Recent Posts Widget config [recent_posts] title = \u0026#34;\u0026#34; # default: \u0026#34;Recent Posts\u0026#34; length = 4 # default: 5 excludeTypes = [\u0026#34;page\u0026#34;] # default: [\u0026#34;page\u0026#34;] # Search Widget config [search] title = \u0026#34;Search\u0026#34; # default: \u0026#34;Search\u0026#34; # Sidebar Menu Widget config [sidebar_menu] title = \u0026#34;\u0026#34; # default: \u0026#34;\u0026#34; mirror = \u0026#34;\u0026#34; # default: \u0026#34;\u0026#34; # Social Menu Widget config [social_menu] title = \u0026#34;\u0026#34; # default: \u0026#34;\u0026#34; platforms = [\u0026#34;github\u0026#34;,\u0026#34;facebook\u0026#34;,\u0026#34;twitter\u0026#34;,\u0026#34;instagram\u0026#34;,\u0026#34;email\u0026#34;,\u0026#34;codepen\u0026#34;,\u0026#34;gitlab\u0026#34;,\u0026#34;linkedin\u0026#34;,\u0026#34;telegram\u0026#34;,\u0026#34;google_scholar\u0026#34;,\u0026#34;youtube\u0026#34;] # Taxonomy Cloud Widget config [taxonomy_cloud] title = \u0026#34;\u0026#34; # default: Plural Name for `taxonomyCloud.taxonomy` taxonomy = \u0026#34;tags\u0026#34; # default: \u0026#34;tags\u0026#34; shuffle = true # default: true If configuration for any Widgets are missing in this file, Minimo will fallback to the default configuration for those Widgets.\nGo wild!\n","href":"/docs/widgets/","title":"Widgets"},{"content":"","href":"/tags/widgets/","title":"widgets"},{"content":" Minimo comes with several shortcodes built-in.\nShortcode: center Center align you content.\ncenter: Parameters  Markdown content between opening and closing tags.  center: Usage Example {{\u0026lt; center \u0026gt;}} _Center Aligned Text_ {{\u0026lt; /center \u0026gt;}} Output\nCenter Aligned Text  Shortcode: convo Renders conversation blocks.\nconvo: Parameters  sep [String] (optional): seperator between person and text (default: \u0026ldquo;:\u0026rdquo;)  convo: Inner Syntax person :: text You can remove the person part, if you want.\nconvo: Usage Example {{\u0026lt; convo sep=\u0026#34;:\u0026#34; \u0026gt;}} Jerry :: You don\u0026#39;t look so tough. Finch :: It\u0026#39;s because I have only two modes, Jerry. Calm, and furious. It\u0026#39;s a rare person that sees the latter and lives to talk about it. {{\u0026lt; /convo \u0026gt;}} Output\n  Jerry :  You don\u0026rsquo;t look so tough.   Finch :  It\u0026rsquo;s because I have only two modes, Jerry. Calm, and furious. It\u0026rsquo;s a rare person that sees the latter and lives to talk about it.    Shortcode: file Include content from seperate file with syntax highlighting.\nfile: Parameters 0 =\u0026gt; filename [String] (required)\n1 =\u0026gt; filetype [String] (optional)\nfile: Usage Example {{\u0026lt; file \u0026#34;content/_index.md\u0026#34; \u0026gt;}} Output\n--- title: Home menu: - main - sidebar weight: -270 ---\u0026gt; The Golden Rule is that there are no golden rules. \u0026lt;!--知识是一宝库，而实践就是开启宝库大门的钥匙。--\u0026gt; \u0026gt; — Fuller Shortcode: text Text with custom size and color\ntext: Parameters You can use either Named or Unnamed Parameters\nNamed Parameters\n s or size [String] (optional): multiplier relative to the normal size c or color [String] (optional): name / hex / rgb / rgba  Unnamed Parameters\n0 =\u0026gt; textsize [String] (required): multiplier relative to the normal size\n1 =\u0026gt; textcolor [String] (optional): name / hex / rgb / rgba\ntext: Usage Example {{\u0026lt; text s=\u0026#34;1.4\u0026#34; color=\u0026#34;purple\u0026#34; \u0026gt;}} font-size: 1.4em; color: purple; {{\u0026lt; /text \u0026gt;}} Output\nfont-size: 1.5em;\ncolor: purple; ","href":"/docs/shortcodes/","title":"Shortcodes"},{"content":"","href":"/tags/shortcode/","title":"shortcode"},{"content":"You can add cover image to your contents with the cover paramameter in the content\u0026rsquo;s front-matter.\nYou can directly provide the image url:\n--- cover: /images/eden-farm-children-s-village.jpg ---  cover [String]: path/url of the cover image  Or you can provide additional information:\n--- cover: image: /images/eden-farm-children-s-village.jpg alternate: Picture of a yellow wall with a blue window in the upper-left corner caption: Eden Farm Children\u0026#39;s Village by Gareth Harper on Unsplash style: full ---  cover [Map]:  image [String]: path/url of the cover image alternate [String]: alternate text for the image caption [String]: caption for the cover image style [String]: full / wide / normal   ","href":"/docs/cover-image/","title":"Cover Image"},{"content":"","href":"/page/","title":"Pages"},{"content":"You can translate Minimo in your own language!\nFor example, if you want to translate Minimo in Spanish, you will have to add this to your site\u0026rsquo;s config file:\n[languages.es] lang = \u0026#34;es\u0026#34; languageName = \u0026#34;Spanish\u0026#34; weight = 1 Then create a folder named /i18n/ in your site\u0026rsquo;s root. And create a file /i18n/es.toml with the translated strings.\nFor reference template you can see the en.toml file.\nIf you want your translation file to be included in Minimo repository, feel free to create a pull request.\n","href":"/docs/translation/","title":"Translation Support"},{"content":"","href":"/tags/i18n/","title":"i18n"},{"content":"","href":"/tags/translation/","title":"translation"},{"content":"Hugo uses Chroma as it\u0026rsquo;s built-in syntax-highlighter.\nFor detailed information about Syntax Highlighting in Hugo, check the Hugo\u0026rsquo;s Syntax Highlighting Documentation.\n","href":"/docs/syntax-highlighting/","title":"Syntax Highlighting"},{"content":"","href":"/tags/chroma/","title":"chroma"},{"content":"","href":"/tags/pygments/","title":"pygments"},{"content":" Minimo has three menus.\n Main Menu Sidebar Menu Social Menu  Main Menu name: main\nMain menu is located at the top of the site.\nCheck Hugo\u0026rsquo;s Menus Documentation for information about managing this menu.\nYou can hide the Main Menu using the following option in your config.toml file:\n[params.settings] hideMainMenu = true Sidebar Menu name: sidebar\nSocial Menu is available as Widget: sidebar_menu. Add it to the sidebar Widget Area to use it.\nYou can use Sidebar Menu as normal Hugo Menus.\nOr you can use it to mirror another menu by using the sidebar_menu.mirror option in your Widgets Configuration File. For example, this will mirror the Main Menu:\n[sidebar_menu] ... mirror = \u0026#34;main\u0026#34; The sidebar menu can display nested menus. The sub-pages need to have a page as parent defined in the page\u0026rsquo;s front matter:\nmenu: main: parent: myParentPage Social Menu Social Menu is available as Widget: social_menu. You can add it to Widget Areas to use it.\nUse the variables under [params.social] in your config.toml file for adding your social profiles:\n[params.social] codepen = \u0026#34;...\u0026#34; email = \u0026#34;...\u0026#34; facebook = \u0026#34;...\u0026#34; ... You only have to add your usernames. Minimo will take care of the rest.\nChanging Social Menu Icons Order If you want to change the order of the social menu icons, use the social_menu.platforms option in your Widgets Configuration File.\nThe social menu icons will appear in the order you specify in the platforms array.\n","href":"/docs/menus/","title":"Menus Setup Guide"},{"content":"","href":"/tags/menus/","title":"menus"},{"content":"","href":"/tags/og/","title":"Opengraph"},{"content":" Minimo has built-in support for Opengraph tags. It will pick up most of the things from your contents\u0026rsquo; front-matters \u0026amp; Hugo configuration.\nYou can use these options in you content\u0026rsquo;s front-matter:\n--- audios: [] # for og:audio tags images: [] # for og:image tags videos: [] # for og:video tags ---  audios [Array of Strings]: path/url of audio files images [Array of Strings]: path/url of image files videos [Array of Strings]: path/url of video files  N.B.: the front-matter syntax shown here is yaml. If you use a different format (e.g. toml), the syntax will change accordingly.\nIf you add Cover Image to you content, it will also be picked up.\nFacebook Opengraph You can set these options in your config.toml files for better integration with Facebook:\n[params.opengraph.facebook] admins = [] # for fb:admins tags appID = \u0026#34;\u0026#34; # for fb:app_id tag pageID = \u0026#34;\u0026#34; # for article:publisher tag  admins [Array of Strings]: Facebook Profile IDs appID [String]: Facebook Application ID pageid [String]: Facebook Page ID  Also, the [social.facebook] field from the Author\u0026rsquo;s Profile data is used for article:author tag.\nTwitter Cards Minimo has built-in support for Twitter Cards.\nYou can set these options in your config.toml files to provide additional information for Twitter Cards:\n[params.opengraph.twitter] page = \u0026#34;\u0026#34; # for twitter:site tag  page [String]: Twitter Page\u0026rsquo;s Username  Also, the [social.twitter] field from the Author\u0026rsquo;s Profile data is used for twitter:creator tag.\n","href":"/docs/opengraph/","title":"Opengraph Support"},{"content":" Minimo supports multiple authors for your site. Just make sure you have the following configuration in your site\u0026rsquo;s config.toml:\n[taxonomies] author = \u0026#34;authors\u0026#34; Minimo treats Authors as a Hugo Taxonomy.\nAuthor\u0026rsquo;s Profile For adding an author to your site:\n Create data/authors folder in your site\u0026rsquo;s root directory Create a file with the filename format: \u0026lt;username\u0026gt;.toml  Now, add information about the author using the structure below:\n/data/authors/muniftanjim.toml\nid = \u0026#34;muniftanjim\u0026#34; [email] username = \u0026#34;muniftanjim\u0026#34; host = \u0026#34;gmail.com\u0026#34; [name] display = \u0026#34;Munif Tanjim\u0026#34; [social] email = \u0026#34;\u0026#34; facebook = \u0026#34;MunifTanjim\u0026#34; twitter = \u0026#34;MunifTanjim\u0026#34; You can use either the [email] fields or the [social.email] field. You don\u0026rsquo;t need to fill them both. However, it is encouraged to use [email] instead of [social.email].\nAdding Authors to Contents For adding authors to your content include the following option in your content\u0026rsquo;s front-matter:\n--- authors: [\u0026#34;muniftanjim\u0026#34;] ---  authors [Array of Strings]: username of authors  That\u0026rsquo;s all.\n","href":"/docs/authors/","title":"Authors Setup Guide"},{"content":"","href":"/tags/authors/","title":"authors"},{"content":"This is the Minimo\u0026rsquo;s configuration file ( config.toml ) file of this site:\nbaseURL = \u0026#34;http://mannuan.github.io\u0026#34; title = \u0026#34;mannuan\u0026#34; # for smart copyright line, leave this blank and check [params.copyright] copyright = \u0026#34;\u0026#34; theme = \u0026#34;minimo\u0026#34; disqusShortname = \u0026#34;\u0026#34; googleAnalytics = \u0026#34;\u0026#34; Paginate = 10 preserveTaxonomyNames = true enableRobotsTXT = true # generate robots.txt # Syntax Highlighting ( https://gohugo.io/content-management/syntax-highlighting/ ) pygmentsCodefences = true enableEmoji = true # Missing translations will default to this content language defaultContentLanguage = \u0026#34;en\u0026#34; [params.info] description = \u0026#34;Rome was not built in a day.\u0026#34; title404 = \u0026#34;Nothing\u0026#39;s here!\u0026#34; [params.assets] favicon = \u0026#34;favicon.ico\u0026#34; customCSS = [\u0026#34;css/custom.css\u0026#34;] customJS = [\u0026#34;js/custom.js\u0026#34;] gopher = \u0026#34;\u0026#34; # used in 404 template ( Generator: https://gopherize.me ) [params.copyright] prefix = \u0026#34;\u0026#34; holder = \u0026#34;mannuan\u0026#34; startYear = \u0026#34;2019\u0026#34; suffix = \u0026#34;\u0026#34; [params.settings] # date \u0026amp; time format: https://golang.org/pkg/time/ dateFormat = \u0026#34;2006, Jan 02\u0026#34; listDateFormat = \u0026#34;2006, Jan 02\u0026#34; archiveDateFormat = \u0026#34;Jan 02\u0026#34; hideEntryNavigation = [\u0026#34;page\u0026#34;] # boolean / array of sections hideEntryMeta = [\u0026#34;page\u0026#34;] # boolean / array of sections showReadingTime = true showLastmod = true taxonomyCloudShuffle = true accentColor = \u0026#34;#FFFFFF\u0026#34; #default hideMainMenu = false rtl = false [params.sidebar] enable = true [params.widgets] header = [\u0026#34;breadcrumbs\u0026#34;] homepage = [\u0026#34;recent_posts\u0026#34;] sidebar = [\u0026#34;about\u0026#34;,\u0026#34;search\u0026#34;,\u0026#34;sidebar_menu\u0026#34;,\u0026#34;taxonomy_cloud\u0026#34;] footer = [\u0026#34;social_menu\u0026#34;] [params.opengraph.facebook] admins = [] # array of Facebook IDs appID = \u0026#34;\u0026#34; pageID = \u0026#34;\u0026#34; [params.opengraph.twitter] page = \u0026#34;\u0026#34; # Twitter page username [params.seo] # Title Separator: - – — · • * ⋆ | ~ « » \u0026lt; \u0026gt; titleSeparator = \u0026#34;•\u0026#34; [params.social] #codepen = \u0026#34;MunifTanjim\u0026#34; email = \u0026#34;mannuandeyangguang@163.com\u0026#34; #facebook = \u0026#34;MunifTanjim\u0026#34; github = \u0026#34;mannuan\u0026#34; #gitlab = \u0026#34;MunifTanjim\u0026#34; #instagram = \u0026#34;MunifTanjim\u0026#34; #linkedin = \u0026#34;muniftanjim\u0026#34; #twitter = \u0026#34;MunifTanjim\u0026#34; #telegram = \u0026#34;MunifTanjim\u0026#34; #google_scholar = \u0026#34;qc6CJjYAAAAJ\u0026#34; #youtube = \u0026#34;UCT-U0rNerYxItGcuoPX-WYA\u0026#34; [params.comments] enable = false # Isso: https://posativ.org/isso/ [params.comments.isso] enable = false scriptSrc = \u0026#34;\u0026#34; # \u0026#34;https://isso.example.com/js/embed.min.js\u0026#34; dataAttrs = \u0026#34;\u0026#34; # \u0026#34;data-isso=\u0026#39;https://isso.example.com\u0026#39; data-isso-require-author=\u0026#39;true\u0026#39;\u0026#34; [params.comments.staticman] enable = true apiEndpoint = \u0026#34;https://api.staticman.net/v2/entry\u0026#34; maxDepth = 2 username = \u0026#34;MunifTanjim\u0026#34; repository = \u0026#34;minimo\u0026#34; branch = \u0026#34;master\u0026#34; # Utterances: https://utteranc.es [params.comments.utterances] enable = false issueTerm = \u0026#34;pathname\u0026#34; # pathname / url / title [params.comments.utterances.github] username = \u0026#34;mannuan\u0026#34; #repository = \u0026#34;minimo\u0026#34; [params.search] client = \u0026#34;fuse\u0026#34; # algolia / fuse / lunr [params.search.algolia] appId = \u0026#34;\u0026#34; indexName = \u0026#34;\u0026#34; searchApiKey = \u0026#34;\u0026#34; [taxonomies] author = \u0026#34;authors\u0026#34; category = \u0026#34;categories\u0026#34; series = \u0026#34;series\u0026#34; tag = \u0026#34;tags\u0026#34; [permalinks] page = \u0026#34;/:slug/\u0026#34; [[menu.main]] name = \u0026#34;Repo\u0026#34; weight = -10 identifier = \u0026#34;repository\u0026#34; url = \u0026#34;https://github.com/mannuan\u0026#34; [blackfriday] hrefTargetBlank = true [languages] # edit this block for your own language [languages.en] lang = \u0026#34;en\u0026#34; languageName = \u0026#34;English\u0026#34; weight = 1 ","href":"/docs/config-file/","title":"Configuration File: config.toml"},{"content":"","href":"/categories/others/","title":"others"},{"content":"","href":"/categories/tutorial/","title":"Tutorial"},{"content":" Updating Minimo Update Minimo clone Just replace the themes/minimo folder with the latest version of Minimo clone, i.e. delete the old folder and clone again:\nrm -rf themes/minimo git clone --depth 1 https://github.com/MunifTanjim/minimo themes/minimo Then, commit the changes:\ngit add themes/minimo git commit -m \u0026#34;update [theme]: minimo\u0026#34; Update Minimo submodule cd themes/minimo git checkout master git fetch \u0026amp;\u0026amp; git pull cd ../.. git add themes/minimo git commit -m \u0026#34;update [theme]: minimo\u0026#34; To Do After Updating Minimo After updating Minimo, always check that your site\u0026rsquo;s config.toml file matches the latest config.toml file format.\nA good idea is to double check all the Configuration settings of Minimo.\n","href":"/docs/updating/","title":"Updating Guide"},{"content":" First of all you will need to setup a Hugo site. You can follow the Hugo\u0026rsquo;s Quick Start Guide for that.\nAfter you\u0026rsquo;re done with that, it\u0026rsquo;s time for installing Minimo!\nInstalling Minimo There are two different ways you can install Minimo:\n As clone As submodule  The second method is recommended.\nInstall Minimo as clone With this method, you will simply clone it. And a copy of Minimo\u0026rsquo;s repository will be stored with the rest of you site. Enter the following command for cloning Minimo:\ngit clone --depth 1 https://github.com/MunifTanjim/minimo themes/minimo Install Minimo as submodule This method doesn\u0026rsquo;t store a copy of Minimo\u0026rsquo;s repository inside your site\u0026rsquo;s repository. Rather it adds Minimo as a dependency. Start by this command:\ngit submodule add https://github.com/MunifTanjim/minimo themes/minimo This will add Minimo\u0026rsquo;s repository as a submodule to your site\u0026rsquo;s repository. Now, you will have to pull the theme:\ngit submodule init git submodule update That\u0026rsquo;s all, Minimo is ready to be used.\nConfiguration for Minimo For getting started with Minimo, copy the config.toml file from the exampleSite directory inside Minimo\u0026rsquo;s repository to your site repository:\ncp themes/minimo/exampleSite/config.toml . You can take a look at the config.toml file of this site.\nNow, you can start editing this file and change the configuration!\nSetting up Authors Follow the Authors Setup Guide for setting up authors for you site.\nSetting up Widgets If you want to use Widgets on your site, take a look at the Widgets documentation\nEt voilà! Minimo is ready!\n","href":"/docs/installation/","title":"Installation Guide"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
