<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端算法类 on mannuan</title>
    <link>https://mannuan.github.io/tags/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E7%B1%BB/</link>
    <description>Recent content in 前端算法类 on mannuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 30 Sep 2019 19:32:54 +0800</lastBuildDate>
    
	<atom:link href="https://mannuan.github.io/tags/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E7%B1%BB/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>剑指offer总结</title>
      <link>https://mannuan.github.io/post/20190930193254/</link>
      <pubDate>Mon, 30 Sep 2019 19:32:54 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190930193254/</guid>
      <description> 剑指offer  二维数组中的查找  左下角 行和列容易混淆 col和row两个指针 循环条件的时候容易写错  替换空格  考察数组的理解 不要使用正则 在末尾填充一些无关字符串  从尾到头打印链表  考察了栈的特点 注意使用unshift  重建二叉树  比较难理解 充分利用前序遍历的递归  用两个栈实现队列  先进后出，在一次”先进后出“，变为先进先出  旋转数组的最小数字  要求时间复杂度达到O(lgn) 只能使用二分 二分比O(n)多一种情况考虑 边界条件需要考虑 不会写二分查找  斐波那契数列  prev, curr双指针 for循环从0开始  跳台阶  斐波那契数列  变态跳台阶  找规律，位运算,[[1,1,1,1],[2,2],[1,1,2],[1,2,1],[2,1,1],[1,3],[3,1],[4]]  矩形覆盖  斐波那契数列 0不在斐波那契数列中  二进制中1的个数  利用了标志位左移&amp;amp;1的思想（这是一种比较耗时的做法，每次都要循环32次,即使只有一个1的时候） n = (n-1)&amp;amp;n   </description>
    </item>
    
  </channel>
</rss>