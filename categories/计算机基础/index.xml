<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机基础 on mannuan</title>
    <link>https://mannuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 计算机基础 on mannuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 26 Aug 2019 22:46:19 +0800</lastBuildDate>
    
	<atom:link href="https://mannuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式</title>
      <link>https://mannuan.github.io/post/20190826224619/</link>
      <pubDate>Mon, 26 Aug 2019 22:46:19 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190826224619/</guid>
      <description> 设计模式 javascript中的设计模式 工厂模式 构造函数模式 考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节
原型模式 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
组合模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式 其他常用设计模式 单例模式  单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点；  享元模式 优点 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
缺点  为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。 读取享元模式的外部状态会使得运行时间稍微变长。  装饰模式 优点  采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。
缺点 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。
  代理模式 优点  代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
 增加了系统的复杂度；
  观察者模式 优点  降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。
缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
  适配器模式 优点  客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。  缺点  对类适配器来说，更换适配器的实现过程比较复杂  </description>
    </item>
    
    <item>
      <title>ASCII码对照表</title>
      <link>https://mannuan.github.io/post/20190825140450/</link>
      <pubDate>Sun, 25 Aug 2019 14:04:50 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190825140450/</guid>
      <description>ASCII码对照表  ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符   0 NUT 32 (space) 64 @ 96 、   1 SOH 33 ! 65 A 97 a   2 STX 34 &#34; 66 B 98 b   3 ETX 35 # 67 C 99 c   4 EOT 36 $ 68 D 100 d   5 ENQ 37 % 69 E 101 e   6 ACK 38 &amp;amp; 70 F 102 f   7 BEL 39 , 71 G 103 g   8 BS 40 ( 72 H 104 h   9 HT 41 ) 73 I 105 i   10 LF 42 * 74 J 106 j   11 VT 43 + 75 K 107 k   12 FF 44 , 76 L 108 l   13 CR 45 - 77 M 109 m   14 SO 46 .</description>
    </item>
    
    <item>
      <title>原码，反码和补码</title>
      <link>https://mannuan.github.io/post/20190723204549/</link>
      <pubDate>Tue, 23 Jul 2019 20:45:49 +0800</pubDate>
      
      <guid>https://mannuan.github.io/post/20190723204549/</guid>
      <description>编码方式 对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是计算机存储一个具体数字的编码方式。
存储方式 数值在计算机是以补码的方式存储的。
机器数 一个数在计算机中的二进制表示形式，比如补码就是机器数的形式。
格式 机器数分为两部分：符号位和数据部分。
符号位 正数为0，负数为1；
 例1: 在字长为8位的计算机中，十进制的&amp;rdquo;+2&amp;rdquo;，转换为二进制为&amp;rdquo;00000010&amp;rdquo;。 例2: 在字长为8位的计算机中，十进制的&amp;rdquo;-2&amp;rdquo;，转换为二进制为&amp;rdquo;10000010&amp;rdquo;。  机器数的真值 带符号位的机器数对应的真正数值。
原码 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值；
反码 反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反；
补码 补码的表示方式是：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）
举例:
   十进制数 原码 反码 补码     85 01010101 01010101 01010101   -85 11010101 10101010 10101011   9 00001001 00001001 00001001   -9 10001001 11110110 11110111    使用补码的原因 反码的来历 计算机底层只有加法器，不支持减法运算，在进行减法运算，会转换为加法运算。即：1-1=1+(-1)。为了解决这个问题，不得不让符号位参与运算，从而产生了反码。
补码的来历 在用反码进行计算时，出现了&amp;rdquo;0&amp;rdquo;这个特殊的数值，0带符号是没有任何意义的。即有&amp;rdquo;00000000&amp;rdquo;和&amp;rdquo;10000000&amp;rdquo;两个编码表示0。于是设计了补码，负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码到的问题：用&amp;rdquo;00000000&amp;rdquo;表示0，用&amp;rdquo;10000000&amp;rdquo;表示-128。
 注意：-128实际上是使用-0的补码来表示的，所以-128并没有原码和反码。而使用补码之后，就修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用补码表示的范围为[-128, 127]。</description>
    </item>
    
  </channel>
</rss>