<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>面向对象</title>
	</head>
	<body>
		<script type="text/javascript">
			// 类的声明
			function Animal(){
				this.name = "name";
			}
			// es6类的声明
			class Animal2{
				constructor(){
					this.name = "name";
				}
			}
			// 类的实例化
			var animal = new Animal();
			var animal2 = new Animal2();
			console.log(animal, animal2);
			
			/**
			 * 继承的方式
			 * **/
			 
			// 借助构造函数
			function Parent1(){
				this.name = "Parent1";
			}
			Parent1.prototype.age = "age";
			Parent1.prototype.say = function(){};
			function Child1(){
				Parent1.call(this);
				this.type = "child1";
			}
			var s1 = new Child1;
			console.log(s1, s1.age, s1.say);
			// 缺点: 无法获得父类的原型链上的属性和方法
			
			// 借助原型链
			function Parent2(){
				this.name = "parent2";
				this.say = [1,2,3];
			}
			function Child2(){
				this.type = "child2";
			}
			Child2.prototype = new Parent2;
			var s2 = new Child2();
			var s3  = new Child2();
			s3.say.push(4);
			console.log(s2 instanceof Child2, s2 instanceof Parent2, s2.say, s3.say);
			// 缺点: 每个实例之间共享原型链上的数据,不隔离
			
			// 组合方式
			function Parent3(){
				this.name = "parent3";
				this.say = [1,2,3];
			}
			function Child3(){
				Parent3.call(this);
				this.type = "child3";
			}
			Child3.prototype = new Parent3();
			var s4 = new Child3;
			var s5 = new Child3;
			s4.say.push(4);
			console.log(s4 instanceof Child3, s5 instanceof Child3, s4 instanceof Parent3, s5 instanceof Parent3);
			console.log(s4.say, s5.say);
			// 缺点: 父类的构造函数被执行了两次
			
			// 组合方式优化一
			function Parent4(){
				this.name = "parent4";
			}
			function Child4(){
				Parent4.call(this);
				this.type = "child4";
			}
			Child4.prototype = Parent4.prototype;
			var s6 = new Child4;
			console.log(s6 instanceof Child4, s6 instanceof Parent4);
			console.log(s6.__proto__.constructor);
			// 缺点构造函数的指向出错
			
			// 组合方式优化二
			function Parent5(){
				this.name = "parent5";
			}
			function Child5(){
				Parent5.call(this);
				this.type = "child5";
			}
			Child5.prototype = Object.create(Parent5.prototype);
			Child5.prototype.constructor = Child5;
			var s7 = new Child5;
			console.log(s7.__proto__.constructor, s7 instanceof Child5, s7 instanceof Parent5);
		</script>
	</body>
</html>
